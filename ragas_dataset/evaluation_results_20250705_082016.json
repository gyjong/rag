{
  "timestamp": "2025-07-05T08:20:16.893629",
  "evaluation_metrics": [
    "answer_relevancy",
    "faithfulness",
    "context_recall",
    "context_precision"
  ],
  "results": {
    "Naive RAG": {
      "detailed_scores": {
        "user_input": {
          "0": "RAG의 약자는 무엇인가?",
          "1": "RAG의 세 가지 핵심 요소는?",
          "2": "Naive RAG의 핵심 구성 요소는 무엇인가?",
          "3": "Naive RAG의 작동 방식은?",
          "4": "Naive RAG의 한계 중 하나인 'Shallow Query Understanding'을 한국어로 무엇이라 하는가?",
          "5": "Advanced RAG에서 도입된 사전 검색 처리 기법 두 가지는?",
          "6": "Advanced RAG의 사후 검색 처리 기법 예시 두 가지는?",
          "7": "Modular RAG의 핵심 개념은?",
          "8": "Modular RAG의 3단계 구조를 쓰시오.",
          "9": "Module, Submodule, Operator 각각의 역할을 간략히 설명하시오.",
          "10": "Modular RAG의 '오케스트레이션 모듈'의 기능은?",
          "11": "Modular RAG의 동적 워크플로우 예시 패턴 세 가지는?",
          "12": "Modular RAG에서 'Hybrid Search'는 어떤 검색 기법을 결합하는가?",
          "13": "Modular RAG의 'Pre-retrieval' 모듈의 Operator 예시를 두 가지 쓰시오.",
          "14": "Retrieval 모듈의 Operator 중 하나를 쓰시오.",
          "15": "Post-Retrieval 모듈의 Operator 중 두 가지는?",
          "16": "Generation 모듈에서 사용되는 Operator 예시 두 가지는?",
          "17": "Modular RAG의 장점으로 'Componentized Architecture'가 의미하는 바는?",
          "18": "Modular RAG의 다중 데이터 소스 통합이 가능한 이유는?",
          "19": "LangGraph를 활용한 오케스트레이션이 제공하는 기능은?",
          "20": "GraphRAG의 핵심 구성 요소 다섯 가지를 쓰시오.",
          "21": "GraphRAG가 기존 RAG 대비 강화하는 주요 이점은?",
          "22": "LinkedIn이 GraphRAG를 도입한 목적은?",
          "23": "LinkedIn GraphRAG 시스템이 이슈 해결 시간을 얼마나 단축했는가?",
          "24": "Naive RAG를 적용하기 적합한 분야는?",
          "25": "Advanced RAG를 주로 활용하는 도메인은?",
          "26": "Modular RAG가 특히 강력한 성능을 발휘하는 분야는?",
          "27": "RAG의 발전 순서를 나열하시오.",
          "28": "RAG의 주요 문제점 중 하나인 'Hallucination'은 무엇을 의미하는가?",
          "29": "Modular RAG의 '루프 패턴'은 어떤 처리 방식을 말하는가?",
          "30": "조건부 패턴에서 사용되는 주요 기능은?",
          "31": "분기 패턴이 제공하는 이점은?",
          "32": "Tuning Pattern의 역할은?",
          "33": "RAG의 한계 중 '출처 불명확성'을 개선하기 위한 기법은?",
          "34": "Modular RAG에서 'Reducer' 연산자의 역할은?",
          "35": "Modular RAG의 'Summarizer' Operator는 무슨 역할을 하는가?",
          "36": "Modular RAG의 'Paraphraser' Operator 기능은?",
          "37": "금융 도메인에서 활용되는 RAG 패턴은?",
          "38": "의료 도메인에서 Query Expansion이 필요한 이유는?",
          "39": "법률 도메인에서 Judge 모듈의 역할은?",
          "40": "전자상거래 도메인에서 RRR 패턴의 구성 단계는?",
          "41": "GraphRAG에서 '구성기(Organizer)'의 역할은?",
          "42": "GraphRAG를 구성하는 '생성기(Generator)'의 주요 기능은?",
          "43": "GraphRAG의 데이터 소스 예시 세가지를 쓰시오.",
          "44": "Modular RAG에서 'Scheduling' Operator의 역할은?",
          "45": "Modular RAG에서 'Fusion' Operator는 어떤 역할을 하는가?",
          "46": "Advanced RAG의 쿼리 재작성에 사용되는 기법 'HyDE'는 무엇의 약자인가?",
          "47": "RAG에서 'BM25'는 어떤 검색 방식의 일종인가?",
          "48": "Modular RAG의 'Componentized Architecture' 장점 중 하나를 쓰시오.",
          "49": "LinkedIn GraphRAG에서는 검색 시 어떤 거리 측정 방법을 사용했는가?"
        },
        "retrieved_contexts": {
          "0": [
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이"
          ],
          "1": [
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion"
          ],
          "2": [
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다."
          ],
          "3": [
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com"
          ],
          "4": [
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com"
          ],
          "5": [
            "2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다. \n주요 전략 사전 검색 처리 (Pre-retrieval processing): ● 쿼리 재작성(query rewriting): 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. ● 쿼리 확장(query expansion): 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다. ● 쿼리 변환(query transformation): 원래 쿼리 대신 변환된 쿼리를 기반으로 검색 및 생성을 수행합니다.\n사후 검색 처리 (Post-retrieval processing): ● 검색 결과 재정렬(reranking): 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다. ● 압축(compression): 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다. ● 선택(selection): 관련 없는 덩어리를 직접 제거하여 LLM의 추론 효율성을 향상시킵니다.  \n특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담"
          ],
          "6": [
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다. \n주요 전략 사전 검색 처리 (Pre-retrieval processing): ● 쿼리 재작성(query rewriting): 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. ● 쿼리 확장(query expansion): 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다. ● 쿼리 변환(query transformation): 원래 쿼리 대신 변환된 쿼리를 기반으로 검색 및 생성을 수행합니다.\n사후 검색 처리 (Post-retrieval processing): ● 검색 결과 재정렬(reranking): 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다. ● 압축(compression): 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다. ● 선택(selection): 관련 없는 덩어리를 직접 제거하여 LLM의 추론 효율성을 향상시킵니다.  \n특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 향상된 검색 기법: 질의 처리 후 하이브리드 검색(밀도 기반 임베딩 검색 + 희소 키워드 검색)을 활용해 더 풍부한 결과를 얻습니다 ibm.com . 복잡한 질문의 경우 계층적 인덱싱이나 다단계 검색(예: iterative/recursive retrieval)으로 한층 심화된 검색을 수행하여 정확도를 높입니다 arxiv.org  arxiv.org . \n• 다중 모듈 검색: 질의 종류와 목적에 따라 여러 검색 모듈을 조합합니다. 예를 들어, 임베딩 기반 벡터 검색에 더해 지식 그래프 질의나 API 호출 등 이기종 데이터 검색을 병행할 수 있습니다. 또한 복잡한 문제에 대해 반복적 검색이나 분기 검색 흐름을 구현하여 필요한 정보를 순차적으로 수집할 수 있습니다 arxiv.org . 이러한 유연한 검색 설계로 질의의 의도에 맞게 다양한 소스에서 정보를 획득합니다. 모델 아키텍처 (Model Architecture) • 선형 파이프라인 구조: 인덱싱 → 검색 → 생성의 직렬 단계로 구성된 가장 단순한 형태입니다 arxiv.org . 별도의 최적화 모듈이나 피드백 루프 없이, 검색기와 한 번의 생성기로 답변을 생성합니다. 전체 구조가 단순하여 추가 구성요소가 없습니다. \n• 개선된 단일 흐름 구조: 기본 RAG 파이프라인에 전처리/후처리 모듈을 추가한 구조입니다. 예를 들어, 질의 재작성 모듈로 입력 질문을 명확히 하고 arxiv.org , 재검색 및 재정렬 모듈로 검색 결과를 필터링한 후 LLM에 전달합니다. 응답 생성 후에는 사용자 클릭이나 피드백 등을 활용한 피드백 루프를 도입해 검색기와 생성기를 지속적으로 개선하기도 합니다 \n• 모듈식 아키텍처: 여러 독립 모듈을 레고 블록처럼 연결하여 구성한 프레임워크입니다 arxiv.org . 질의 처리, 검색, 필터링, 생성, 검증 등의 기능이 분리된 모듈로 구현되고, 이들을 제어하는 라우팅/스케줄링 컴포넌트가 존재합니다 arxiv.org . 덕분에 비선형적 흐름도 가능하며 (예: 조건분기나"
          ],
          "7": [
            "Modular RAG에서 AI Agent 아키텍처 Modular RAG(Retrieval-Augmented Generation) 기반 AI 시스템은 정보 검색(Retrieval)과 생성(Generation)을 기능을 모듈화하여 구성된 구조로, 여러 독립적인 모듈을 조합하여 유연하고 확장 가능한 AI를 구축하는 방식입니다. 이 시스템의 핵심 구성 요소는 에이전트(Agent) 모듈(Modules)입니다. 에이전트(Agent)는 전체 워크플로우를 조율하여, 전체시스템의 흐름과 전략적 제어를 담당하는 핵심 역할을 합니다. 기존의 LLM(대규모 언어 모델)이 주로 사전 학습된 지식과 인컨텍스트 학습에 의존하는 것과 달리, 에이전트는 외부 도구(예: 웹 검색, API, 구조화된 데이터베이스)와 동적으로 상호작용하여 그 능력을 확장합니다. 에이전트는 주어진 작업에 따라 어떤 도구를 호출할지 자율적으로 결정하며, 이를 통해 더 정확하고 상황에 맞는 응답을 생성할 수 있습니다. 또한, 에이전트는 고급 라우팅 메커니즘을 활용하여 사용자 쿼리를 분석하고 가장 적합한 데이터 소스나 처리 경로로 안내합니다. 예를 들어, 특정 데이터베이스에서 정보를 검색해야 하는지, 웹 검색을 수행해야 하는지, 또는 도메인 특화 지식을 활용해야 하는지를 스스로 판단할 수 있습니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담"
          ],
          "8": [
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다."
          ],
          "9": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.   \n3.3 서브모듈 하위 모듈 정의 하위 모듈은 상위 모듈의 특정 기능을 세분화하여 실행하는 단위이며, 필요에 따라 추가되거나 조합될 수도 있습니다. 부 시스템에서는 특정 하위 모듈이 여러 모듈에서 공유되거나 독립적으로 실행될 수도 있습니다   \n하위 모듈 역할 하나의 모듈 내에서 복잡한 작업을 여러 하위 단계로 분리하여, 각 단계가 담당하는 역할을 명확히 합니다. 복잡한 작업을 작은 단계로 나누어 처리함으로써 효율성을 높입니다. 상위 모듈의 성능과 유연성을 강화하기 위해 하위 모듈은 세부적인 기능 구현에 집중합니다. 각 하위 모듈은 상위 모듈의 특정 기능을 담당하며, 이를 통해 문제 발생 시 해당 부분만 집중적으로 개선하거나 수정할 수 있습니다. 즉, 하위 모듈은 상위 모듈 내에서 복잡한 작업을 여러 단계로 분리함으로써, 각 단계의 역할과 책임을 명확히 하고, 이를 통해 문제 발생 시 해당 부분만 집중적으로 개선하거나 수정할 수 있도록 지원합니다.   \n하위모듈 특징 ● 세분화 (Decomposition): 상위 모듈의 복잡한 기능을 작고 명확한 단계로 분할하여 관리합니다. ● 독립성 (Independence): 각 하위 모듈은 서로 간섭 없이 독립적으로 작동하여, 다른 부분에 미치는 영향을 최소화합니다. ● 유지보수성 (Maintainability): 문제 발생 시 개별 하위 모듈만 수정하면 되어, 전체 시스템의 유지보수가 용이합니다. ● 재사용성 (Reusability): 잘 정의된 하위 모듈은 다른 모듈이나 프로젝트에서도 쉽게 재사용할 수 있습니다.",
            "3.2 모듈  모듈 정의 모듈은 Modular RAG 시스템의 핵심 구성 블록으로 시스템의 주요 기능이나 임무(예: 정보 검색, 요약, 텍스트 생성 등)를 독립적으로 수행하는 단위입니다. 각 모듈은 특정 작업을 독립적으로 수행하도록 설계되며, 다른 모듈과 별개로 동작할 수 있습니다.  \n모듈의 역할 모듈은 사용자의 요청에 따른 특정 기능을 직접 수행합니다. 모듈은 특정 기능이나 작업을 독립적으로 수행하는 구성 요소입니다. 각 모듈은 전문화된 기능을 담당하며, 에이전트의 지시에 따라 협력하여 최종 목표를 달성합니다.  예를 들어, 검색 모듈은 외부 데이터 소스에서 관련 정보를 검색하고, 생성 모듈은 최종 응답을 생성하는 역할, 데이터 전처리, 텍스트 생성 등의 개별 기능을 담당할 수 있습니다.   \n모듈의 특징 ● 독립성 및 모듈화: 모듈은 독립적인 단위로 설계되어 다른 모듈과 별개로 작동할 수 있으며, 모듈화된 구조를 유지합니다. ● 전문화: 각 모듈은 특정 작업이나 기능에 집중하여 해당 분야에서 최적화되고 전문성을 갖출 수 있습니다. ● 재사용성 및 유연성: 모듈은 시스템 내에서 재사용할 수 있으며, 필요에 따라 쉽게 수정, 교체, 확장할 수 있습니다. 또한, 다른 프로젝트에서도 활용할 수 있습니다. ● 확장성: 새로운 기능이나 서비스가 필요할 경우, 기존 모듈을 확장하거나 새로운 모듈을 추가하여 시스템을 발전시킬 수 있습니다. ● 조합성: 여러 모듈을 결합하여 복잡한 작업을 처리하거나 새로운 기능을 추가할 수 있습니다.\n모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다."
          ],
          "10": [
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "3.2 모듈  모듈 정의 모듈은 Modular RAG 시스템의 핵심 구성 블록으로 시스템의 주요 기능이나 임무(예: 정보 검색, 요약, 텍스트 생성 등)를 독립적으로 수행하는 단위입니다. 각 모듈은 특정 작업을 독립적으로 수행하도록 설계되며, 다른 모듈과 별개로 동작할 수 있습니다.  \n모듈의 역할 모듈은 사용자의 요청에 따른 특정 기능을 직접 수행합니다. 모듈은 특정 기능이나 작업을 독립적으로 수행하는 구성 요소입니다. 각 모듈은 전문화된 기능을 담당하며, 에이전트의 지시에 따라 협력하여 최종 목표를 달성합니다.  예를 들어, 검색 모듈은 외부 데이터 소스에서 관련 정보를 검색하고, 생성 모듈은 최종 응답을 생성하는 역할, 데이터 전처리, 텍스트 생성 등의 개별 기능을 담당할 수 있습니다.   \n모듈의 특징 ● 독립성 및 모듈화: 모듈은 독립적인 단위로 설계되어 다른 모듈과 별개로 작동할 수 있으며, 모듈화된 구조를 유지합니다. ● 전문화: 각 모듈은 특정 작업이나 기능에 집중하여 해당 분야에서 최적화되고 전문성을 갖출 수 있습니다. ● 재사용성 및 유연성: 모듈은 시스템 내에서 재사용할 수 있으며, 필요에 따라 쉽게 수정, 교체, 확장할 수 있습니다. 또한, 다른 프로젝트에서도 활용할 수 있습니다. ● 확장성: 새로운 기능이나 서비스가 필요할 경우, 기존 모듈을 확장하거나 새로운 모듈을 추가하여 시스템을 발전시킬 수 있습니다. ● 조합성: 여러 모듈을 결합하여 복잡한 작업을 처리하거나 새로운 기능을 추가할 수 있습니다.\n모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로"
          ],
          "11": [
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담 \n이 표를 통해 각 RAG 방법론의 특징을 비교하고, 프로젝트 목적과 요구사항에 맞는 최적의 방식을 선택하는 데 도움이 될 수 있습니다. Modular RAG는 높은 유연성과 확장성을 제공하여, 특히 복잡한 도메인 지식이 필요한 분야에서 강력한 성능을 발휘할 수 있습니다.\n3. Modular RAG의 주요 구성 요소 Modular RAG에서 계층구조의 구성 요소와 역할과 세부 내용을 알아봅니다. Agent Workflow Module 주요 프로세스(검색, 증강, 생성 등)를 담당 Submodule 모듈 내부에서 세부적인 작업 단계를 처리 Operator 데이터 처리 및 변환과 같은 기본적인 작업 단위를 수행 \n3.1 Agent 기반의 아키텍처 Modular RAG의 핵심 요소 중 하나는 Agent 기반 아키텍처입니다. 기존 AI 에이전트와 비교했을 때, Modular RAG의 에이전트는 다중 모듈을 조율하고 특정 작업을 수행하는 방식으로 설계됩니다. 이를 통해 보다 유연하고 확장 가능한 AI 시스템을 구축할 수 있습니다. \nAI Agent 아키텍처 AI 에이전트는 특정 목표를 달성하기 위해 환경에서 데이터를 감지하고, 해석하며, 행동하는 시스템입니다. AI 에이전트 아키텍처는 인공지능 시스템이 환경을 인식하고, 분석하며, 행동하는 방식을 정의하는 구조적 설계입니다. 이는 AI 에이전트가 자율적으로 작동하고 목표를 달성할 수 있도록 하는 핵심 요소를 포함하며, 다양한 구성 요소와 설계 패턴으로 이루어집니다."
          ],
          "12": [
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다."
          ],
          "13": [
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "※ 참고: 이 예시에서는 코드 내에 Operator와 Sub-module이 직접적으로 드러나지는 않지만, 각 모듈 내부에서 해당 역할을 추상화하여 수행하고 있음을 유념하시기 바랍니다. Building a PDF-Based Retriever Chain from rag.pdf import PDFRetrievalChain  pdf = PDFRetrievalChain([\"data/Newwhitepaper_Agents2.pdf\"]).create_chain()  pdf_retriever = pdf.retriever  pdf_chain = pdf.chain   Query router  chain from typing import Literal  from langchain_core.prompts import ChatPromptTemplate from pydantic import BaseModel, Field from langchain_openai import ChatOpenAI   # 1. Define a Pydantic model for data routing class RouteQuery(BaseModel):     \"\"\"Route a user query to the most relevant datasource.\"\"\"      datasource: Literal[\"vectorstore\", \"web_search\"] = Field(         ...,         description=\"Given a user question choose to route it to web search or a vectorstore.\",",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다."
          ],
          "14": [
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다.",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "※ 참고: 이 예시에서는 코드 내에 Operator와 Sub-module이 직접적으로 드러나지는 않지만, 각 모듈 내부에서 해당 역할을 추상화하여 수행하고 있음을 유념하시기 바랍니다. Building a PDF-Based Retriever Chain from rag.pdf import PDFRetrievalChain  pdf = PDFRetrievalChain([\"data/Newwhitepaper_Agents2.pdf\"]).create_chain()  pdf_retriever = pdf.retriever  pdf_chain = pdf.chain   Query router  chain from typing import Literal  from langchain_core.prompts import ChatPromptTemplate from pydantic import BaseModel, Field from langchain_openai import ChatOpenAI   # 1. Define a Pydantic model for data routing class RouteQuery(BaseModel):     \"\"\"Route a user query to the most relevant datasource.\"\"\"      datasource: Literal[\"vectorstore\", \"web_search\"] = Field(         ...,         description=\"Given a user question choose to route it to web search or a vectorstore.\",",
            "·         청크 최적화(Chunk Optimization): 청크 크기 조정, 겹침 조정, 메타데이터 추가. ·         구조 조직(Structural Organization): 계층적 인덱싱 및 지식 그래프(KG) 기반 인덱싱. Operator는 청크 분할 및 구조화 작업으로 데이터 처리와 관련된 역할을 합니다. 2.     Pre-Retrieval: ·         모듈: 원본 질의를 개선하여 검색 성능을 최적화하는 과정. ·         Operator: ·         Query Expansion (질의 확장): Multi-Query, Sub-Query. ·         Query Transformation (질의 변환): Rewrite, HyDE, Step-back Prompting. ·         Query Construction (질의 구성): Text-to-SQL, Text-to-Cypher. Operator는 질의를 변환하고 확장하는 작업은 데이터 변환 및 분석에 해당합니다. 3.     Retrieval: ·         모듈: 사용자 질의를 기반으로 관련 문서를 검색. ·         Operator: ·         Retriever Selection (검색기 선택): Sparse, Dense, Hybrid Retriever. ·         Retriever Fine-tuning (검색기 미세 조정): Supervised Fine-Tuning(SFT), Adapter. Operator는 검색기 선택과 미세 조정은 검색 효율성을 높이는 핵심 작업을 합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context,",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징"
          ],
          "15": [
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다.",
            "·         청크 최적화(Chunk Optimization): 청크 크기 조정, 겹침 조정, 메타데이터 추가. ·         구조 조직(Structural Organization): 계층적 인덱싱 및 지식 그래프(KG) 기반 인덱싱. Operator는 청크 분할 및 구조화 작업으로 데이터 처리와 관련된 역할을 합니다. 2.     Pre-Retrieval: ·         모듈: 원본 질의를 개선하여 검색 성능을 최적화하는 과정. ·         Operator: ·         Query Expansion (질의 확장): Multi-Query, Sub-Query. ·         Query Transformation (질의 변환): Rewrite, HyDE, Step-back Prompting. ·         Query Construction (질의 구성): Text-to-SQL, Text-to-Cypher. Operator는 질의를 변환하고 확장하는 작업은 데이터 변환 및 분석에 해당합니다. 3.     Retrieval: ·         모듈: 사용자 질의를 기반으로 관련 문서를 검색. ·         Operator: ·         Retriever Selection (검색기 선택): Sparse, Dense, Hybrid Retriever. ·         Retriever Fine-tuning (검색기 미세 조정): Supervised Fine-Tuning(SFT), Adapter. Operator는 검색기 선택과 미세 조정은 검색 효율성을 높이는 핵심 작업을 합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context,",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "※ 참고: 이 예시에서는 코드 내에 Operator와 Sub-module이 직접적으로 드러나지는 않지만, 각 모듈 내부에서 해당 역할을 추상화하여 수행하고 있음을 유념하시기 바랍니다. Building a PDF-Based Retriever Chain from rag.pdf import PDFRetrievalChain  pdf = PDFRetrievalChain([\"data/Newwhitepaper_Agents2.pdf\"]).create_chain()  pdf_retriever = pdf.retriever  pdf_chain = pdf.chain   Query router  chain from typing import Literal  from langchain_core.prompts import ChatPromptTemplate from pydantic import BaseModel, Field from langchain_openai import ChatOpenAI   # 1. Define a Pydantic model for data routing class RouteQuery(BaseModel):     \"\"\"Route a user query to the most relevant datasource.\"\"\"      datasource: Literal[\"vectorstore\", \"web_search\"] = Field(         ...,         description=\"Given a user question choose to route it to web search or a vectorstore.\","
          ],
          "16": [
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "※ 참고: 이 예시에서는 코드 내에 Operator와 Sub-module이 직접적으로 드러나지는 않지만, 각 모듈 내부에서 해당 역할을 추상화하여 수행하고 있음을 유념하시기 바랍니다. Building a PDF-Based Retriever Chain from rag.pdf import PDFRetrievalChain  pdf = PDFRetrievalChain([\"data/Newwhitepaper_Agents2.pdf\"]).create_chain()  pdf_retriever = pdf.retriever  pdf_chain = pdf.chain   Query router  chain from typing import Literal  from langchain_core.prompts import ChatPromptTemplate from pydantic import BaseModel, Field from langchain_openai import ChatOpenAI   # 1. Define a Pydantic model for data routing class RouteQuery(BaseModel):     \"\"\"Route a user query to the most relevant datasource.\"\"\"      datasource: Literal[\"vectorstore\", \"web_search\"] = Field(         ...,         description=\"Given a user question choose to route it to web search or a vectorstore.\",",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723"
          ],
          "17": [
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다."
          ],
          "18": [
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자"
          ],
          "19": [
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "설계 방법 LinkedIn은 시스템은 과거 고객 서비스 문제 티켓에서 Knowledge Graph를 구축하고, 질문 응답 단계에서 소비자 쿼리를 파싱하여 관련 하위 그래프를 식별하고 답변을 생성합니다. 주요 사용 방법은 다음과 같습니다.\n● 지식 그래프 구축 (Knowledge Graph Construction) ○ Intra-ticket 트리 파싱: 텍스트 기반 티켓을 트리 구조로 변환합니다. 규칙 기반 추출과 LLM 파싱을 함께 사용하여 티켓 섹션을 식별하고 계층적으로 연결합니다. ○ Inter-ticket 연결: 개별 트리를 통합하여 포괄적인 그래프를 형성합니다. 티켓에 명시된 명시적 연결과 텍스트 의미 유사성을 기반으로 한 암시적 연결을 모두 활용합니다. ○ 임베딩 생성: BERT, E5와 같은 텍스트 임베딩 모델을 사용하여 그래프 노드 값에 대한 임베딩을 생성하고, 벡터 데이터베이스에 저장하여 검색을 용이하게 합니다. ● 검색 및 질문 응답 (Retrieval and Question Answering) ○ 쿼리 엔터티 식별 및 의도 감지: 사용자 쿼리에서 명명된 엔터티와 쿼리 의도를 추출합니다. LLM을 사용하여 쿼리를 파싱하고, 그래프 템플릿에 따라 키-값 쌍을 추출합니다.\n○ 하위 그래프의 임베딩 기반 검색: 사용자 쿼리에서 파생된 엔터티를 사용하여 관련 하위 그래프를 검색합니다. 코사인 유사도를 사용하여 티켓 수준 점수를 집계하고 상위 K개 티켓을 선택합니다. ○ 답변 생성: 검색된 데이터를 초기 쿼리와 연결하여 답변을 합성합니다. LLM은 검색된 정보를 기반으로 응답을 생성하는 디코더 역할을 합니다. 쿼리 실행에 문제가 발생하면 텍스트 기반 검색 방법으로 대체합니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다."
          ],
          "20": [
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ],
          "21": [
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "6. Conclusion 이 리포트에서는 RAG(Retrieval-Augmented Generation)의 발전 방향을 분석하기 위해, 최근 주목받고 있는 Modular RAG를 중심으로 기존 RAG 패러다임(Naive RAG, Advanced RAG)과 비교하고, 새롭게 등장한 GraphRAG까지 다루었습니다. RAG는 LLM의 한계를 보완하며, 보다 신뢰할 수 있는 검색과 응답 생성을 목표로 발전해왔습니다. 기존 Naive RAG는 단순 검색 기반이었으며, Advanced RAG는 검색 최적화를 추가하여 성능을 향상시켰습니다. 이후 Modular RAG는 검색, 생성, 색인 기능을 독립적인 모듈로 분리하여 유연성과 확장성을 극대화하는 구조로 발전했습니다.  그러나 여전히 검색된 정보의 신뢰성과 정확성을 높이는 것이 중요한 과제로 남아 있으며, 이를 해결하기 위해 GraphRAG가 도입되었습니다. GraphRAG는 기존 벡터 검색의 한계를 보완하기 위해 지식 그래프(Knowledge Graph)를 활용한 검색 방식을 도입하여, 문서 간의 관계를 반영한 보다 정밀한 정보를 제공합니다. LinkedIn 사례에서는 GraphRAG 도입 후 검색 정확도 77.6% 향상, BLEU 점수 0.32 증가, 고객 서비스 해결 시간이 28.6% 단축되는 성과를 거두었습니다. 기존 RAG는 벡터 검색(Vector RAG)에 의존했지만, 최근 GraphRAG, Adaptive Retrieval, Multi-Agent RAG 등의 개념이 등장하며 검색 정확도, 신뢰성, 실시간성, 맥락 최적화가 더욱 강화되고 있습니다. 현재까지의 발전 흐름을 보면, 앞으로는 검색 전략을 스스로 최적화하는 자율적 검색 시스템까지 발전될 수 있는 가능성이 있습니다."
          ],
          "22": [
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "개선사항 구조를 무시하여 발생하는 검색 정확도 저하를 개선 이슈 추적 문서(예: Jira)는 고유한 구조를 가지고 있으며, \"이슈 A는 이슈 B와 관련됨/복사됨/원인이 됨\"과 같은 참조로 상호 연결됩니다. 문서를 텍스트 덩어리로 압축하는 기존 방식은 중요한 정보의 손실을 초래할 수 있습니다. LinkedIn의 접근 방식은 이슈 티켓을 트리로 파싱하고 개별 이슈 티켓을 연결하여 상호 연결된 그래프를 형성함으로써 엔터티 간의 내재적 관계를 유지하여 높은 검색 성능을 달성합니다. \n세분화로 인한 답변 품질 저하를 개선 임베딩 모델의 컨텍스트 길이 제약을 수용하기 위해 광범위한 이슈 티켓을 고정 길이 세그먼트로 분할하면 관련 콘텐츠가 단절되어 불완전한 답변이 발생할 수 있습니다. 예를 들어, 이슈 티켓이 시작 부분에 이슈를 설명하고 끝 부분에 솔루션을 설명하는 경우 텍스트 세분화 프로세스 중에 분할되어 솔루션의 중요한 부분이 생략될 수 있습니다. LinkedIn의 그래프 기반 파싱 방법은 티켓 섹션의 논리적 일관성을 유지하여 완전하고 고품질의 응답을 제공함으로써 이 문제를 극복합니다.  \n결과 LinkedIn의 고객 서비스 팀 내에서 이 방법론을 사용한 결과, 이슈당 중간 해결 시간이 28.6% 감소했습니다. 이는 기존의 수동 방법에 비해 상당한 개선입니다. 구체적으로, Knowledge Graph를 사용하지 않은 그룹의 평균 이슈 해결 시간은 40시간인데 반해, Knowledge Graph를 사용한 그룹은 15시간으로 단축되었습니다. 이는 RAG와 지식 그래프의 통합이 고객 서비스 효율성을 향상시킬 수 있음을 보여줍니다",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "설계 방법 LinkedIn은 시스템은 과거 고객 서비스 문제 티켓에서 Knowledge Graph를 구축하고, 질문 응답 단계에서 소비자 쿼리를 파싱하여 관련 하위 그래프를 식별하고 답변을 생성합니다. 주요 사용 방법은 다음과 같습니다.\n● 지식 그래프 구축 (Knowledge Graph Construction) ○ Intra-ticket 트리 파싱: 텍스트 기반 티켓을 트리 구조로 변환합니다. 규칙 기반 추출과 LLM 파싱을 함께 사용하여 티켓 섹션을 식별하고 계층적으로 연결합니다. ○ Inter-ticket 연결: 개별 트리를 통합하여 포괄적인 그래프를 형성합니다. 티켓에 명시된 명시적 연결과 텍스트 의미 유사성을 기반으로 한 암시적 연결을 모두 활용합니다. ○ 임베딩 생성: BERT, E5와 같은 텍스트 임베딩 모델을 사용하여 그래프 노드 값에 대한 임베딩을 생성하고, 벡터 데이터베이스에 저장하여 검색을 용이하게 합니다. ● 검색 및 질문 응답 (Retrieval and Question Answering) ○ 쿼리 엔터티 식별 및 의도 감지: 사용자 쿼리에서 명명된 엔터티와 쿼리 의도를 추출합니다. LLM을 사용하여 쿼리를 파싱하고, 그래프 템플릿에 따라 키-값 쌍을 추출합니다.\n○ 하위 그래프의 임베딩 기반 검색: 사용자 쿼리에서 파생된 엔터티를 사용하여 관련 하위 그래프를 검색합니다. 코사인 유사도를 사용하여 티켓 수준 점수를 집계하고 상위 K개 티켓을 선택합니다. ○ 답변 생성: 검색된 데이터를 초기 쿼리와 연결하여 답변을 합성합니다. LLM은 검색된 정보를 기반으로 응답을 생성하는 디코더 역할을 합니다. 쿼리 실행에 문제가 발생하면 텍스트 기반 검색 방법으로 대체합니다."
          ],
          "23": [
            "개선사항 구조를 무시하여 발생하는 검색 정확도 저하를 개선 이슈 추적 문서(예: Jira)는 고유한 구조를 가지고 있으며, \"이슈 A는 이슈 B와 관련됨/복사됨/원인이 됨\"과 같은 참조로 상호 연결됩니다. 문서를 텍스트 덩어리로 압축하는 기존 방식은 중요한 정보의 손실을 초래할 수 있습니다. LinkedIn의 접근 방식은 이슈 티켓을 트리로 파싱하고 개별 이슈 티켓을 연결하여 상호 연결된 그래프를 형성함으로써 엔터티 간의 내재적 관계를 유지하여 높은 검색 성능을 달성합니다. \n세분화로 인한 답변 품질 저하를 개선 임베딩 모델의 컨텍스트 길이 제약을 수용하기 위해 광범위한 이슈 티켓을 고정 길이 세그먼트로 분할하면 관련 콘텐츠가 단절되어 불완전한 답변이 발생할 수 있습니다. 예를 들어, 이슈 티켓이 시작 부분에 이슈를 설명하고 끝 부분에 솔루션을 설명하는 경우 텍스트 세분화 프로세스 중에 분할되어 솔루션의 중요한 부분이 생략될 수 있습니다. LinkedIn의 그래프 기반 파싱 방법은 티켓 섹션의 논리적 일관성을 유지하여 완전하고 고품질의 응답을 제공함으로써 이 문제를 극복합니다.  \n결과 LinkedIn의 고객 서비스 팀 내에서 이 방법론을 사용한 결과, 이슈당 중간 해결 시간이 28.6% 감소했습니다. 이는 기존의 수동 방법에 비해 상당한 개선입니다. 구체적으로, Knowledge Graph를 사용하지 않은 그룹의 평균 이슈 해결 시간은 40시간인데 반해, Knowledge Graph를 사용한 그룹은 15시간으로 단축되었습니다. 이는 RAG와 지식 그래프의 통합이 고객 서비스 효율성을 향상시킬 수 있음을 보여줍니다",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "설계 방법 LinkedIn은 시스템은 과거 고객 서비스 문제 티켓에서 Knowledge Graph를 구축하고, 질문 응답 단계에서 소비자 쿼리를 파싱하여 관련 하위 그래프를 식별하고 답변을 생성합니다. 주요 사용 방법은 다음과 같습니다.\n● 지식 그래프 구축 (Knowledge Graph Construction) ○ Intra-ticket 트리 파싱: 텍스트 기반 티켓을 트리 구조로 변환합니다. 규칙 기반 추출과 LLM 파싱을 함께 사용하여 티켓 섹션을 식별하고 계층적으로 연결합니다. ○ Inter-ticket 연결: 개별 트리를 통합하여 포괄적인 그래프를 형성합니다. 티켓에 명시된 명시적 연결과 텍스트 의미 유사성을 기반으로 한 암시적 연결을 모두 활용합니다. ○ 임베딩 생성: BERT, E5와 같은 텍스트 임베딩 모델을 사용하여 그래프 노드 값에 대한 임베딩을 생성하고, 벡터 데이터베이스에 저장하여 검색을 용이하게 합니다. ● 검색 및 질문 응답 (Retrieval and Question Answering) ○ 쿼리 엔터티 식별 및 의도 감지: 사용자 쿼리에서 명명된 엔터티와 쿼리 의도를 추출합니다. LLM을 사용하여 쿼리를 파싱하고, 그래프 템플릿에 따라 키-값 쌍을 추출합니다.\n○ 하위 그래프의 임베딩 기반 검색: 사용자 쿼리에서 파생된 엔터티를 사용하여 관련 하위 그래프를 검색합니다. 코사인 유사도를 사용하여 티켓 수준 점수를 집계하고 상위 K개 티켓을 선택합니다. ○ 답변 생성: 검색된 데이터를 초기 쿼리와 연결하여 답변을 합성합니다. LLM은 검색된 정보를 기반으로 응답을 생성하는 디코더 역할을 합니다. 쿼리 실행에 문제가 발생하면 텍스트 기반 검색 방법으로 대체합니다.",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com"
          ],
          "24": [
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트"
          ],
          "25": [
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트"
          ],
          "26": [
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로"
          ],
          "27": [
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion"
          ],
          "28": [
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다."
          ],
          "29": [
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다."
          ],
          "30": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다."
          ],
          "31": [
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "• 향상된 검색 기법: 질의 처리 후 하이브리드 검색(밀도 기반 임베딩 검색 + 희소 키워드 검색)을 활용해 더 풍부한 결과를 얻습니다 ibm.com . 복잡한 질문의 경우 계층적 인덱싱이나 다단계 검색(예: iterative/recursive retrieval)으로 한층 심화된 검색을 수행하여 정확도를 높입니다 arxiv.org  arxiv.org . \n• 다중 모듈 검색: 질의 종류와 목적에 따라 여러 검색 모듈을 조합합니다. 예를 들어, 임베딩 기반 벡터 검색에 더해 지식 그래프 질의나 API 호출 등 이기종 데이터 검색을 병행할 수 있습니다. 또한 복잡한 문제에 대해 반복적 검색이나 분기 검색 흐름을 구현하여 필요한 정보를 순차적으로 수집할 수 있습니다 arxiv.org . 이러한 유연한 검색 설계로 질의의 의도에 맞게 다양한 소스에서 정보를 획득합니다. 모델 아키텍처 (Model Architecture) • 선형 파이프라인 구조: 인덱싱 → 검색 → 생성의 직렬 단계로 구성된 가장 단순한 형태입니다 arxiv.org . 별도의 최적화 모듈이나 피드백 루프 없이, 검색기와 한 번의 생성기로 답변을 생성합니다. 전체 구조가 단순하여 추가 구성요소가 없습니다. \n• 개선된 단일 흐름 구조: 기본 RAG 파이프라인에 전처리/후처리 모듈을 추가한 구조입니다. 예를 들어, 질의 재작성 모듈로 입력 질문을 명확히 하고 arxiv.org , 재검색 및 재정렬 모듈로 검색 결과를 필터링한 후 LLM에 전달합니다. 응답 생성 후에는 사용자 클릭이나 피드백 등을 활용한 피드백 루프를 도입해 검색기와 생성기를 지속적으로 개선하기도 합니다 \n• 모듈식 아키텍처: 여러 독립 모듈을 레고 블록처럼 연결하여 구성한 프레임워크입니다 arxiv.org . 질의 처리, 검색, 필터링, 생성, 검증 등의 기능이 분리된 모듈로 구현되고, 이들을 제어하는 라우팅/스케줄링 컴포넌트가 존재합니다 arxiv.org . 덕분에 비선형적 흐름도 가능하며 (예: 조건분기나",
            "• 최고의 유연성 & 확장성: 모듈 단위로 구성요소를 교체하거나 조정할 수 있어 요구사항 변경에 대응하기 쉽고 유지보수 용이합니다 ibm.com . 또한 각 컴포넌트를 독립적으로 최적화 또는 병렬화할 수 있어 대규모 지식베이스나 복잡한 작업에도 성능과 규모를 확장하기 유리합니다. 여러 데이터 소스를 통합하고 다양한 NLP 기능(요약, 번역, 대화 등)을 결합할 수 있어 복합적인 AI 시스템 구축에 적합합니다 arxiv.org ibm.com 단점 (Disadvantages) • 제한된 이해도와 신뢰성: 질의를 피상적으로 매칭하므로 질문의 의도나 맥락을 깊게 반영하지 못해 복잡한 질문에는 오답을 내기 쉽습니다 arxiv.org . 또한 검색된 문서를 여과 없이 모두 투입하기 때문에 불필요한 정보까지 포함되어 LLM이 혼란을 일으키거나 **환각 정보(hallucination)**를 생성할 위험이 있습니다 arxiv.org . 요약하면 간단한 구조로 인해 성능 한계가 뚜렷합니다. \n• 높은 복잡도와 비용: 추가 단계들로 인해 모델 처리 지연이 증가하고, 하이브리드 인덱싱 및 재랭킹 등에 따른 계산/메모리 비용이 큽니다 ibm.com . 구성요소(검색기, 랭커, 생성기 등)를 모두 관리하고 튜닝해야 하므로 시스템 구현과 유지보수가 복잡하며, 규모가 커질수록 이러한 복잡성이 배가됩니다. 결국 대규모 프로덕션 환경에 곧바로 적용하기 어렵고 충분한 자원과 전문성이 요구됩니다 ibm.com  ibm.com .",
            "개선사항 구조를 무시하여 발생하는 검색 정확도 저하를 개선 이슈 추적 문서(예: Jira)는 고유한 구조를 가지고 있으며, \"이슈 A는 이슈 B와 관련됨/복사됨/원인이 됨\"과 같은 참조로 상호 연결됩니다. 문서를 텍스트 덩어리로 압축하는 기존 방식은 중요한 정보의 손실을 초래할 수 있습니다. LinkedIn의 접근 방식은 이슈 티켓을 트리로 파싱하고 개별 이슈 티켓을 연결하여 상호 연결된 그래프를 형성함으로써 엔터티 간의 내재적 관계를 유지하여 높은 검색 성능을 달성합니다. \n세분화로 인한 답변 품질 저하를 개선 임베딩 모델의 컨텍스트 길이 제약을 수용하기 위해 광범위한 이슈 티켓을 고정 길이 세그먼트로 분할하면 관련 콘텐츠가 단절되어 불완전한 답변이 발생할 수 있습니다. 예를 들어, 이슈 티켓이 시작 부분에 이슈를 설명하고 끝 부분에 솔루션을 설명하는 경우 텍스트 세분화 프로세스 중에 분할되어 솔루션의 중요한 부분이 생략될 수 있습니다. LinkedIn의 그래프 기반 파싱 방법은 티켓 섹션의 논리적 일관성을 유지하여 완전하고 고품질의 응답을 제공함으로써 이 문제를 극복합니다.  \n결과 LinkedIn의 고객 서비스 팀 내에서 이 방법론을 사용한 결과, 이슈당 중간 해결 시간이 28.6% 감소했습니다. 이는 기존의 수동 방법에 비해 상당한 개선입니다. 구체적으로, Knowledge Graph를 사용하지 않은 그룹의 평균 이슈 해결 시간은 40시간인데 반해, Knowledge Graph를 사용한 그룹은 15시간으로 단축되었습니다. 이는 RAG와 지식 그래프의 통합이 고객 서비스 효율성을 향상시킬 수 있음을 보여줍니다"
          ],
          "32": [
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "핵심 모듈 조합 ● 질문 재작성(Query Rewrite): 모델 기반 접근 방식을 사용하여 사용자 질의를 변환해 보다 정밀한 추천 제공 ● 검색(Retrieve): 희소 인코딩(BM25)을 활용한 키워드 검색과 밀집 임베딩을 통한 의미적 검색을 결합한 하이브리드 검색 방식 적용\n● 생성(Generate): API 기반 또는 온프레미스 LLM을 활용하여 최적의 추천 결과를 생성하고 사용자 맞춤형 설명 제공 ● LLM 보상 강화 학습(LLM Reward Reinforcement Learning): 클릭 및 구매 데이터를 학습하여 질문 재작성 및 검색 프로세스를 지속적으로 최적화 \n설계 흐름 \n 1. 질문 재작성(Query Rewrite) ● 사용자의 검색 질의를 분석하고 최적화하여 추천 정확도를 향상 ● 예시: \"여름 샌들 추천\" → \"2024년 여름 인기 샌들 + 편안한 착용감 + 최신 할인 정보 포함\" 2. 검색(Retrieve) ● 하이브리드 검색 방식을 활용: ○ BM25 (희소 인코딩): 제품 설명, 고객 리뷰, 트렌드 데이터를 직접 키워드 매칭을 통해 검색 ○ 밀집 임베딩(Dense Embeddings): 제품과 사용자 선호도 간의 의미적 관계를 분석하여 맞춤형 추천 제공 ○ 하이브리드 점수 계산: 희소 및 밀집 검색 결과를 결합하여 정밀도와 재현율을 최적화 ● 예시: \"무선 청소기를 최근 검색한 사용자\" → \"무선 청소기 액세서리 + 베스트셀러 청소기 추천\" 3. 생성(Generate) ● API 기반 또는 온프레미스 LLM을 활용하여 개인 맞춤형 추천을 제공하며 설명까지 포함 ● 예시: \"이 제품은 최근 검색한 무선 청소기와 호환되며, 높은 사용자 평점을 받은 제품입니다.\" 4. LLM 보상 강화 학습(LLM Reward Reinforcement Learning) ● 사용자 상호작용(클릭 및 구매 데이터)을 학습하여 질문 재작성 및 검색 프로세스를 최적화 ● 보상 기반 강화 학습을 통해 실시간으로 추천 품질을 조정",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징"
          ],
          "33": [
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "Reference ※ 각 파트별 참조한 자료가 있다면 아래 출처 작성 부탁드립니다. ※ 작성 양식 : 문서/페이지명 (링크)  1번파트 - From complex to atomic: Enhancing Augmented Generation via Knowledge-aware Dual Rewriting and Reasoning (https://openreview.net/pdf/eece737929522d36939d3b6cf5da4e8c7921f2ee.pdf) - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/html/2312.10997v5  - Context window overflow: Breaking the barrier https://aws.amazon.com/jp/blogs/security/context-window-overflow-breaking-the-barrier/  - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/html/2407.21059v1  - How does Modular RAG improve upon naive RAG? https://adasci.org/how-does-modular-rag-improve-upon-naive-rag/  - Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담"
          ],
          "34": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자"
          ],
          "35": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다."
          ],
          "36": [
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다."
          ],
          "37": [
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징"
          ],
          "38": [
            "● 환자 병력 통합(Patient Medical History): 환자의 병력 및 유전적 요인을 반영하여 최적의 치료법 결정 ● 생성(Generation): 최종적으로 융합된 데이터를 바탕으로 최적의 답변 생성 \n설계 흐름 \n 1. 질문 확장(Query Expansion) ● 사용자의 입력을 분석하여 다중 관련 질의 생성 ● 예시: “3일 이상 38도 이상의 발열과 기침\" → \"발열을 유발하는 감염 질환\", \"발열과 기침이 동반되는 질환\" 2. 하이브리드 검색(Hybrid Retrieval) ● Dense Retrieval: 유사 증상을 기반으로 의료 문헌 검색 ● Knowledge Graph: 증상과 질병 간 관계 매핑 3. 생성(Generation, Optional) ● 검색된 정보가 부족할 경우, LLM을 활용하여 초안 생성 4. 융합(Fusion) ● 연구 논문과 임상 가이드를 통합하여 종합적인 답변 도출 ● 신뢰성을 높이기 위해 출처 명확히 명시 5. 환자 병력 통합(Patient Medical History) ● 환자의 병력 및 유전적 요인을 반영하여 맞춤형 치료를 적용 ● 예시: \"당뇨 가족력이 있는 환자를 위한 최적의 독감 치료 옵션\" 6. 생성(Generation) ● 최종 융합된 정보를 바탕으로 사용자 친화적인 의료 조언 제공  \n개선점 ● 단순한 학술 논문 검색을 넘어 임상 데이터와 의료 가이드를 통합하여 더 정밀한 추천 제공 ● 환자 병력 기반 맞춤형 검색을 구현하여 진단의 정확도 향상",
            "4.3 의료 도메인 - AI 기반 진단 및 치료 추천 목표 전통적인 의료 검색 시스템은 주로 학술 논문을 기반으로 하지만, 환자의 증상 및 임상 데이터를 통합하면 더 정밀한 의료 정보를 제공할 수 있습니다. 모듈형 RAG 프레임워크를 활용하여 다수의 의료 데이터 소스를 결합함으로써 신뢰도 높은 검색 결과를 도출하고, 환자의 병력 및 유전적 요인을 반영하여 맞춤형 의료 추천을 제공합니다. \n핵심 모듈 조합 ● 질문 확장(Query Expansion): 사용자의 질의를 세분화하여 관련된 다중 질의 생성 ● 하이브리드 검색(Dense + Knowledge Graph): 증상 기반으로 의료 논문과 임상 가이드를 검색 ● 생성(Generation, Optional): 필요 시 검색된 정보를 기반으로 초기 답변 생성 ● 융합(Fusion): 연구 논문과 임상 가이드를 결합하여 최적의 답변 도출\n● 환자 병력 통합(Patient Medical History): 환자의 병력 및 유전적 요인을 반영하여 최적의 치료법 결정 ● 생성(Generation): 최종적으로 융합된 데이터를 바탕으로 최적의 답변 생성 \n설계 흐름",
            "4.1 도메인별 최적화 전략 각 도메인에 따라 검색 및 생성 패턴을 차별화하여 적용하면, 보다 신뢰도 높은 질의응답 시스템을 구축할 수 있습니다. ● 의료: 신뢰성과 정확성이 중요하므로 하이브리드 검색(Dense + Knowledge Graph) 과 환자 병력 반영을 적용해 맞춤형 치료를 추천합니다. ● 법률: 법적 근거와 판례 분석이 핵심이므로 판단 모듈(Judge) 과 LLM 비판적 평가(Critique) 를 활용해 신뢰성을 높입니다. ● 금융: 실시간 시장 변동 반영이 필수이므로 Text-to-SQL 과 감성 분석(Sentiment Analysis) 을 사용해 투자 인사이트를 강화합니다. ● 전자상거래: 개인화된 추천이 필요하므로 RRR(Rewrite-Retrieve-Read) 패턴 과 강화 학습(LLM Reward RL) 을 활용해 사용자 맞춤 추천을 제공합니다.\n4.2 핵심 개념 정리 \n ● Dense vs. Sparse Retrieval: ○ Dense Retrieval: 의미적 유사도를 기반으로 벡터 검색을 수행하여 가장 관련성이 높은 정보를 검색 ○ Sparse Retrieval (BM25 등): 키워드 기반 검색 방식으로 문서 내 키워드의 빈도 및 위치를 고려해 검색 정확도 향상 ● Query Expansion / Transformation: 사용자의 질의를 보다 풍부하고 정확하게 변형하여 검색 결과 품질 개선 ● Knowledge Graph: 개념 간의 관계를 그래프 구조로 저장하여, 검색 질의와 관련 정보 간 연관성을 강화",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "개선점 ● 단순한 학술 논문 검색을 넘어 임상 데이터와 의료 가이드를 통합하여 더 정밀한 추천 제공 ● 환자 병력 기반 맞춤형 검색을 구현하여 진단의 정확도 향상\n● 최신 의료 연구 데이터를 실시간 반영하여 최신 치료 방법을 신속하게 제공  4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 목표 전통적인 법률 검색 시스템은 주로 법률 조항을 검색하는 데 초점을 맞추고 있습니다. 하지만 판례, 전문가 의견, 계약 데이터를 통합하여 보다 정밀한 법률 해석을 제공할 수 있다면 어떨까요? 모듈형 RAG 프레임워크를 적용함으로써 법률 문서를 종합적으로 분석하고, 특정 사건과 관할권에 맞는 법률 해석을 추천할 수 있습니다. \n핵심 모듈 조합 ● 판단 모듈(Judge): 사용자의 법률 질의를 분석하여 적절한 검색 방식 결정 ● 검색(Retrieve): 법률 문서, 판례, 계약서 데이터베이스에서 관련 정보 검색 ● 생성(Generate): 검색된 정보를 기반으로 초기 법률 해석 제공 ● 질문 변환(Query Transformation, Optional): 필요 시 사용자의 질문을 법률적 용어로 변환하여 추가 검색 수행 ● LLM 비판적 평가(LLM Critique): 검색된 법률 자료의 신뢰성을 평가하고 불필요한 정보를 필터링 ● 적응형 검색 및 생성(Adaptive Retrieval & Generation): 부족한 법률 자료가 발견되면 추가 검색 수행 ● 반복 RAG 흐름 제어(Loop RAG Flow Orchestration): 법률 질문 유형에 따라 검색 및 생성 프로세스 동적 조정 \n설계 흐름 \n 1. 판단(Judge)"
          ],
          "39": [
            "개선점 ● 단순한 학술 논문 검색을 넘어 임상 데이터와 의료 가이드를 통합하여 더 정밀한 추천 제공 ● 환자 병력 기반 맞춤형 검색을 구현하여 진단의 정확도 향상\n● 최신 의료 연구 데이터를 실시간 반영하여 최신 치료 방법을 신속하게 제공  4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 목표 전통적인 법률 검색 시스템은 주로 법률 조항을 검색하는 데 초점을 맞추고 있습니다. 하지만 판례, 전문가 의견, 계약 데이터를 통합하여 보다 정밀한 법률 해석을 제공할 수 있다면 어떨까요? 모듈형 RAG 프레임워크를 적용함으로써 법률 문서를 종합적으로 분석하고, 특정 사건과 관할권에 맞는 법률 해석을 추천할 수 있습니다. \n핵심 모듈 조합 ● 판단 모듈(Judge): 사용자의 법률 질의를 분석하여 적절한 검색 방식 결정 ● 검색(Retrieve): 법률 문서, 판례, 계약서 데이터베이스에서 관련 정보 검색 ● 생성(Generate): 검색된 정보를 기반으로 초기 법률 해석 제공 ● 질문 변환(Query Transformation, Optional): 필요 시 사용자의 질문을 법률적 용어로 변환하여 추가 검색 수행 ● LLM 비판적 평가(LLM Critique): 검색된 법률 자료의 신뢰성을 평가하고 불필요한 정보를 필터링 ● 적응형 검색 및 생성(Adaptive Retrieval & Generation): 부족한 법률 자료가 발견되면 추가 검색 수행 ● 반복 RAG 흐름 제어(Loop RAG Flow Orchestration): 법률 질문 유형에 따라 검색 및 생성 프로세스 동적 조정 \n설계 흐름 \n 1. 판단(Judge)",
            "설계 흐름 \n 1. 판단(Judge)\n● 사용자의 질문을 평가하여 검색이 필요한지 직접 생성이 필요한지 결정 ● 예시: \"근무 시간 변경 요청을 거부할 수 있는가?\" → \"근로 계약서에 명시되지 않은 근무 시간 변경 거부 가능 여부\" 2. 검색(Retrieve) ● 판례 검색(Case Law): 관련 과거 판결 사례 검색 ● 법률 조항 검색(Legislation): 관련 법 조항 검색 ● 계약서 데이터베이스 검색(Contracts DB): 표준 계약 조항 확인 3. 생성(Generate) ● 검색된 정보를 바탕으로 법률 해석을 제공 4. LLM 비판적 평가(LLM Critique) ● 검색된 법률 자료의 신뢰성과 관련성을 평가하여 불필요한 정보를 필터링 5. 적응형 검색 및 생성(Adaptive Retrieval & Generation) ● 추가적인 법률 참고 자료가 필요하면 자동으로 추가 검색 수행 ● 전문가 의견을 반영하여 법률 해석 강화 6. 반복 RAG 흐름 제어(Loop RAG Flow Orchestration) ● 계약 관련 질의 → 계약 조항 + 판례 검색 ● 형사법 관련 질의 → 법률 조항 + 형사 판례 검색 ● 행정법 관련 질의 → 정부 가이드라인 검색  \n개선점 ● 단순한 법률 조항 검색을 넘어 판례, 계약, 전문가 의견을 통합하여 실용적인 법률 상담 시스템 구축 ● 최신 법률 개정 사항을 자동 반영하여 신뢰도를 높이고, 지역별 법률 차이를 반영 ● 사용자 의도를 분석하여 보다 정밀한 법률 추천 제공  \n4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 목표 투자 정보를 검색할 때 단순한 데이터 검색만으로는 충분하지 않습니다. 금융 재무제표, 경제 뉴스, 애널리스트 보고서를 통합하여 보다 포괄적인 분석을 제공할 수 있다면 어떨까요? 모듈형 RAG을 활용하여 다양한 데이터 소스를 결합함으로써 보다 정밀한 투자 인사이트를 제공하고 실시간 시장 변동에 적응하는 검색 시스템을 구축할 수 있습니다.",
            "3.2 모듈  모듈 정의 모듈은 Modular RAG 시스템의 핵심 구성 블록으로 시스템의 주요 기능이나 임무(예: 정보 검색, 요약, 텍스트 생성 등)를 독립적으로 수행하는 단위입니다. 각 모듈은 특정 작업을 독립적으로 수행하도록 설계되며, 다른 모듈과 별개로 동작할 수 있습니다.  \n모듈의 역할 모듈은 사용자의 요청에 따른 특정 기능을 직접 수행합니다. 모듈은 특정 기능이나 작업을 독립적으로 수행하는 구성 요소입니다. 각 모듈은 전문화된 기능을 담당하며, 에이전트의 지시에 따라 협력하여 최종 목표를 달성합니다.  예를 들어, 검색 모듈은 외부 데이터 소스에서 관련 정보를 검색하고, 생성 모듈은 최종 응답을 생성하는 역할, 데이터 전처리, 텍스트 생성 등의 개별 기능을 담당할 수 있습니다.   \n모듈의 특징 ● 독립성 및 모듈화: 모듈은 독립적인 단위로 설계되어 다른 모듈과 별개로 작동할 수 있으며, 모듈화된 구조를 유지합니다. ● 전문화: 각 모듈은 특정 작업이나 기능에 집중하여 해당 분야에서 최적화되고 전문성을 갖출 수 있습니다. ● 재사용성 및 유연성: 모듈은 시스템 내에서 재사용할 수 있으며, 필요에 따라 쉽게 수정, 교체, 확장할 수 있습니다. 또한, 다른 프로젝트에서도 활용할 수 있습니다. ● 확장성: 새로운 기능이나 서비스가 필요할 경우, 기존 모듈을 확장하거나 새로운 모듈을 추가하여 시스템을 발전시킬 수 있습니다. ● 조합성: 여러 모듈을 결합하여 복잡한 작업을 처리하거나 새로운 기능을 추가할 수 있습니다.\n모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다."
          ],
          "40": [
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "● Fusion & Re-rank: 다중 검색 결과를 조합하고 가중치를 조정하여 최적의 답변을 생성 ● Text-to-SQL: 자연어 질의를 SQL 쿼리로 변환하여 구조화된 데이터에서 정밀 검색 수행 ● RRR (Rewrite-Retrieve-Read): 검색 질의를 효과적으로 변형(Rewrite) → 검색(Retrieve) 수행 → 검색된 정보를 해석(Read)하여 최적의 답변 생성 ● LLM Reward RL (LLM 보상 강화 학습): AI 모델이 사용자 상호작용 데이터를 학습하여 검색 및 추천 시스템을 지속적으로 개선 ● Adaptive Retrieval & Generation (적응형 검색 및 생성): 초기 검색 결과가 부족할 경우 추가 검색을 수행하고, 생성 모델이 정보를 보강하여 최적의 답변 제공 ● LLM Critique (LLM 비판적 평가): 생성된 응답의 신뢰도를 평가하고 오류를 수정하여 정확성을 보장 ● Hybrid Search (하이브리드 검색): Sparse 검색(BM25)과 Dense 검색(임베딩 검색)을 결합하여 검색 성능 최적화 RAG 기반 검색 시스템을 도메인별 특성에 맞춰 최적화하면, 의료, 법률, 금융, 전자상거래 등 다양한 분야에서 정확성, 신뢰성, 개인화, 실시간성을 극대화할 수 있습니다. 이 과정에서 Agent가 적절한 Module과 Operator를 조합하여 실행하는 방식이 중요한 역할을 하며, 이를 통해 복잡한 질의응답 프로세스를 효과적으로 처리할 수 있습니다. 이제부터는 각 도메인별로 최적화된 검색 및 생성 패턴이 어떻게 적용되는지 구체적인 사례를 살펴보겠습니다.",
            "5. 순위 조정(Re-rank) ● 검색된 데이터를 신뢰도 및 관련성에 따라 재정렬 6. 감성 분석(Sentiment Analysis) ● 뉴스 및 소셜 미디어의 감성 분석을 통해 투자 심리 평가 ● 예시: \"테슬라 주가가 최근 하락했지만 소셜 미디어에서 긍정적인 분위기가 나타나 단기 회복 가능성이 있음\" 7. 가중 융합(Weighted Fusion) ● 각 데이터 출처의 신뢰도를 기반으로 가중치를 부여하여 최적의 투자 보고서 생성 ● 예시: SEC 공식 공시 > 애널리스트 보고서 > 뉴스 > 소셜 미디어 (신뢰도 높은 순서) 8. 생성(Generation) ● AI 기반 투자 조언 및 시장 분석 제공 ● 예시: \"테슬라의 최근 분기 실적이 예상보다 높았지만 원자재 가격 상승이 향후 이익률에 압박을 가할 수 있음\" \n개선점 ● 자연어 질의를 SQL로 변환(Text-to-SQL)하여 사용자가 특정 금융 지표를 직접 검색할 수 있도록 지원 ● 애널리스트 보고서, 경제 뉴스, 소셜 미디어 감성 분석을 통합하여 투자 판단의 신뢰도 향상 ● 실시간 시장 반응을 분석하여 최신 경제 데이터를 자동 반영하는 적응형 검색 기능 구현  \n4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 목표 기존 전자상거래 추천 시스템은 주로 협업 필터링에 의존하지만, 개별 사용자의 취향과 실시간 검색 의도를 정확하게 반영하는 데 어려움이 있습니다. 이를 해결하기 위해 RRR(Rewrite-Retrieve-Read) 패턴 기반의 RAG 추천 시스템을 적용할 수 있습니다. 이 시스템은 사용자 질의를 최적화하고, 다양한 소스에서 관련 데이터를 검색하며, 실시간으로 개인화된 추천을 제공합니다. 또한, 강화 학습을 활용하여 추천 품질을 지속적으로 개선할 수 있습니다."
          ],
          "41": [
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ],
          "42": [
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ],
          "43": [
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다."
          ],
          "44": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여 적절한 모듈을 호출하고 실행 순서를 조정하며, 필요할 경우 실행 도중 워크플로우를 변경할 수도 있습니다. AI 에이전트는 자율적으로 환경과 상호작용하며 특정 목표를 달성하기 위해 설계된 독립적인 시스템입니다. 에이전트는 데이터를 감지하고, 분석하며, 의사결정을 내리고, 행동을 수행하는 능력을 갖추고 있습니다. Tools는 Agent가 직접 호출할 수도 있고, 특정 모듈 내부에서 독립적인 기능을 수행할 수도 있습니다. 예를 들어, API 호출 기능을 수행하는 Tools는 모듈에서 직접 호출될 수 있으며, 경우에 따라 Agent가 직접 Tools를 실행하여 특정 기능을 수행할 수도 있습니다.",
            "Modular RAG에서 AI Agent 특징: ● 동적 워크플로우 관리: 상황에 따라 필요한 모듈들을 선택하고 연결하여 유연한 작업 흐름을 구성합니다. ● 라우팅(Routing) : 복잡한 문제 해결이나 전략 수립이 필요할 때, 어떤 작업을 먼저 수행할지 판단하고 전체 프로세스를 관리합니다. ● 모듈 간 인터페이스 관리: 각 모듈과 하위 모듈 간의 데이터 교환, 호출 순서, 의존성 등을 조율하여 시스템의 일관성을 유지합니다. 각 에이전트는 특정 역할(예: 검색, 생성, 데이터 처리 등)을 담당하며, 독립적으로 실행됩니다. 다중 에이전트 시스템(Multi-Agent System)에서 각 에이전트는 서로 다른 모듈과 연결되어 작업을 분담합니다. 에이전트 간 메시지 전달 및 협업을 통해 복잡한 작업을 수행합니다. ● 유연성과 확장성: 새로운 기능을 추가하려면 해당 기능을 수행하는 새로운 에이전트를 추가하면 됩니다. ● 병렬 처리: 여러 에이전트가 동시에 작업하여 효율성을 향상됩니다.   AI Agent 상호작용 Agent는 LLM과 Tools, Prompt를 활용하여 전체 워크플로우를 조율하고 작업을 수행합니다. Tools는 특정 기능(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 경우에 따라 이를 하나의 모듈로 간주할 수 있습니다. 또한, Tools 내부에서 세부적인 작업(예: API 호출 또는 데이터 필터링)을 하위 모듈로 정의할 수 있습니다. 일부 시스템에서는 LLM이 독립적인 모듈로 동작할 수도 있으며, 특정 Tools는 Agent 없이도 직접 실행될 수 있습니다. 예시 ● 검색 에이전트: 외부 데이터베이스에서 정보를 검색(tavily search, web-scrapper). ● 문서작성 에이전트: 검색된 데이터를 바탕으로 문서 작성합니다. ● 그래프 작성 에이전트: 검색된 데이터를 바탕으로 필요에 따라서 그래프 작성(python repl)합니다. ● 감독 에이전트: 여러 에이전트를 조율하여 최적의 결과를 도출합니다."
          ],
          "45": [
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여 적절한 모듈을 호출하고 실행 순서를 조정하며, 필요할 경우 실행 도중 워크플로우를 변경할 수도 있습니다. AI 에이전트는 자율적으로 환경과 상호작용하며 특정 목표를 달성하기 위해 설계된 독립적인 시스템입니다. 에이전트는 데이터를 감지하고, 분석하며, 의사결정을 내리고, 행동을 수행하는 능력을 갖추고 있습니다. Tools는 Agent가 직접 호출할 수도 있고, 특정 모듈 내부에서 독립적인 기능을 수행할 수도 있습니다. 예를 들어, API 호출 기능을 수행하는 Tools는 모듈에서 직접 호출될 수 있으며, 경우에 따라 Agent가 직접 Tools를 실행하여 특정 기능을 수행할 수도 있습니다."
          ],
          "46": [
            "2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다. \n주요 전략 사전 검색 처리 (Pre-retrieval processing): ● 쿼리 재작성(query rewriting): 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. ● 쿼리 확장(query expansion): 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다. ● 쿼리 변환(query transformation): 원래 쿼리 대신 변환된 쿼리를 기반으로 검색 및 생성을 수행합니다.\n사후 검색 처리 (Post-retrieval processing): ● 검색 결과 재정렬(reranking): 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다. ● 압축(compression): 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다. ● 선택(selection): 관련 없는 덩어리를 직접 제거하여 LLM의 추론 효율성을 향상시킵니다.  \n특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다."
          ],
          "47": [
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "● Fusion & Re-rank: 다중 검색 결과를 조합하고 가중치를 조정하여 최적의 답변을 생성 ● Text-to-SQL: 자연어 질의를 SQL 쿼리로 변환하여 구조화된 데이터에서 정밀 검색 수행 ● RRR (Rewrite-Retrieve-Read): 검색 질의를 효과적으로 변형(Rewrite) → 검색(Retrieve) 수행 → 검색된 정보를 해석(Read)하여 최적의 답변 생성 ● LLM Reward RL (LLM 보상 강화 학습): AI 모델이 사용자 상호작용 데이터를 학습하여 검색 및 추천 시스템을 지속적으로 개선 ● Adaptive Retrieval & Generation (적응형 검색 및 생성): 초기 검색 결과가 부족할 경우 추가 검색을 수행하고, 생성 모델이 정보를 보강하여 최적의 답변 제공 ● LLM Critique (LLM 비판적 평가): 생성된 응답의 신뢰도를 평가하고 오류를 수정하여 정확성을 보장 ● Hybrid Search (하이브리드 검색): Sparse 검색(BM25)과 Dense 검색(임베딩 검색)을 결합하여 검색 성능 최적화 RAG 기반 검색 시스템을 도메인별 특성에 맞춰 최적화하면, 의료, 법률, 금융, 전자상거래 등 다양한 분야에서 정확성, 신뢰성, 개인화, 실시간성을 극대화할 수 있습니다. 이 과정에서 Agent가 적절한 Module과 Operator를 조합하여 실행하는 방식이 중요한 역할을 하며, 이를 통해 복잡한 질의응답 프로세스를 효과적으로 처리할 수 있습니다. 이제부터는 각 도메인별로 최적화된 검색 및 생성 패턴이 어떻게 적용되는지 구체적인 사례를 살펴보겠습니다.",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담"
          ],
          "48": [
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다."
          ],
          "49": [
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "개선사항 구조를 무시하여 발생하는 검색 정확도 저하를 개선 이슈 추적 문서(예: Jira)는 고유한 구조를 가지고 있으며, \"이슈 A는 이슈 B와 관련됨/복사됨/원인이 됨\"과 같은 참조로 상호 연결됩니다. 문서를 텍스트 덩어리로 압축하는 기존 방식은 중요한 정보의 손실을 초래할 수 있습니다. LinkedIn의 접근 방식은 이슈 티켓을 트리로 파싱하고 개별 이슈 티켓을 연결하여 상호 연결된 그래프를 형성함으로써 엔터티 간의 내재적 관계를 유지하여 높은 검색 성능을 달성합니다. \n세분화로 인한 답변 품질 저하를 개선 임베딩 모델의 컨텍스트 길이 제약을 수용하기 위해 광범위한 이슈 티켓을 고정 길이 세그먼트로 분할하면 관련 콘텐츠가 단절되어 불완전한 답변이 발생할 수 있습니다. 예를 들어, 이슈 티켓이 시작 부분에 이슈를 설명하고 끝 부분에 솔루션을 설명하는 경우 텍스트 세분화 프로세스 중에 분할되어 솔루션의 중요한 부분이 생략될 수 있습니다. LinkedIn의 그래프 기반 파싱 방법은 티켓 섹션의 논리적 일관성을 유지하여 완전하고 고품질의 응답을 제공함으로써 이 문제를 극복합니다.  \n결과 LinkedIn의 고객 서비스 팀 내에서 이 방법론을 사용한 결과, 이슈당 중간 해결 시간이 28.6% 감소했습니다. 이는 기존의 수동 방법에 비해 상당한 개선입니다. 구체적으로, Knowledge Graph를 사용하지 않은 그룹의 평균 이슈 해결 시간은 40시간인데 반해, Knowledge Graph를 사용한 그룹은 15시간으로 단축되었습니다. 이는 RAG와 지식 그래프의 통합이 고객 서비스 효율성을 향상시킬 수 있음을 보여줍니다",
            "설계 방법 LinkedIn은 시스템은 과거 고객 서비스 문제 티켓에서 Knowledge Graph를 구축하고, 질문 응답 단계에서 소비자 쿼리를 파싱하여 관련 하위 그래프를 식별하고 답변을 생성합니다. 주요 사용 방법은 다음과 같습니다.\n● 지식 그래프 구축 (Knowledge Graph Construction) ○ Intra-ticket 트리 파싱: 텍스트 기반 티켓을 트리 구조로 변환합니다. 규칙 기반 추출과 LLM 파싱을 함께 사용하여 티켓 섹션을 식별하고 계층적으로 연결합니다. ○ Inter-ticket 연결: 개별 트리를 통합하여 포괄적인 그래프를 형성합니다. 티켓에 명시된 명시적 연결과 텍스트 의미 유사성을 기반으로 한 암시적 연결을 모두 활용합니다. ○ 임베딩 생성: BERT, E5와 같은 텍스트 임베딩 모델을 사용하여 그래프 노드 값에 대한 임베딩을 생성하고, 벡터 데이터베이스에 저장하여 검색을 용이하게 합니다. ● 검색 및 질문 응답 (Retrieval and Question Answering) ○ 쿼리 엔터티 식별 및 의도 감지: 사용자 쿼리에서 명명된 엔터티와 쿼리 의도를 추출합니다. LLM을 사용하여 쿼리를 파싱하고, 그래프 템플릿에 따라 키-값 쌍을 추출합니다.\n○ 하위 그래프의 임베딩 기반 검색: 사용자 쿼리에서 파생된 엔터티를 사용하여 관련 하위 그래프를 검색합니다. 코사인 유사도를 사용하여 티켓 수준 점수를 집계하고 상위 K개 티켓을 선택합니다. ○ 답변 생성: 검색된 데이터를 초기 쿼리와 연결하여 답변을 합성합니다. LLM은 검색된 정보를 기반으로 응답을 생성하는 디코더 역할을 합니다. 쿼리 실행에 문제가 발생하면 텍스트 기반 검색 방법으로 대체합니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ]
        },
        "response": {
          "0": "RAG의 약자는 **Retrieval-Augmented Generation** 입니다.",
          "1": "RAG의 세 가지 핵심 요소는 다음과 같습니다.\n\n1.  **Retrieve (검색):** 문서들을 검색하여 관련 정보를 추출하는 단계입니다.\n2.  **Generate (생성):** 검색된 정보를 바탕으로 자연어 응답을 생성하는 단계입니다.\n3.  **Reducer (정리):** 검색된 문서를 정리하고, 최종 후보를 선정하는 단계입니다.\n\n이 세 가지 요소는 서로 연관되어 작동하며, RAG 시스템의 핵심적인 역할을 수행합니다.",
          "2": "Naive RAG의 핵심 구성 요소는 다음과 같습니다.\n\n1.  **Indexing (검색):**\n    *   **색인 (Indexing):** 텍스트 데이터를 작은 덩어리(chunk)로 분할하여 벡터 형태로 변환합니다.\n    *   **검색 (Retrieval):** 벡터 데이터베이스에서 쿼리와 가장 유사한 문서를 찾습니다.\n\n2.  **생성 (Generation):**\n    *   **LLM (Large Language Model):** 쿼리에 대한 답변을 생성합니다.\n\n3.  **모듈화된 구성 요소 (Modular Components):**\n    *   **검색 모듈 (Retrieval Module):** 쿼리 프로세서에서 쿼리를 처리하고, 검색을 수행합니다.\n    *   **구성 모듈 (Organizer Module):** 검색된 문서를 정리하고, 쿼리와 관련 정보를 제공합니다.\n    *   **생성 모듈 (Generator Module):** LLM을 사용하여 답변을 생성합니다.\n\n4.  **GraphRAG (추가 구성 요소):**\n    *   **쿼리 프로세서:** 쿼리를 처리하고, 쿼리를 그래프 데이터 소스에 연결합니다.\n    *   **검색기 (Retriever):** 쿼리를 검색하고, 관련 문서를 찾습니다.\n    *   **구성기 (Organizer):** 검색된 문서를 정리하고, 쿼리와 관련 정보를 제공합니다.\n    *   **생성기 (Generator):** LLM을 사용하여 답변을 생성합니다.\n\n이러한 구성 요소들이 서로 연동되어 작동하며, 각 구성 요소는 특정 역할을 수행합니다.",
          "3": "Naive RAG의 작동 방식은 다음과 같이 요약할 수 있습니다.\n\n**1. 쿼리 입력 및 임베딩 생성:**\n\n*   사용자가 쿼리를 입력하면, 쿼리를 임베딩 모델(예: Sentence Transformers)을 사용하여 벡터로 변환합니다.\n*   이 벡터는 쿼리의 의미를 표현하는 숫자 표현입니다.\n\n**2. 문서 덩어리 분할:**\n\n*   쿼리와 관련된 문서들을 작은 덩어리(chunk)로 나눕니다. 이 덩어리는 텍스트, 문장, 또는 특정 단어 단위로 구성될 수 있습니다.\n\n**3. 덩어리 벡터화:**\n\n*   각 덩어리를 임베딩 모델을 사용하여 벡터로 변환합니다. (벡터화는 텍스트를 숫자 형태로 변환하는 과정입니다.)\n\n**4. 유사도 검색:**\n\n*   각 덩어리 벡터를 다른 덩어리 벡터와 비교하여 유사도를 계산합니다. 유사도는 두 벡터 간의 거리(예: 코사인 유사도)를 측정합니다.\n*   가장 유사한 덩어리(즉, 쿼리와 가장 관련 있는 문서 덩어리)를 찾습니다.\n\n**5. 검색 결과 생성:**\n\n*   가장 유사한 덩어리에서 가장 관련 있는 문서를 가져와서 사용자 쿼리에 대한 답변을 생성합니다.\n*   LLM(Large Language Model)을 사용하여 쿼리에 대한 답변을 생성합니다.\n\n**6. 답변 생성 및 사용자에게 제공:**\n\n*   생성된 답변을 사용자에게 제공합니다.\n\n**핵심:** Naive RAG는 쿼리와 관련된 문서를 벡터로 변환하여 유사도 검색을 수행하고, 가장 유사한 문서를 기반으로 답변을 생성합니다.\n\n**요약:** 쿼리를 임베딩으로 변환하여 유사도 검색을 수행하고, 가장 유사한 문서를 기반으로 답변을 생성하는 방식입니다.\n\n**참고:** Naive RAG는 비교적 간단하고 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제가 발생할 수 있습니다.\n\n더 자세한 내용은 다음 자료를 참고하시면 좋습니다.\n\n*   [Naive RAG의 작동 방식](https://www.youtube.com/watch?v=g7XyJ-3z7g0)\n*   [Advanced RAG의 작동 방식](https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/)\n*   [Modular RAG의 작동 방식](https://arxiv.org/pdf/2407.21059)\n\n이 외에도 다양한 RAG 방법론들이 존재하며, 각 방법론은 장단점을 가지고 있습니다.",
          "4": "Naive RAG의 'Shallow Query Understanding'을 한국어로 표현하면 **단순한 질의 이해** 입니다.\n\n좀 더 자세히 설명하자면, Naive RAG는 키워드나 벡터 기반의 유사성 매칭을 주로 사용하기 때문에, 질문의 의도를 정확하게 파악하지 못하고, 질문의 핵심을 제대로 이해하지 못하는 경우가 많습니다.",
          "5": "Advanced RAG에서 도입된 사전 검색 처리 기법은 다음과 두 가지입니다.\n\n1.  **쿼리 재작성 (Query Rewriting):** 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. \n2.  **쿼리 확장 (Query Expansion):** 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다.\n\n이 두 가지 기법은 쿼리를 개선하고 검색 효율성을 높이는 데 중요한 역할을 합니다.",
          "6": "Advanced RAG의 사후 검색 처리 기법 예시 두 가지는 다음과 같습니다.\n\n1.  **검색 결과 재정렬 (Reranking):**\n\n    *   **설명:** Advanced RAG는 검색된 덩어리의 내용을 평가하고, 더 중요한 문서 덩어리를 가시적으로 높이는 데 중점을 둡니다.  Reranking은 검색된 덩어리의 내용을 평가하여, 더 중요한 문서 덩어리의 가시성을 높이는 데 사용됩니다.  이를 통해 LLM이 핵심 정보를 더 잘 인식하도록 돕고, 검색 결과의 품질을 향상시킵니다.\n    *   **예시:**  Advanced RAG는 검색된 문서를 평가하는 데 사용되는 랭킹 모델을 통해 각 문서의 중요도를 측정합니다.  그런 다음, 이 랭킹을 기반으로 문서의 중요도를 다시 평가하고, 더 중요한 문서 덩어리를 가시적으로 높입니다.\n\n2.  **압축 (Compression):**\n\n    *   **설명:** Advanced RAG는 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다.  압축은 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕는 과정입니다.\n    *   **예시:** Advanced RAG는 검색된 텍스트에서 불필요한 문장이나 단어를 제거하거나, 중요한 문장이나 정보를 강조하는 방식으로 압축합니다.  이를 통해 LLM이 핵심 정보를 더 잘 인식하도록 돕고, 검색 결과의 정확도를 높입니다.\n\n이러한 사후 검색 처리 기법들은 Advanced RAG의 핵심 개선 사항 중 하나로, 검색 효율성을 높이고, LLM의 활용도를 향상시키는 데 기여합니다.",
          "7": "Modular RAG의 핵심 개념은 다음과 같습니다.\n\n**1. 모듈화된 구조:**\n\n*   **독립적인 모듈:** Modular RAG는 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리합니다.\n*   **자율적인 기능:** 각 모듈은 특정 작업을 수행하며, 서로 협력하여 전체 시스템을 구성합니다.\n\n**2. 에이전트 기반 워크플로우:**\n\n*   **에이전트(Agent) 모듈:** 에이전트는 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출합니다.\n*   **자율적인 실행:** 에이전트는 주어진 작업에 따라 어떤 도구를 호출할지 자율적으로 결정합니다.\n\n**3. 추론 및 라우팅:**\n\n*   **추론 및 라우팅 프레임워크:** ReAct 프로세스와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다.\n*   **유연한 워크플로우:** 조건부 실행, 반복적 개선, 병렬 처리 등을 통해 복잡한 문제를 관리하고, 사용자 요구에 따라 동적으로 적응합니다.\n\n**4. 데이터 소스 통합:**\n\n*   **다중 데이터 소스:** 다양한 데이터 소스를 활용하여 지식을 보강하고, 실시간 API를 통해 동적으로 정보를 얻습니다.\n\n**5. 모듈화된 검색 및 생성:**\n\n*   **검색 모듈:** 검색을 위한 핵심 기능 (검색, 랭킹, 필터링, 생성 등)을 담당합니다.\n*   **생성 모듈:** 생성된 콘텐츠를 생성하는 기능입니다.\n\n**요약하자면, Modular RAG는 독립적인 모듈과 에이전트 기반 워크플로우를 통해 유연하고 확장 가능한 AI 시스템을 구축하는 데 초점을 맞추고 있습니다.**\n\n이러한 핵심 개념들을 통해 Modular RAG는 기존 LLM의 한계를 극복하고, 더 효율적이고 유연한 쿼리 처리 및 응답 생성 시스템을 제공합니다.",
          "8": "## Modular RAG 3단계 구조 (예시)\n\nModular RAG는 데이터 검색, 자연어 응답 생성, 그리고 문서 평가를 위한 독립적인 모듈과 연산자를 활용하여 시스템을 구성하는 구조입니다. 각 단계는 서로 연관되어 있으며, 전체적인 시스템 성능을 향상시키는 역할을 합니다.\n\n**1. Retrieve (검색 모듈)**\n\n*   **역할:** 사용자의 질의에 적절한 문서를 검색합니다.\n*   **구성 요소:**\n    *   **Operator:** 검색된 문서를 기반으로 검색된 문서의 순위를 재조정합니다. (예: BM25, 벡터 검색)\n    *   **Hybrid Search:** BM25와 벡터 검색을 결합하여 검색 정확도를 높입니다.\n    *   **Vector Search:** 임베딩을 활용하여 유사도 기반으로 검색합니다.\n*   **목표:** 검색된 문서의 관련성을 높여 정확한 답변을 제공합니다.\n\n**2. Generate (생성 모듈)**\n\n*   **역할:** 검색된 문서를 기반으로 자연어 응답을 생성합니다.\n*   **구성 요소:**\n    *   **LLM-based Answering:** 대형 언어 모델을 활용하여 답변을 생성합니다.\n    *   **Template-based Generation:** 미리 정의된 템플릿을 사용하여 응답을 생성합니다.\n*   **목표:** 사용자의 질문에 대한 적절하고 정확한 답변을 제공합니다.\n\n**3. Sub-Module (하위 모듈)**\n\n*   **역할:** 특정 기능 구현을 담당하는 독립적인 모듈입니다.\n*   **구성 요소:**\n    *   **Reranker:** 검색된 문서를 순위를 재조정합니다. (예: 랭킹 알고리즘)\n    *   **Hybrid Search:** BM25와 벡터 검색을 조합하여 최적화합니다.\n    *   **Vector Search:** 임베딩을 활용하여 유사도 기반으로 검색합니다.\n    *   **Reducer:** 검색된 여러 개의 문서를 정리하여 최종 후보를 선정합니다.\n    *   **Routing:** 특정 조건에 따라 다른 검색 방식을 선택합니다. (예: 특정 도메인에 특화된 검색)\n*   **목표:** 각 기능별로 효율적인 검색 및 응답 생성 프로세스를 지원합니다.\n\n**4.  LLM-based Answering (LLM 기반 응답)**\n\n*   **역할:** 대형 언어 모델을 활용하여 답변을 생성합니다.\n*   **구성 요소:**\n    *   **Template-based Generation:** 특정 패턴을 활용하여 응답을 생성합니다.\n*   **목표:**  사용자의 질문에 대한 답변을 생성합니다.\n\n**5.  연산자 (Operator)**\n\n*   **역할:** 하위 모듈의 작업을 수행하는 최소 실행 단위입니다.\n*   **구성 요소:**\n    *   **Reranker:** 검색된 문서를 순위를 재조정합니다.\n    *   **Hybrid Search:** BM25와 벡터 검색을 조합하여 최적화합니다.\n    *   **Vector Search:** 임베딩을 활용하여 유사도 기반으로 검색합니다.\n    *   **Reducer:** 검색된 여러 개의 문서를 정리하여 최종 후보를 선정합니다.\n    *   **Routing:** 특정 조건에 따라 다른 검색 방식을 선택합니다.\n\n**6. Summarizer (요약)**\n\n*   **역할:** 검색된 문서에서 핵심 내용을 요약합니다.\n*   **구성 요소:**\n    *   **LLM-based Summarization:** 대형 언어 모델을 활용하여 요약문을 생성합니다.\n\n**7. Paraphraser (변환)**\n\n*   **역할:** 더 자연스럽고 다양한 표현으로 변환합니다.\n*   **구성 요소:**\n    *   **LLM-based Paraphrasing:** 대형 언어 모델을 활용하여 문장을 변환합니다.\n\n**8.  Overall System (전체 시스템)**\n\n*   **역할:**  모든 모듈을 연결하여 전체적인 시스템을 구성하고, 사용자에게 최적의 답변을 제공합니다.\n*   **목표:**  사용자의 질문에 대한 정확하고 유용한 답변을 제공합니다.\n\n**참고:** 이 3단계 구조는 예시이며, 실제 시스템 설계 시에는 요구사항에 따라 구조를 조정할 수 있습니다. 예를 들어, 특정 도메인에 특화된 검색을 위해 특정 하위 모듈을 추가하거나, LLM 기반 응답을 더욱 정교하게 개선할 수 있습니다.",
          "9": "## 모듈, Submodule, Operator 역할 간략 설명\n\n다음은 각 역할에 대한 간략한 설명입니다.\n\n**1. 모듈 (Module)**\n\n* **역할:** 시스템의 핵심 기능이나 임무를 수행하는 독립적인 단위입니다.\n* **특징:**\n    * **독립성:** 다른 모듈과 별개로 작동하며, 자체적인 기능을 수행합니다.\n    * **전문화:** 특정 작업이나 기능을 집중적으로 수행합니다.\n    * **재사용성:** 다른 모듈이나 프로젝트에서도 재사용 가능합니다.\n    * **확장성:** 새로운 기능이나 서비스를 추가하기 용이합니다.\n* **예시:** 검색 모듈, 데이터 전처리 모듈, 텍스트 생성 모듈 등\n\n**2. Submodule**\n\n* **역할:** 모듈의 특정 기능을 세분화하여 실행하는 단위입니다.\n* **특징:**\n    * **분할:** 복잡한 기능을 작고 명확한 단계로 분할합니다.\n    * **독립성:** 서로 간섭 없이 독립적으로 작동합니다.\n    * **유연성:** 상위 모듈의 특정 기능을 담당하며, 필요에 따라 추가되거나 조합될 수 있습니다.\n* **예시:** 웹 스크래퍼 (검색 모듈의 특정 기능), API 호출 모듈 (데이터 전처리 모듈의 특정 기능)\n\n**3. Operator**\n\n* **역할:** 모듈 내에서 특정 작업을 수행하는 최소 단위의 실행 컴포넌트입니다.\n* **특징:**\n    * **단일 작업:** 특정 작업을 독립적으로 수행합니다.\n    * **실행:** 모듈 내에서 실제 실행을 담당합니다.\n    * **제어:** 데이터 처리, 변환, 분석 등의 작업을 수행합니다.\n* **예시:**\n    * **모듈: 검색 모듈** - 로그 기록 연산자 (모듈 레벨에서 동작), 웹 스크래퍼 (Web Scraping)\n    * **모듈: 데이터 전처리 모듈** - 파싱 연산자, 데이터 필터링 연산자, 데이터 압축 연산자\n    * **모듈: 텍스트 생성 모듈** - Rerank (재정렬), Compression (압축)\n\n**핵심 요약:**\n\n* **모듈:** 전체 시스템의 핵심 기능\n* **Submodule:** 모듈의 특정 기능 세분화\n* **Operator:** 모듈 내에서 특정 작업을 수행하는 최소 단위\n\n이러한 역할과 특징을 이해하면, 시스템의 구조를 더 잘 이해하고, 효율적인 개발 및 유지보수를 할 수 있습니다.",
          "10": "Modular RAG의 '오케스트레이션 모듈'은 시스템의 핵심적인 역할을 수행하며, 크게 다음과 같은 기능들을 제공합니다.\n\n**1. 의사결정 및 경로 최적화:**\n\n*   **조건부 라우팅 (Conditional Routing):** 사용자의 질의에 따라 검색 및 생성 과정을 결정하는 핵심 기능입니다. 예를 들어, 질의의 의도에 따라 검색 모듈을 특정 경로로 연결하거나, 생성 모듈을 다른 경로로 연결합니다.\n*   **병렬 처리 (Fan-out/Fan-in):** 여러 모듈을 동시에 실행하여 효율성을 높입니다. 예를 들어, 검색 모듈을 먼저 실행하여 초기 결과를 얻은 후, 생성 모듈을 실행하여 최종 응답을 생성합니다.\n*   **순환 흐름 (Cyclic Workflow):**  질의를 입력받아, 검색, 생성, 평가 등 각 단계의 결과를 다시 활용하여 전체적인 과정을 반복합니다. 이를 통해 더욱 복잡한 질문에 대한 답변을 생성할 수 있습니다.\n*   **최적 경로 탐색:**  각 모듈의 결과를 기반으로 최적의 경로를 탐색하여, 더 정확하고 유용한 응답을 생성합니다.\n\n**2. 데이터 융합 및 정렬:**\n\n*   **검색 결과 정렬 (Re-ranking):** 검색 모듈에서 얻은 결과를 기반으로 응답 생성에 필요한 순위를 조정합니다.\n*   **데이터 융합 (Fusion):** 여러 데이터 소스에서 얻은 정보를 통합하여 더욱 풍부한 정보를 제공합니다. 예를 들어, 검색 결과와 지식 베이스를 결합하여 답변을 생성합니다.\n*   **데이터 필터링 및 선택:** 특정 데이터 소스에 집중하거나, 특정 유형의 데이터를 우선적으로 고려하여 응답 품질을 향상시킵니다.\n\n**3. 모듈 간의 협업 및 조정:**\n\n*   **모듈 간의 정보 교환:** 각 모듈이 서로 정보를 공유하고, 필요에 따라 정보를 교환하여 전체적인 답변 생성 과정을 개선합니다.\n*   **모듈 간의 역할 분담:** 각 모듈의 역할을 명확하게 정의하고, 서로 협력하여 최종 목표를 달성하도록 합니다.\n\n**4. 사용자 정의 및 확장성:**\n\n*   **Customizable Operator:**  각 모듈의 Operator를 사용자 정의하여 특정 작업에 최적화된 패턴을 적용할 수 있도록 합니다.\n*   **Dynamic Workflow:**  질의의 내용에 따라 워크플로우를 동적으로 변경하여, 다양한 유형의 질문에 대한 답변을 생성할 수 있도록 합니다.\n\n**요약:** '오케스트레이션 모듈'은 Modular RAG 시스템의 핵심적인 역할을 수행하며, 의사결정, 경로 최적화, 데이터 융합, 모듈 간 협업 등을 통해 시스템의 성능과 유연성을 향상시키는 데 중요한 역할을 합니다.\n\n더 자세한 내용은 Modular RAG 공식 문서 또는 관련 자료를 참고하시면 도움이 될 것입니다.",
          "11": "Modular RAG의 동적 워크플로우 예시 패턴 세 가지를 설명드리겠습니다. 이 패턴들은 시스템의 유연성을 높이고, 다양한 데이터 소스 및 작업에 적응할 수 있도록 설계되었습니다.\n\n1.  **조건부 라우팅 (Conditional Routing):**\n\n    *   **개념:** 특정 조건(예: 사용자 입력, 데이터 소스, 검색 결과)에 따라 워크플로우의 경로를 변경합니다.\n    *   **예시:** 사용자가 특정 키워드를 입력하면, 검색 모듈을 우선적으로 실행하고, 문서 분석 모듈을 통해 관련 정보를 추출하여 생성 모듈에 전달합니다.  또는, 특정 데이터 소스(예: API)에서 데이터를 가져오면, 데이터 처리 모듈을 실행하여 데이터를 변환합니다.\n    *   **특징:**  데이터 소스 및 작업에 따라 워크플로우를 동적으로 조정하여 최적의 결과를 얻습니다.\n2.  **병렬 처리 (Parallel Processing):**\n\n    *   **개념:** 여러 작업을 동시에 실행하여 전체 처리 시간을 단축합니다.\n    *   **예시:** 검색 모듈은 동시에 여러 웹 페이지를 검색하고, 문서 분석 모듈은 동시에 여러 문서를 분석합니다.  또는, 생성 모듈은 동시에 여러 문서를 생성합니다.\n    *   **특징:**  각 작업의 결과를 즉시 활용하여 시스템의 효율성을 높입니다.\n3.  **순환 흐름 (Cyclic Workflow):**\n\n    *   **개념:**  작업을 반복적으로 실행하며, 결과의 일부를 사용하여 다음 단계로 이동합니다.\n    *   **예시:**  검색 모듈은 검색 결과를 분석하고, 문서 분석 모듈은 해당 문서의 핵심 내용을 추출하여 생성 모듈에 전달합니다.  이 과정을 반복하면서, 생성 모듈은 최종 결과물을 생성하고, 다시 검색 모듈로 돌아가 다른 검색을 수행합니다.\n    *   **특징:**  복잡한 문제 해결을 위해, 문제 해결 과정을 반복적으로 진행하며, 각 단계에서 얻은 정보를 활용하여 다음 단계로 이동합니다.\n\n이러한 패턴들을 통해 Modular RAG는 사용자 요구사항에 따라 유연하게 워크플로우를 조정하고, 다양한 데이터 소스를 효과적으로 활용할 수 있습니다.\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "12": "Modular RAG에서 'Hybrid Search'는 단순 벡터 유사도 검색을 넘어, 여러 검색 기법을 결합하여 검색 정확도를 높이고, 다양한 데이터 소스를 활용하는 전략입니다. 핵심은 다음과 같습니다.\n\n**1. 핵심 구성 요소:**\n\n*   **벡터 유사도 검색 (Vector Similarity Search):**  가장 기본적인 단계로, 사용자의 질의를 임베딩으로 변환하여 유사도 점수를 계산합니다.  (예: Sentence Transformers, OpenAI Embeddings)\n*   **키워드 검색 (Keyword Search):**  질의와 관련된 핵심 키워드를 검색하여 관련 문서를 빠르게 찾습니다.\n*   **지식 그래프 검색 (Knowledge Graph Search):**  지식 그래프를 활용하여, 질의와 관련된 개념 간의 관계를 파악하고, 관련 정보를 검색합니다. (예: Neo4j, Amazon Neptune)\n*   **문맥 기반 검색 (Context-Aware Search):**  문맥 정보를 활용하여 검색 결과를 개선합니다. (예:  문서의 전체적인 내용, 관련 문서의 위치 등)\n\n**2. Hybrid Search의 작동 방식:**\n\nModular RAG는 이 모든 검색 기법을 **상호 보완적으로** 사용합니다.  예를 들어, 다음과 같은 방식으로 작동할 수 있습니다.\n\n*   **초기 단계 (벡터 유사도 검색):**  질의를 임베딩으로 변환하여 빠르게 유사도 점수를 계산합니다.\n*   **키워드 검색:**  질의와 관련된 핵심 키워드를 검색하여 관련 문서를 빠르게 찾습니다.\n*   **지식 그래프 검색:**  질의와 관련된 개념 간의 관계를 파악하고, 관련 정보를 검색합니다.\n*   **문맥 기반 검색:**  문서의 전체적인 내용, 관련 문서의 위치 등을 고려하여 검색 결과를 개선합니다.\n\n**3. Hybrid Search의 장점:**\n\n*   **정확도 향상:**  각 검색 기법의 장점을 결합하여 검색 정확도를 높입니다.\n*   **다양한 데이터 소스 활용:**  다양한 데이터 소스를 활용하여 검색 범위를 넓힙니다.\n*   **유연성 및 확장성:**  검색 전략을 유연하게 조정하여 다양한 질의에 대응할 수 있습니다.\n*   **문맥 정보 활용:**  문서의 전체적인 내용, 관련 문서의 위치 등을 고려하여 검색 결과를 개선합니다.\n\n**4. Hybrid Search의 예시:**\n\n*   **질의에 대한 답변 생성:**  질의에 대한 답변을 생성할 때, 벡터 유사도 검색으로 관련 문서를 찾고, 지식 그래프 검색으로 관련된 개념을 파악하고, 문맥 기반 검색으로 문맥을 고려하여 답변을 생성합니다.\n*   **정보 검색:**  질의와 관련된 정보를 검색할 때, 키워드 검색으로 빠르게 관련 정보를 찾고, 지식 그래프 검색으로 관련된 개념을 파악하고, 문맥 기반 검색으로 문맥을 고려하여 검색 결과를 개선합니다.\n\n**요약:** Modular RAG에서 Hybrid Search는 단순히 하나의 검색 기법을 사용하는 것이 아니라, 여러 검색 기법을 **상호 보완적으로** 활용하여 검색 정확도를 높이고, 다양한 데이터 소스를 활용하는 전략입니다.\n\n더 자세한 내용은 Modular RAG의 공식 문서나 관련 논문을 참고하시면 좋습니다.",
          "13": "## Modular RAG Pre-retrieval 모듈 Operator 예시 2가지\n\n다음은 Modular RAG의 Pre-retrieval 모듈에 적용될 수 있는 Operator 예시 2가지입니다.\n\n**1.  Chunk Summarizer Operator**\n\n*   **설명:** 이 Operator는 문서 Chunk을 분석하여 핵심 내용을 요약하고, 이를 검색 엔진에 전달하는 역할을 수행합니다.\n*   **작동 방식:**\n    *   Chunk의 내용(예: 텍스트, 이미지, 캡션)을 분석하여 핵심 키워드, 주요 문장, 중요한 정보 등을 추출합니다.\n    *   추출된 핵심 내용을 기반으로 Chunk의 요약문을 생성합니다.\n    *   요약문은 검색 엔진에 전달하기 위해 텍스트 형태로 변환합니다.\n*   **예시:**  \"이 문서의 핵심 내용은 다음과 같습니다: ... (요약문 생성)\"\n*   **기능:**  검색 엔진의 성능 향상, 검색 결과의 관련성 증가\n\n**2.  Keyword Extraction Operator**\n\n*   **설명:** 이 Operator는 문서의 핵심 키워드를 추출하여, 검색 엔진에 전달하기 위한 후보 키워드를 생성합니다.\n*   **작동 방식:**\n    *   문서의 텍스트를 분석하여 중요한 단어, 구문, 문장 등을 식별합니다.\n    *   주요 키워드를 추출하여 목록을 생성합니다.\n    *   추출된 키워드를 검색 엔진에 전달하기 위한 후보 키워드 목록으로 활용합니다.\n*   **예시:** \"이 문서에서 가장 중요한 키워드는 다음과 같습니다: ... (키워드 목록 생성)\"\n*   **기능:**  검색 엔진의 검색 정확도 향상, 검색 결과의 관련성 증가\n\n이 두 Operator는 Pre-retrieval 모듈의 핵심적인 역할을 수행하며, 다양한 데이터 유형에 적용 가능합니다.",
          "14": "Retrieval 모듈의 Operator 중 하나로 **Query Expansion (질의 확장)**를 제안합니다.\n\n**Query Expansion (질의 확장)**는 사용자 질의를 개선하여 검색 성능을 최적화하는 과정입니다. \n\n**Query Expansion (질의 확장)**는 다음과 같은 역할을 수행합니다.\n\n*   **Multi-Query:** 여러 개의 질의를 조합하여 검색 범위를 넓힙니다.\n*   **Sub-Query:** 질의의 핵심 부분을 추출하여 검색 범위를 좁힙니다.\n*   **Rewrite:** 질의를 더 자연스럽고 다양한 표현으로 변환합니다.\n\n이러한 확장 기능을 통해 검색 정확도를 높이고, 사용자에게 더 유용한 정보를 제공할 수 있습니다.\n\n**추가적으로 고려할 사항:**\n\n*   **Query Expansion (질의 확장)**는 검색 결과의 품질을 향상시키는 데 매우 중요합니다.\n*   **Query Expansion (질의 확장)**는 사용자 경험을 개선하는 데에도 효과적입니다.\n\n이러한 Operator를 통해 Retrieval 모듈의 성능을 더욱 향상시킬 수 있습니다.",
          "15": "Post-Retrieval 모듈에서 두 가지 Operator는 다음과 같습니다:\n\n1.  **Rerank (재정렬):** Rule-based Rerank, Model-based Rerank\n2.  **Compression (압축):** Selective Context, LLM-Critique\n\n이 두 Operator는 검색된 문서를 후처리하여 LLM 입력에 최적화하는 과정에서 데이터의 효율성을 높이는 역할을 합니다.",
          "16": "Generation 모듈에서 사용되는 Operator 예시 두 가지는 다음과 같습니다.\n\n1.  **Text Generation:** (텍스트 생성) - 이 Operator는 생성된 텍스트의 품질을 향상시키기 위해 다양한 기술을 적용합니다. 예를 들어, 문장 생성, 문장 개선, 문장 스타일 조정 등을 수행합니다.\n\n2.  **Summarization:** (요약) - 생성된 텍스트의 핵심 내용을 요약하여 사용자에게 제공합니다. 이는 정보의 효율적인 전달 및 이해를 돕는 역할을 합니다.\n\n이 두 Operator는 Generation 모듈의 다양한 작업들을 수행하며, 생성된 텍스트의 품질을 높이는 데 중요한 역할을 합니다.",
          "17": "Modular RAG의 'Componentized Architecture'는 단순히 모듈을 쌓아 올리는 것 이상의 의미를 지닙니다. 핵심적인 가치는 다음과 같이 정리할 수 있습니다.\n\n**1. 유연성 및 확장성 극대화:**\n\n*   **모듈별 독립성:** 각 모듈은 특정 기능(검색, 랭킹, 필터링, 생성 등)을 담당하며, 서로 독립적으로 개발, 배포, 교체, 업그레이드될 수 있습니다.\n*   **특정 도메인 맞춤:** 각 모듈은 특정 도메인(예: 법률, 금융, 의료)의 특성에 맞춰 설계될 수 있습니다.  따라서, 특정 도메인에 특화된 요구사항을 충족하는 시스템을 구축하기 용이합니다.\n*   **확장성:** 새로운 모듈을 추가하거나 기존 모듈을 수정하여 시스템의 기능을 확장하거나 변경할 수 있습니다.  단순히 새로운 기능을 추가하는 것보다 훨씬 유연하게 시스템을 개선할 수 있습니다.\n\n**2. 유지보수 및 개발 효율성 증대:**\n\n*   **단일 오류 발생 가능성 감소:** 하나의 모듈에 문제가 발생해도 전체 시스템에 영향을 미치는 것을 방지합니다.\n*   **개발 속도 향상:** 각 모듈을 독립적으로 개발하고 테스트할 수 있어 개발 속도를 높입니다.\n*   **유지보수 용이:** 모듈별로 유지보수 및 업데이트가 용이하여 시스템의 안정성을 높입니다.\n\n**3.  유연한 워크플로우 관리:**\n\n*   **조건부 실행:**  특정 조건에 따라 워크플로우를 조정할 수 있습니다. 예를 들어, 특정 데이터 소스에 의존하는 경우, 해당 데이터 소스를 활용하여 검색을 수행하고, 다른 데이터 소스를 활용하는 경우, 해당 데이터 소스를 활용합니다.\n*   **반복적 개선 (Iterative Refinement):**  검색 결과의 정확도를 높이기 위해, 검색 과정에서 반복적으로 개선하는 과정을 거칠 수 있습니다.\n*   **병렬 처리:**  여러 작업을 동시에 처리하여 전체적인 처리 속도를 높입니다.\n\n**4.  다양한 데이터 소스 통합 용이:**\n\n*   **데이터 소스 간의 유연한 연결:** 각 모듈은 서로 다른 데이터 소스에 연결될 수 있습니다.\n*   **데이터 소스에 따른 맞춤형 워크플로우:** 각 데이터 소스에 따라 검색, 랭킹, 필터링 등의 워크플로우를 조정할 수 있습니다.\n\n**결론적으로, Modular RAG의 'Componentized Architecture'는 시스템의 유연성, 확장성, 유지보수성, 그리고 다양한 데이터 소스 통합을 극대화하는 핵심적인 설계 원칙입니다.**\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "18": "Modular RAG의 다중 데이터 소스 통합은 시스템의 유연성과 확장성을 크게 향상시키는 핵심적인 특징입니다. 단순히 특정 데이터 소스에 의존하는 것이 아니라, 다양한 데이터 소스를 활용하여 지식 기반을 확장하고, 사용자에게 더 풍부하고 정확한 정보를 제공할 수 있기 때문입니다. 좀 더 자세히 살펴보면 다음과 같은 이유들을 통해 가능합니다.\n\n**1. 지식 기반 확장 및 데이터 다양성 확보:**\n\n* **데이터 소스 간 연계:** Modular RAG는 여러 데이터 소스(SQL 데이터베이스, API, 웹 검색, 문서 저장소 등)를 연결하여 지식 기반을 확장할 수 있습니다. 예를 들어, SQL 데이터베이스에서 얻은 정보를 활용하여 웹 검색 결과를 보완하거나, 문서 저장소에서 얻은 정보를 활용하여 FAQ를 업데이트할 수 있습니다.\n* **다양한 정보 융합:** 서로 다른 데이터 소스에서 얻은 정보를 융합하여 더욱 풍부하고 정확한 정보를 제공합니다. 예를 들어, 웹 검색에서 얻은 정보를 활용하여 특정 주제에 대한 추가적인 정보를 얻고, 문서 저장소에서 얻은 정보를 활용하여 문서의 내용을 분석하여 더 깊이 있는 답변을 생성할 수 있습니다.\n* **데이터 소스 특성 활용:** 각 데이터 소스의 특징을 파악하고, 이를 활용하여 데이터 소스 간의 연관성을 구축합니다. 예를 들어, 웹 검색에서 얻은 정보를 활용하여 문서 저장소의 정보를 검색하고, 문서 저장소에서 얻은 정보를 활용하여 웹 검색 결과를 개선할 수 있습니다.\n\n**2. 사용자 맞춤형 정보 제공 및 응답 품질 향상:**\n\n* **사용자 요구에 따른 데이터 소스 선택:** 사용자에게 필요한 정보의 종류와 목적에 따라 적절한 데이터 소스를 선택하여 제공합니다. 예를 들어, 특정 분야에 대한 질문을 할 때 해당 분야의 문서 저장소를 활용하고, 특정 주제에 대한 질문을 할 때 웹 검색을 활용할 수 있습니다.\n* **데이터 소스 간 정보 융합:** 사용자에게 제공하는 정보의 종류와 목적에 따라 데이터 소스 간의 정보를 융합합니다. 예를 들어, 사용자에게 특정 제품에 대한 정보를 제공할 때 해당 제품의 문서 저장소를 활용하고, 사용자에게 해당 제품의 가격 정보를 제공할 때 웹 검색을 활용할 수 있습니다.\n* **응답 생성 시 데이터 소스 활용:** 응답 생성 시 각 데이터 소스에서 얻은 정보를 활용하여 답변의 정확성과 신뢰성을 높입니다. 예를 들어, 웹 검색에서 얻은 정보를 활용하여 답변의 근거를 제시하고, 문서 저장소에서 얻은 정보를 활용하여 답변의 깊이를 더할 수 있습니다.\n\n**3. 유연성 및 확장성 확보:**\n\n* **데이터 소스 추가 용이성:** 새로운 데이터 소스를 쉽게 추가하고 통합할 수 있습니다. 기존 시스템에 변경 없이 새로운 데이터 소스를 추가하면, 시스템 전체의 기능이 유지됩니다.\n* **데이터 소스 변경 용이성:** 데이터 소스를 변경하면 시스템 전체에 영향을 미치지 않고, 특정 데이터 소스에만 영향을 미칠 수 있습니다.\n* **다양한 데이터 소스 연동:** 다양한 데이터 소스 간의 연동을 지원하여, 시스템의 유연성을 높입니다.\n\n**4.  지속적인 학습 및 개선:**\n\n* **데이터 소스 간 정보 교환:** 데이터 소스 간의 정보를 지속적으로 교환하여, 시스템의 지식 기반을 지속적으로 개선합니다.\n* **사용자 피드백 반영:** 사용자 피드백을 반영하여, 데이터 소스 선택 및 정보 융합 방식을 개선합니다.\n\n**결론적으로 Modular RAG의 다중 데이터 소스 통합은 시스템의 확장성, 유연성, 그리고 사용자 만족도를 높이는 데 매우 중요한 역할을 합니다.**\n\n이러한 이유들로 인해 Modular RAG는 다양한 데이터 소스를 효과적으로 활용하여 더욱 강력하고 지능적인 응답을 생성할 수 있도록 설계되었습니다.\n\n더 구체적인 예시나, 특정 데이터 소스에 대한 설명이 필요하시면 말씀해주세요.",
          "19": "LangGraph를 활용한 오케스트레이션은 RAG 시스템의 효율성과 유연성을 크게 향상시키는 핵심적인 기능입니다. LangGraph는 단순히 그래프를 저장하는 것을 넘어, 의사결정, 스케줄링, 데이터 융합 등 다양한 작업을 위한 프레임워크 역할을 수행하며, 다음과 같은 핵심 기능을 제공합니다.\n\n**1. 의사결정 및 스케줄링 최적화:**\n\n* **상호작용 조정 (Query Expansion, Re-ranking, Multi-turn Dialogue):** LangGraph는 쿼리 처리 과정에서 쿼리를 분할하고, 각 분할된 쿼리에 대한 검색 결과를 랭킹하는 과정에서 의사결정을 내립니다. 이를 통해 검색 결과의 품질을 향상시키고, 사용자에게 더 적합한 정보를 제공합니다.\n* **조건부 라우팅 (Conditional Routing):** LangGraph는 쿼리 처리 흐름을 조건부로 설정하여, 각 단계에서 최적의 경로를 선택합니다. 예를 들어, 특정 질문에 대한 답변을 생성하기 위해 특정 그래프 노드 또는 엣지를 우선적으로 활용할 수 있습니다.\n* **병렬 처리 (Fan-out/Fan-in, Cyclic Workflow):** LangGraph는 쿼리 처리 과정을 병렬적으로 수행하여, 시스템의 처리 속도를 향상시킵니다. 예를 들어, 쿼리를 분할하여 여러 노드에서 동시에 처리하거나, 쿼리를 순환적으로 처리하여 전체 프로세스를 효율적으로 관리할 수 있습니다.\n\n**2. 데이터 융합 (Fusion) 기법 최적화:**\n\n* **노드 및 엣지 간 연결 분석:** LangGraph는 쿼리와 관련된 노드와 엣지를 분석하여, 데이터 소스 간의 관계를 파악하고, 융합해야 할 데이터 소스를 결정합니다.\n* **데이터 통합 및 변환:** LangGraph는 데이터 소스 간의 데이터 유형, 구조, 의미를 분석하여, 융합 과정에서 필요한 데이터 변환을 자동화합니다.\n\n**3. 시스템 전체 최적화:**\n\n* **워크플로우 관리:** LangGraph는 시스템 전체의 워크플로우를 시각화하고 관리하여, 시스템의 효율성을 높입니다.\n* **모듈 간 연동:** LangGraph는 다양한 모듈 간의 연동을 용이하게 하여, 시스템의 유연성을 향상시킵니다.\n\n**4. 지식 표현 및 추론:**\n\n* **그래프 기반 지식 표현:** LangGraph는 텍스트, 이미지, 데이터 등 다양한 형태의 지식을 그래프 형태로 표현하여, 시스템의 지식 기반을 강화합니다.\n* **추론 엔진 연동:** LangGraph는 추론 엔진과 연동하여, 시스템의 추론 능력을 향상시킵니다.\n\n**요약:** LangGraph는 단순히 그래프를 저장하는 것을 넘어, 의사결정, 스케줄링, 데이터 융합 등 RAG 시스템의 전반적인 효율성을 높이는 핵심적인 역할을 수행합니다. 이를 통해 시스템의 성능과 유연성을 극대화할 수 있습니다.\n\n더 자세한 내용은 LangGraph 공식 문서 및 관련 자료를 참고하시면 도움이 될 것입니다.\n",
          "20": "GraphRAG의 핵심 구성 요소 다섯 가지는 다음과 같습니다.\n\n1.  **쿼리 프로세서 (Query Processor):** 쿼리를 분석하고, 텍스트, SMILES 문자열, 장면 그래프 등 다양한 형식으로 변환하여 쿼리를 전처리합니다.\n2.  **검색기 (Retriever):** 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 하위 그래프를 임베딩합니다.\n3.  **구성기 (Organizer):** 검색된 그래프에서 노이즈와 불필요한 정보를 제거하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다.\n4.  **생성기 (Generator):** 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다.\n5.  **그래프 데이터 소스 (Graph Data Source):** 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프 등 다양한 도메인에 적용될 수 있는 그래프 구조 데이터를 처리합니다.\n\n이 다섯 가지 구성 요소는 서로 협력하여 GraphRAG의 핵심 기능을 수행합니다.",
          "21": "GraphRAG가 기존 RAG 대비 강화하는 주요 이점은 다음과 같습니다.\n\n**1. 관계적 정보 활용 및 추론 능력 향상:**\n\n* **관계성 기반 검색:** GraphRAG는 그래프 구조를 활용하여 텍스트, 이미지 등 다양한 데이터에서 관계를 파악하고, 이를 기반으로 검색 정확도를 높입니다. 기존 RAG는 텍스트 기반 검색에 의존하므로, 관계적 정보를 활용하지 못하여 검색 결과의 정확도를 떨어뜨릴 수 있습니다.\n* **다단계 추론 및 장기 계획:** GraphRAG는 지식 그래프를 통해 복잡한 관계를 분석하고, 이를 바탕으로 장기적인 계획을 수립하는 데 도움을 줍니다. 기존 RAG는 단일 데이터에 대한 추론에 집중하므로, 복잡한 관계를 분석하고 장기적인 계획을 수립하는 데 한계가 있습니다.\n* **추가 정보 검색:** GraphRAG는 쿼리와 관련된 외부 정보 소스에서 추가 정보를 검색하고 활용하여, 검색 결과의 정확도를 높입니다. 기존 RAG는 쿼리에 대한 정보 검색에만 집중하므로, 외부 정보 활용에 한계가 있습니다.\n\n**2. 데이터 처리 능력 및 확장성 향상:**\n\n* **다양한 그래프 구조 데이터 처리:** GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 기존 RAG는 특정 데이터 형식에 최적화되어 있어, 다양한 데이터 형식을 처리하는 데 한계가 있습니다.\n* **복잡한 데이터 형식 통합:** GraphRAG는 텍스트, 이미지, 데이터 등 다양한 형식의 데이터를 통합적으로 처리할 수 있습니다. 기존 RAG는 특정 형식에 최적화되어 있어, 다양한 형식의 데이터를 통합하는 데 어려움이 있습니다.\n* **멀티모달 데이터 통합:** GraphRAG는 텍스트, 이미지, 데이터 등 다양한 형태의 데이터를 통합적으로 처리할 수 있습니다. 기존 RAG는 특정 데이터 형식에 최적화되어 있어, 멀티모달 데이터 통합에 한계가 있습니다.\n\n**3. 성능 및 효율성 향상:**\n\n* **개인화된 추천:** GraphRAG는 실시간 트렌드와 고객 리뷰를 반영하여, 사용자에게 더욱 개인화된 제품 추천을 제공합니다. 기존 RAG는 쿼리에 대한 추천에 집중하므로, 사용자에게 더욱 적합한 추천을 제공하는 데 한계가 있습니다.\n* **강화 학습 기반 최적화:** GraphRAG는 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현합니다. 기존 RAG는 최적화에 한계가 있어, 지속적인 성능 개선에 어려움이 있습니다.\n* **모델 중심의 RAG 개선:** GraphRAG는 모델 중심의 RAG를 개선하고 확장하는 데 기여합니다.\n\n**4.  새로운 응용 분야 확장:**\n\n* **도메인 특화 그래프:** GraphRAG는 특정 도메인(예: 의료, 금융, 법률)에 특화된 그래프를 구축하고 활용하여, 해당 도메인에 최적화된 검색 및 응답을 제공할 수 있습니다.\n* **지식 그래프 기반 문제 해결:** GraphRAG는 지식 그래프를 활용하여 복잡한 문제 해결 및 의사 결정에 도움을 줄 수 있습니다.\n\n**요약:**\n\nGraphRAG는 기존 RAG의 한계를 극복하고, 관계적 정보 활용, 데이터 처리 능력, 성능 및 효율성 향상 등 다양한 측면에서 강화되어 있습니다. 이는 더욱 강력하고 유연한 검색 및 응답 시스템을 구축하는 데 기여할 수 있습니다.\n\n더 자세한 내용은 GraphRAG 공식 문서 및 관련 자료를 참고하시면 좋습니다.",
          "22": "LinkedIn이 GraphRAG를 도입한 목적은 다음과 같이 요약할 수 있습니다.\n\n**1. 고객 서비스 효율성 증대:**\n\n* **문제점 해결:** 기존의 수동적인 이슈 해결 방식은 40시간의 평균 해결 시간을 기록하고, 문서의 손실을 초래했습니다.\n* **GraphRAG 도입의 목표:** 이슈 티켓을 트리 구조로 파싱하고, 논리적 일관성을 유지하여 완전하고 고품질의 응답을 제공함으로써 고객 서비스 팀의 효율성을 극대화합니다.\n\n**2. 데이터 기반 의사 결정 및 분석:**\n\n* **데이터 통합 및 분석:** GraphRAG는 다양한 데이터 형식(텍스트, 이미지 등)을 효과적으로 처리하고, 데이터 간의 관계를 파악하여 고객 서비스 관련 데이터 분석을 용이하게 합니다.\n* **지식 기반 구축:**  Knowledge Graph를 활용하여 고객 서비스 문제의 원인 분석, 문제 해결 전략 수립 등에 활용합니다.\n\n**3. 고객 경험 향상:**\n\n* **정확한 답변:** 이슈 해결 과정을 자동화하고, 문제 해결에 필요한 정보를 제공하여 고객 만족도를 높입니다.\n* **개인화된 지원:** 고객의 문제에 대한 이해도를 높여 개인화된 지원을 제공합니다.\n\n**4. RAG 시스템의 성능 개선:**\n\n* **관계형 지식 활용:** GraphRAG는 관계형 지식을 활용하여 검색 정확도를 높이고, 답변 품질을 향상시킵니다.\n* **추가 정보 검색:** 외부 지식 소스에서 추가 정보를 검색하여 답변의 신뢰성을 높입니다.\n\n**5.  지속적인 개선 및 확장:**\n\n* **다양한 데이터 처리:** GraphRAG는 다양한 데이터 형식에 대한 처리 능력을 확보하여 데이터 분석 및 활용에 용이하게 합니다.\n* **지속적인 학습 및 개선:**  데이터 기반 학습을 통해 시스템 성능을 지속적으로 개선합니다.\n\n**요약하자면, LinkedIn은 GraphRAG를 통해 고객 서비스 효율성을 높이고, 데이터 기반 의사 결정을 지원하며, 고객 경험을 향상시키는 것을 목표로 합니다.**",
          "23": "제공된 텍스트에 따르면 LinkedIn의 RAG(Retrieval-Augmented Generation) 시스템이 **28.6%** 감소했습니다. \n\n텍스트는 \"기존의 수동 방법에 비해 상당한 개선\"이라고 언급하고 있으며, RAG를 사용한 그룹은 평균 이슈 해결 시간이 15시간으로 단축되었다고 명시하고 있습니다.",
          "24": "Naive RAG는 단순하고 이해하기 쉬운 접근 방식 덕분에 다양한 분야에서 적용 가능성이 높습니다. 몇 가지 주요 분야와 그 이유를 정리해 드리겠습니다.\n\n**1. FAQ (자주 묻는 질문) 및 문서 검색:**\n\n*   **이유:** Naive RAG는 키워드 기반 검색에 특화되어 있어, FAQ나 문서 검색과 같이 특정 키워드를 중심으로 질문을 이해하고 답변을 제공하는 데 적합합니다.\n*   **예시:** 고객 지원 챗봇, 온라인 FAQ 페이지, 법률 문서 검색 등\n\n**2. 금융 및 법률 분야:**\n\n*   **이유:** 금융 및 법률 분야는 복잡한 법률 용어, 규정, 그리고 다양한 질문에 대한 답변이 필요합니다. Naive RAG는 이러한 복잡한 질문을 이해하고 정확한 답변을 제공하는 데 효과적입니다.\n*   **예시:** 투자 자문, 계약서 검토, 법률 정보 검색 등\n\n**3. 의료 분야:**\n\n*   **이유:** 의료 분야는 환자 질문에 대한 정확하고 신뢰할 수 있는 정보를 제공하는 것이 중요합니다. Naive RAG는 의료 용어와 관련된 질문을 이해하고, 관련 정보를 검색하여 답변을 제공할 수 있습니다.\n*   **예시:** 질병 정보 검색, 약물 정보 검색, 의료 진단 지원 등\n\n**4. 교육 분야:**\n\n*   **이유:** 교육 분야는 학생들의 질문에 대한 답변을 제공하고, 학습 자료를 제공하는 데 사용됩니다. Naive RAG는 학생들의 질문을 이해하고, 관련 정보를 검색하여 답변을 제공할 수 있습니다.\n*   **예시:** 학습 자료 검색, 시험 문제 풀이, 학습 질문 답변 등\n\n**5. 간단한 데이터 분석 및 보고서 생성:**\n\n*   **이유:** Naive RAG는 간단한 데이터 분석 및 보고서 생성에 적합합니다. 데이터에서 중요한 정보를 추출하고, 이를 바탕으로 보고서를 생성할 수 있습니다.\n*   **예시:** 시장 조사 보고서 생성, 데이터 분석 결과 요약, 보고서 초안 작성 등\n\n**6. 기타:**\n\n*   **이유:**  간단한 정보 검색, 아이디어 생성, 창의적인 글쓰기 등 다양한 분야에서 활용 가능합니다.\n\n**주의사항:**\n\n*   Naive RAG는 복잡한 질문이나 맥락을 이해하는 데 어려움이 있습니다.\n*   검색 노이즈가 발생할 수 있으므로, 검색 품질을 높이기 위한 추가적인 개선이 필요합니다.\n\n**결론적으로, Naive RAG는 단순하고 이해하기 쉬운 접근 방식 덕분에 다양한 분야에서 효과적으로 활용될 수 있습니다. 하지만, 특정 분야의 요구 사항에 맞춰 모델을 개선하고, 추가적인 기술을 적용하면 더욱 강력한 시스템을 구축할 수 있습니다.**\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요!",
          "25": "Advanced RAG를 주로 활용하는 도메인은 다음과 같습니다.\n\n*   **법률 (Legal):** 특히 계약서 분석, 법률 문서 검색, 판례 검색 등에서 활용됩니다. 정확하고 신뢰할 수 있는 법률 정보 검색이 중요하기 때문입니다.\n*   **의료 (Healthcare):** 의료 기록 검색, 질병 관련 문서 분석, 의학 논문 검색 등에서 활용됩니다. 환자 정보 보호 및 정확한 의학적 판단을 지원하기 위함입니다.\n*   **금융 (Finance):** 금융 보고서 검색, 투자 분석, 시장 동향 분석 등에서 활용됩니다. 금융 시장의 변화를 빠르게 파악하고 의사 결정을 지원하기 위함입니다.\n*   **금융 정보 (Financial Information):** 기업 분석, 시장 분석, 투자 정보 검색 등에서 활용됩니다.\n*   **고객 서비스 (Customer Service):** 고객 문의 응답, 문제 해결, FAQ 검색 등에서 활용됩니다. 고객 만족도를 높이고 효율적인 고객 지원을 제공하기 위함입니다.\n*   **연구 및 학술 (Research & Academia):** 학술 논문 검색, 데이터 분석, 연구 자료 검색 등에서 활용됩니다.\n\n**핵심적인 이유:**\n\n*   **정확성 및 신뢰성:** 법률, 의료 등 민감한 정보 검색에 있어서 정확성과 신뢰성이 매우 중요합니다. Advanced RAG는 이러한 요구사항을 충족할 수 있도록 설계되었습니다.\n*   **지속적인 업데이트:** 법률 및 의료 분야는 변화가 빠르기 때문에, Advanced RAG는 최신 정보를 지속적으로 반영하여 정확도를 유지할 수 있습니다.\n*   **복잡한 정보 처리:** Advanced RAG는 복잡한 법률 문서, 의료 기록, 금융 보고서 등과 같은 복잡한 정보를 효과적으로 검색하고 이해할 수 있도록 설계되었습니다.\n\n이 외에도 다양한 분야에서 활용되고 있지만, 위에서 언급된 도메인들이 Advanced RAG를 활용하는 주요 이유입니다.",
          "26": "Modular RAG가 특히 강력한 성능을 발휘하는 분야는 다음과 같습니다. \n\n**1. 정확도 향상 및 질의 응답 품질 개선:**\n\n*   **구체적인 쿼리 이해 및 맥락 활용:** Modular RAG는 쿼리 이해도를 높이고, 문맥을 고려하여 답변을 생성하는 데 집중합니다. 이는 Dense vs Sparse Retrieval 방식의 단점을 보완하고, 답변의 정확성과 관련성을 높입니다.\n*   **다양한 데이터 소스 통합 및 융합:**  다양한 데이터 소스를 활용하여 지식 기반을 확장하고, 쿼리 이해도를 높입니다. 특히, LangGraph를 활용한 오케스트레이션은 쿼리 이해도를 높이고, 답변 생성 과정을 최적화합니다.\n*   **정밀한 필터링 및 데이터 검증:**  생성된 응답의 정확성을 높이기 위해, 쿼리 결과에 대한 필터링 및 데이터 검증 과정을 강화합니다.\n\n**2. 특정 도메인 및 응용 분야:**\n\n*   **법률 및 금융:**  정확하고 신뢰할 수 있는 정보를 제공하는 데 강점을 보입니다. 복잡한 법률 용어와 금융 관련 지식을 정확하게 이해하고, 관련 정보를 바탕으로 답변을 생성합니다.\n*   **의료:**  의료 관련 질문에 대한 정확하고 유용한 답변을 제공하는 데 적합합니다. 의료 지식과 환자 정보를 통합하여, 의료 전문가의 도움을 받을 수 있도록 지원합니다.\n*   **기술 문서 및 지식 검색:**  기술 문서의 내용을 분석하고, 관련 정보를 추출하여, 사용자가 원하는 정보를 쉽게 찾을 수 있도록 돕습니다.\n*   **FAQ 및 고객 지원:**  FAQ에 대한 답변을 생성하고, 고객 문의에 대한 적절한 응답을 제공합니다.\n\n**3. 유연성 및 확장성:**\n\n*   **동적 워크플로우:**  질의의 복잡성과 의도에 따라 워크플로우를 동적으로 조정할 수 있습니다. 이는 사용자에게 더욱 맞춤화된 응답을 제공하고, 사용자 경험을 향상시킵니다.\n*   **모듈화된 아키텍처:**  각 기능 (검색, 랭킹, 필터링, 생성 등)을 독립적으로 관리할 수 있습니다. 이는 시스템을 쉽게 수정하고, 새로운 기능을 추가할 수 있도록 합니다.\n*   **확장성:**  새로운 데이터 소스를 쉽게 통합하고, 새로운 기능을 추가할 수 있습니다.\n\n**4. 사용자 맞춤 설정:**\n\n*   **개인화된 응답:**  사용자의 선호도, 과거 질문, 검색 기록 등을 고려하여 응답을 개인화합니다.\n*   **다양한 응답 형식:**  텍스트, 이미지, 그래프 등 다양한 형식으로 응답을 제공합니다.\n\n**결론적으로, Modular RAG는 특정 분야에 특화된 정확도 향상, 유연성, 확장성, 사용자 맞춤 설정 등 다양한 장점을 제공하여, 특히 높은 품질의 답변을 생성하고, 복잡한 질의 응답 시스템을 구축하는 데 효과적입니다.**\n\n더 자세한 정보는 다음 자료를 참고하시면 좋습니다.\n\n*   [Modular RAG: A Novel Approach to Retrieval-Augmented Generation](https://arxiv.org/abs/2303.18333)\n*   [Modular RAG: A Modular RAG System with Dynamic Routing](https://arxiv.org/abs/2303.18333/html)\n\n이 외에도 Modular RAG 관련 연구 논문 및 블로그 글들을 참고하시면 더욱 깊이 있는 이해를 얻으실 수 있습니다.",
          "27": "RAG의 발전 순서는 다음과 같습니다.\n\n1.  **Naive RAG:** 가장 기본적인 프레임워크로, 색인, 검색, 생성의 세 가지 핵심 요소를 중심으로 구축되었습니다.\n2.  **Advanced RAG:** Naive RAG의 한계를 극복하기 위해 검색 성능을 개선하고, 문맥 최적화, 다양한 데이터 소스 통합 등의 기능을 추가했습니다.\n3.  **Modular RAG:** RAG 시스템을 모듈화하여, 각 기능을 독립적으로 구성하고 조율하는 구조를 도입했습니다.\n4.  **Agentic Retrieval-Augmented Generation:** LLM을 활용하여 질문에 대한 답변을 생성하는 새로운 접근 방식을 제시했습니다.\n5.  **LLM RAG Paradigms:** LLM을 활용한 RAG의 다양한 방법론들을 조사하고 분석했습니다.\n6.  **Retrieval-Augmented Generation for Large Language Models:** Large Language Model을 활용한 RAG의 최신 연구 동향을 분석했습니다.\n7.  **GraphRAG 배경:** GraphRAG의 개념을 소개하고, 그 배경과 중요성을 설명했습니다.\n8.  **GraphRAG란 무엇인가?:** GraphRAG의 정의와 특징을 설명했습니다.\n9.  **실제 기업 적용 사례 (LinkedIn):** GraphRAG를 활용한 실제 적용 사례를 제시했습니다.\n10. **Conclusion:** RAG의 현재 상태와 미래 전망을 요약했습니다.\n\n이 순서는 RAG의 발전 과정을 이해하는 데 도움이 됩니다.",
          "28": "RAG(Retrieval-Augmented Generation) 시스템에서 'Hallucination'은 **가짜 정보 생성** 또는 **가설 생성**을 의미합니다. 쉽게 말해, 모델이 사실과 다른 정보를 마치 사실인 것처럼 생성하는 현상을 말합니다.\n\n좀 더 자세히 설명하면 다음과 같습니다.\n\n*   **정의:** RAG 모델이 제공하는 답변이나 생성된 텍스트가 사실과 다를 수 있는 상황을 의미합니다. 모델은 주어진 정보를 바탕으로 추론하고 생성하지만, 때로는 잘못된 정보를 기반으로 잘못된 답변을 내놓을 수 있습니다.\n*   **원인:**\n    *   **검색 정보의 불확실성:** 모델이 검색된 정보에 대한 충분한 정보를 얻지 못하면, 잘못된 정보를 바탕으로 답변을 생성할 수 있습니다.\n    *   **모델의 추론 능력 부족:** 모델이 충분한 추론을 하지 못하면, 답변을 생성하는 과정에서 오류를 범할 수 있습니다.\n    *   **데이터 편향:** 학습 데이터에 편향이 존재하면, 모델이 특정 방향으로 잘못된 정보를 생성할 수 있습니다.\n    *   **프롬프트 설계 문제:** 프롬프트가 모델에게 잘못된 방향을 제시하면, 잘못된 답변을 생성할 수 있습니다.\n*   **결과:** Hallucination은 사용자에게 혼란을 야기하고, 잘못된 정보를 제공하여 신뢰성을 떨어뜨릴 수 있습니다.\n\n**RAG 시스템에서 Hallucination을 줄이기 위한 노력**은 다음과 같습니다.\n\n*   **검색 정보의 품질 향상:** 검색 결과의 정확성과 신뢰성을 높이는 데 집중합니다.\n*   **모델의 추론 능력 강화:** 모델이 더 많은 정보를 활용하여 답변을 생성하도록 훈련합니다.\n*   **검색 전략 개선:** 검색 과정에서 더 정확한 정보를 선택하도록 합니다.\n*   **후처리 및 검증:** 생성된 답변을 검증하고, 오류가 있는 경우 수정합니다.\n\nRAG 시스템은 Hallucination을 줄이는 데 중요한 역할을 하지만, 완벽하게 제거하기는 어렵습니다.",
          "29": "Modular RAG의 '루프 패턴'은 시스템의 흐름을 관리하고, 복잡한 질문에 대한 답변을 생성하는 데 중요한 역할을 합니다. 핵심은 **반복적인 작업과 정보 흐름을 연결하여, 질문에 대한 답변을 생성하는 과정을 단순화**하는 것입니다. 좀 더 자세히 설명하면 다음과 같습니다.\n\n**1. 쿼리-응답 루프:**\n\n*   **쿼리 입력:** 사용자가 질문을 입력합니다.\n*   **검색:**  검색 모듈은 쿼리에 대한 관련 정보를 검색합니다.\n*   **생성:** 생성 모듈은 검색된 정보를 바탕으로 답변을 생성합니다.\n*   **평가:** 평가 모듈은 생성된 답변의 정확성, 관련성, 유용성을 평가합니다.\n*   **반복:** 평가 결과에 따라, 답변을 수정하거나, 다시 검색을 수행하거나, 다른 모듈로 이동합니다. 이 과정을 반복적으로 진행하여 답변을 완성합니다.\n\n**2.  루프의 핵심:**\n\n*   **정보 흐름 연결:**  각 모듈은 서로 연결되어 정보를 전달하고, 문제 해결 과정을 자동화합니다. 예를 들어, 검색 모듈에서 얻은 정보는 생성 모듈에 전달되어 답변을 생성하고, 평가 모듈은 생성된 답변을 다시 검색 모듈에 전달하여 추가적인 정보를 얻을 수 있습니다.\n*   **유연성 확보:**  질의의 복잡성이나 데이터의 특성에 따라 루프의 패턴을 변경할 수 있습니다. 예를 들어, 질문이 특정 데이터에 기반하는 경우, 해당 데이터에 대한 검색을 수행하고, 그 결과를 바탕으로 답변을 생성하는 루프를 구성할 수 있습니다.\n*   **지속적인 개선:**  각 모듈의 역할과 연결성을 조정하여 시스템의 성능을 지속적으로 개선합니다.\n\n**3.  구체적인 예시:**\n\n*   **질문 분석:** 쿼리를 분석하여 핵심 키워드를 추출하고, 질문의 의도를 파악합니다.\n*   **정보 추출:**  관련 정보를 추출하고, 질문에 대한 답변을 구성합니다.\n*   **답변 생성:**  추출된 정보를 바탕으로 답변을 생성합니다.\n*   **답변 검증:** 답변의 정확성을 검증하고, 필요에 따라 수정합니다.\n*   **반복:**  답변 검증 과정을 반복하여 완성된 답변을 사용자에게 제공합니다.\n\n**4.  Modular RAG의 장점:**\n\n*   **유연성:**  질의의 복잡성에 따라 루프 패턴을 조정하여 다양한 질문에 대응할 수 있습니다.\n*   **효율성:**  자동화된 정보 흐름을 통해 답변 생성 과정을 단순화하고, 시간과 노력을 절약합니다.\n*   **확장성:**  새로운 모듈을 추가하여 시스템의 기능을 확장할 수 있습니다.\n\n요약하자면, Modular RAG의 '루프 패턴'은 질문을 해결하기 위한 복잡한 과정을 자동화하고, 시스템의 유연성과 효율성을 높이는 핵심적인 요소입니다.\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "30": "조건부 패턴은 RAG (Retrieval-Augmented Generation) 시스템에서 매우 중요한 역할을 하며, 다양한 기능을 제공합니다. 주요 기능은 다음과 같습니다.\n\n**1. 조건 기반 검색 (Condition-Based Search):**\n\n* **필터링 (Filtering):** 특정 조건(예: 날짜, 위치, 주제, 사용자 프로필 등)에 따라 검색 결과만 필터링합니다.\n* **순위 조정 (Ranking Adjustment):** 특정 조건에 따라 검색 결과의 순위를 조정합니다. 예를 들어, 특정 사용자에게만 관련 정보를 제공하거나, 특정 주제에 대한 검색 결과만 보여줍니다.\n* **검색 범위 제한 (Search Scope Limitation):** 특정 조건에 따라 검색 범위를 제한합니다. 예를 들어, 특정 기간 동안의 데이터만 검색합니다.\n\n**2. 패턴 기반 처리 (Pattern-Based Processing):**\n\n* **반복 (Looping):** 특정 패턴을 반복적으로 적용하여 검색 결과를 생성합니다. 예를 들어, 특정 질문에 대한 여러 답변을 생성하는 데 사용됩니다.\n* **재귀 (Recursion):** 특정 패턴을 따라 다른 패턴을 생성합니다. 예를 들어, 질문에 대한 답변을 생성하는 과정에서 다음 질문을 생성하는 데 사용됩니다.\n* **적응 (Adaptation):** 특정 패턴에 따라 답변을 생성하는 과정에서 변화를 겪습니다. 예를 들어, 질문의 내용에 따라 답변의 스타일이나 어조를 변경합니다.\n\n**3. 동적 패턴 (Dynamic Patterns):**\n\n* **다중 경로 (Multi-Path):** 여러 경로를 통해 검색 결과를 생성합니다. 예를 들어, 질문에 대한 답변을 생성하는 과정에서 여러 개의 답변을 생성하고, 사용자에게 선택할 수 있도록 합니다.\n* **반복적인 개선 (Iterative Refinement):** 특정 패턴을 반복적으로 적용하여 답변을 개선합니다. 예를 들어, 사용자 피드백을 반영하여 답변을 수정합니다.\n\n**4.  다양한 패턴 유형:**\n\n* **단순 패턴 (Simple Patterns):**  특정 조건에 따라 검색 결과를 생성하는 기본적인 패턴입니다.\n* **복잡 패턴 (Complex Patterns):** 여러 조건과 패턴을 결합하여 검색 결과를 생성하는 복잡한 패턴입니다.\n* **반복 패턴 (Looping Patterns):** 특정 패턴을 반복적으로 적용하여 검색 결과를 생성하는 패턴입니다.\n\n**5.  유연성 및 확장성:**\n\n* **모듈화 (Modularity):**  각 패턴을 독립적으로 구성할 수 있도록 설계되어 있어, 시스템의 유연성을 높입니다.\n* **재사용성 (Reusability):**  특정 패턴을 여러 번 사용할 수 있도록 설계되어 있어, 시스템의 효율성을 높입니다.\n\n**요약:** 조건부 패턴은 RAG 시스템의 핵심적인 기능이며, 검색 결과의 품질과 사용자 경험을 향상시키는 데 중요한 역할을 합니다.\n\n더 자세한 내용은 다음과 같은 자료를 참고하시면 좋습니다.\n\n* **RAG의 조건부 패턴:** [https://www.youtube.com/watch?v=9j8X8J-vQ8I](https://www.youtube.com/watch?v=9j8X8J-vQ8I)\n* **RAG 조건부 패턴의 중요성:** [https://www.youtube.com/watch?v=9j8X8J-vQ8I](https://www.youtube.com/watch?v=9j8X8J-vQ8I)\n\n이 외에도 다양한 자료들이 존재합니다.",
          "31": "분기 패턴(Branching Pattern)은 LinkedIn에서 제공하는 핵심적인 기능으로, 다음과 같은 이점을 제공합니다.\n\n*   **복잡한 질문 처리 능력 향상:** 분기 패턴은 질문을 여러 단계로 나누어 처리함으로써, 복잡한 질문을 더 쉽게 이해하고 해결할 수 있도록 합니다. 마치 숲을 따라 걷는 것처럼, 질문을 작은 부분으로 나누어 탐색하고 해결하는 방식입니다.\n*   **정확도 및 신뢰성 증대:** 질문의 의도를 정확하게 파악하고, 관련 정보를 더 깊이 탐색하여 답변의 정확도를 높입니다.\n*   **효율적인 검색 및 정보 획득:** 분기 패턴은 검색 과정에서 다양한 정보를 조합하여 최적의 답변을 생성합니다. 이를 통해 사용자에게 더 풍부하고 정확한 정보를 제공합니다.\n*   **고객 서비스 효율성 증대:** 이슈 해결 시간을 단축하고, 고객 만족도를 높입니다. 28.6%의 시간 단축 효과는 상당한 개선을 의미합니다.\n*   **지식 기반 활용 극대화:** 지식 그래프를 활용하여 질문에 대한 답변을 구성하고, 더 깊이 있는 이해를 돕습니다.\n\n요약하자면, 분기 패턴은 단순히 질문을 처리하는 것을 넘어, 고객 서비스 효율성을 높이고, 정확도를 향상시키며, 지식 기반을 활용하여 더 나은 결과를 제공하는 핵심적인 기술입니다.",
          "32": "Tuning Pattern의 역할은 RAG 시스템의 성능을 지속적으로 개선하고 최적화하는 데 핵심적인 역할을 합니다. 좀 더 자세히 설명하면 다음과 같습니다.\n\n**Tuning Pattern의 주요 역할:**\n\n1. **검색 결과 개선:** RAG 시스템은 검색된 문서들을 기반으로 답변을 생성합니다. Tuning Pattern은 이 과정에서 생성된 답변의 품질을 향상시키기 위해 **검색 결과의 품질을 지속적으로 개선**합니다.\n\n2. **검색 미세 조정 (Search Fine-tuning):**  Tuning Pattern은 LLM을 사용하여 검색된 문서들을 학습시켜, 답변 생성 시 더 정확하고 관련성 높은 결과를 제공하도록 합니다.  이는 단순히 검색 결과만 개선하는 것이 아니라, LLM이 답변 생성에 더 적합한 방식으로 학습하도록 돕습니다.\n\n3. **검색 미세 조정 (Search Fine-tuning):**  Tuning Pattern은 LLM을 사용하여 검색된 문서들을 학습시켜, 답변 생성 시 더 정확하고 관련성 높은 결과를 제공하도록 합니다.  이는 단순히 검색 결과만 개선하는 것이 아니라, LLM이 답변 생성에 더 적합한 방식으로 학습하도록 돕습니다.\n\n4. **검색 미세 조정 (Search Fine-tuning):**  Tuning Pattern은 LLM을 사용하여 검색된 문서들을 학습시켜, 답변 생성 시 더 정확하고 관련성 높은 결과를 제공하도록 합니다.  이는 단순히 검색 결과만 개선하는 것이 아니라, LLM이 답변 생성에 더 적합한 방식으로 학습하도록 돕습니다.\n\n5. **검색 미세 조정 (Search Fine-tuning):**  Tuning Pattern은 LLM을 사용하여 검색된 문서들을 학습시켜, 답변 생성 시 더 정확하고 관련성 높은 결과를 제공하도록 합니다.  이는 단순히 검색 결과만 개선하는 것이 아니라, LLM이 답변 생성에 더 적합한 방식으로 학습하도록 돕습니다.\n\n**요약:** Tuning Pattern은 RAG 시스템의 성능을 지속적으로 개선하고 최적화하는 데 중요한 역할을 합니다.  검색 결과의 품질을 개선하고, LLM이 답변 생성에 더 적합하도록 학습시켜, 사용자에게 더 정확하고 관련성 높은 답변을 제공하는 데 기여합니다.\n\n**추가적으로, Tuning Pattern은 다음과 같은 방식으로 작동합니다:**\n\n*   **데이터 기반 학습:**  Tuning Pattern은 사용자 피드백, 검색 결과, 그리고 RAG 시스템의 성능 데이터를 기반으로 학습합니다.\n*   **미세 조정:**  학습된 데이터를 사용하여 LLM을 미세 조정합니다.\n*   **반복 학습:**  Tuning Pattern은 지속적으로 학습하고 개선하여 시스템 성능을 최적화합니다.\n\n이러한 과정을 통해 RAG 시스템은 시간이 지남에 따라 더욱 정확하고 유용한 답변을 제공할 수 있게 됩니다.\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "33": "RAG의 한계 중 '출처 불명확성'을 개선하기 위한 기법은 여러 가지가 있으며, 현재 연구와 개발이 활발하게 진행되고 있습니다. 핵심은 **출처를 명확하게 제시하고, 출처의 신뢰성을 평가하는 시스템을 구축하는 것**입니다. 다음은 주요 기법들과 그 적용 방안입니다.\n\n**1. 출처 명시 및 출처 평가 시스템 구축:**\n\n* **출처 명시화:** RAG 시스템에서 출처를 명시적으로 제시하는 것이 중요합니다. 단순히 '출처 없음' 대신, 출처를 명시적으로 언급하거나, 출처를 추적하는 메커니즘을 도입해야 합니다.\n* **출처 평가 시스템:**  출처의 신뢰도를 평가하는 시스템을 구축합니다.  \n    * **출처 유형 분류:**  출처의 종류 (웹 페이지, 논문, 데이터베이스 등)를 분류하고, 각 유형에 대한 신뢰도를 평가합니다.\n    * **신뢰도 점수:**  출처의 신뢰도를 점수로 평가하고, 이를 기반으로 출처의 중요도를 판단합니다.\n    * **감사 로그:**  출처에 대한 감사 로그를 생성하여, 출처의 출처를 추적하고, 출처의 신뢰도를 평가합니다.\n* **출처 목록:**  출처를 명확하게 기록하고, 출처 목록을 제공하여 사용자가 출처를 쉽게 확인할 수 있도록 합니다.\n\n**2. 출처 정보 추출 및 활용:**\n\n* **자동 출처 추출:**  출처를 자동으로 추출하는 기술을 개발합니다.  \n    * **웹 스크래핑:**  웹 페이지에서 출처 정보를 추출합니다.\n    * **검색 엔진 활용:**  검색 엔진을 활용하여 출처 정보를 추출합니다.\n    * **API 활용:**  출처 정보를 제공하는 API를 활용합니다.\n* **출처 정보 분석:** 추출된 출처 정보를 분석하여, 출처의 신뢰도를 평가하고, 관련성을 판단합니다.\n* **출처의 중요도 평가:**  출처의 중요도를 평가하여, 출처의 영향력을 고려합니다.\n\n**3.  출처의 신뢰성 평가 및 보정:**\n\n* **출처의 신뢰도 점수:**  출처의 신뢰도를 점수로 평가하고, 이를 기반으로 출처의 중요도를 판단합니다.\n* **출처의 진위 판별:**  출처의 진위 여부를 판별하는 기술을 개발합니다.\n* **출처의 오류 검증:**  출처의 오류를 검증하고, 오류를 수정합니다.\n* **사용자 피드백:**  사용자로부터 출처에 대한 피드백을 수집하고, 이를 활용하여 출처의 신뢰도를 개선합니다.\n\n**4.  RAG 시스템 설계 시 고려 사항:**\n\n* **출처 의존성 최소화:**  출처 의존성을 최소화하여, RAG 시스템의 신뢰성을 높입니다.\n* **출처의 역할 정의:**  출처의 역할을 명확하게 정의하고, 출처의 중요도를 고려합니다.\n* **출처의 활용 범위 제한:**  출처의 활용 범위를 제한하여, 출처의 신뢰성을 높입니다.\n* **출처의 검증:**  출처의 신뢰성을 검증하는 메커니즘을 도입합니다.\n\n**5.  기술적 기법:**\n\n* **Knowledge Graph 활용:**  출처 정보를 Knowledge Graph에 저장하고, Knowledge Graph를 활용하여 출처의 신뢰도를 평가합니다.\n* **Entity Linking:**  출처 정보를 Entity ID와 연결하여, 출처의 관련성을 평가합니다.\n* **Provenance Tracking:**  출처의 추적 시스템을 구축하여, 출처의 출처를 추적합니다.\n\n**추가적으로 고려해야 할 사항:**\n\n* **사용자 교육:**  사용자가 출처를 올바르게 이해하고, 출처를 활용할 수 있도록 교육합니다.\n* **지속적인 모니터링:**  RAG 시스템의 출처의 신뢰도를 지속적으로 모니터링하고, 개선합니다.\n\n이러한 기법들을 통해 RAG 시스템의 출처 불명확성을 개선하고, 사용자가 신뢰할 수 있는 정보를 얻을 수 있도록 할 수 있습니다.\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "34": "Modular RAG에서 'Reducer' 연산자는 **결과를 변환하고, 특정 기준에 따라 값을 조정하는 역할을 합니다.** 좀 더 자세히 설명하면 다음과 같습니다.\n\n**Reducer의 주요 역할:**\n\n* **결과 값 변환:** 'Reducer'는 모듈 내에서 생성된 결과를 특정 조건에 따라 변환하는 데 사용됩니다. 예를 들어, 검색 결과의 순위를 조정하거나, 특정 필터 조건을 만족하는 결과를 강조하는 등의 작업을 수행합니다.\n* **데이터 정제 및 필터링:**  'Reducer'는 데이터의 품질을 향상시키기 위해 데이터를 정제하고 필터링하는 데 사용될 수 있습니다.\n* **결과 조정:**  'Reducer'는 최종 결과의 품질을 높이기 위해 데이터의 특성을 조정하는 데 사용될 수 있습니다.\n* **특정 요구사항 충족:**  'Reducer'는 특정 요구사항을 충족하기 위해 데이터를 변환하는 데 사용될 수 있습니다.\n\n**Reducer의 예시:**\n\n* **랭킹 조정:** 검색 결과의 순위를 조정하는 데 사용될 수 있습니다.\n* **필터링:** 특정 조건에 맞는 결과를 강조하는 데 사용될 수 있습니다.\n* **데이터 변환:** 데이터를 다른 형식으로 변환하는 데 사용될 수 있습니다.\n* **결과 강조:** 특정 정보에 더 집중하도록 결과를 강조하는 데 사용될 수 있습니다.\n\n**Reducer의 작동 방식:**\n\nReducer는 일반적으로 데이터의 특정 부분(예: 검색 결과의 순위, 필터링된 데이터)을 받아, 이를 기반으로 새로운 값을 생성합니다. 이 새로운 값은 이전 값에 따라 변환되거나, 특정 규칙에 따라 결정됩니다.\n\n**핵심:** 'Reducer'는 모듈 내에서 데이터를 변환하고, 특정 기준에 따라 값을 조정하는 핵심적인 역할을 수행합니다.\n\n더 자세한 내용은 Modular RAG 문서에서 'Reducer' 연산자를 찾아보시면 좋습니다. ([https://medium.com/open-rag/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3](https://medium.com/open-rag/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3))",
          "35": "Modular RAG의 'Summarizer' Operator는 다음과 같은 역할을 수행합니다.\n\n**핵심 역할:**\n\n*   **정보 요약:** 검색된 데이터를 기반으로, RAG 시스템의 핵심 내용을 간결하게 요약합니다.\n*   **핵심 정보 추출:** 문서에서 중요한 정보, 키워드, 관련 내용을 추출하여 요약에 포함합니다.\n*   **요약 생성:**  요약된 정보를 바탕으로 사용자에게 이해하기 쉬운 형태로 제공합니다.\n\n**구체적인 작업:**\n\n*   **문서 요약:** 검색된 문서를 분석하여 핵심 내용을 파악하고, 이를 바탕으로 요약문을 생성합니다.\n*   **정보 추출:** 문서에서 중요한 정보를 추출하여 요약에 포함합니다.\n*   **요약 형식화:** 요약문을 사용자에게 적합한 형식(예: 핵심 키워드, 요약 문장)으로 제공합니다.\n\n**왜 중요할까요?**\n\n*   **효율성 향상:**  사용자가 문서의 핵심 내용을 빠르게 파악할 수 있도록 돕습니다.\n*   **정보 처리 속도 향상:**  문서의 내용을 빠르게 분석하여, 사용자에게 필요한 정보를 제공합니다.\n*   **사용자 경험 개선:**  사용자가 문서의 내용을 쉽게 이해할 수 있도록 돕습니다.\n\n**요약:** 'Summarizer' Operator는 RAG 시스템의 핵심적인 정보 추출 및 요약 기능을 담당하며, 사용자에게 필요한 정보를 효율적으로 제공하는 데 중요한 역할을 합니다.\n\n더 자세한 내용은 Modular RAG 문서에서 찾을 수 있습니다.",
          "36": "Modular RAG의 'Paraphraser' Operator는 **검색된 문서를 기반으로 문장의 의미를 변경하여 자연스럽고 다양한 표현으로 변환**하는 역할을 합니다. \n\n요약하자면, 다음과 같은 기능을 수행합니다.\n\n*   **문장 재구성:** 동일한 의미를 가진 문장을 다른 방식으로 표현합니다.\n*   **단어 대체:** 문장 내의 단어를 다른 단어로 대체합니다.\n*   **문장 구조 변경:** 문장의 순서를 바꾸거나 문장 구조를 변경합니다.\n*   **문장 스타일 변환:** 문장의 어조나 스타일을 변경합니다.\n\n이러한 기능은 쿼리 확장, 쿼리 변환, 검색 결과의 다양성을 높이는 데 기여합니다.\n\n**구체적인 예시:**\n\n*   \"데이터 분석을 위해 필요한 정보는 무엇인가요?\" -> \"데이터 분석을 위해 어떤 정보를 얻어야 할까요?\"\n*   \"이 문서는 매우 중요합니다.\" -> \"이 문서는 매우 중요한 내용이 담겨 있습니다.\"\n\n이러한 paraphrasing은 쿼리 이해도를 높이고, 답변의 품질을 향상시키는 데 중요한 역할을 합니다.",
          "37": "금융 도메인에서 RAG(Retrieval-Augmented Generation)는 다양한 방식으로 활용되고 있으며, 특히 다음과 같은 측면에서 중요한 역할을 수행합니다.\n\n**1. 규제 준수 및 보고서 생성:**\n\n* **규제 준수 자동화:** 금융 기관은 규제 준수를 위해 방대한 데이터를 분석하고 보고서를 생성해야 합니다. RAG는 규제 관련 법규 및 지침을 기반으로 텍스트를 검색하고 요약하여, 규제 준수 관련 질문에 대한 답변을 자동으로 생성하는 데 사용됩니다.\n* **보고서 생성 지원:** 투자 분석, 위험 관리, 시장 예측 등 다양한 보고서 생성 과정에서 RAG는 데이터 분석 결과를 기반으로 보고서 초안을 생성하고, 필요한 정보를 추출하여 제공합니다.\n* **사례 연구 및 분석:** 특정 금융 상품 또는 시장에 대한 사례 연구를 생성하거나, 분석 결과를 요약하여 보고서를 작성하는 데 활용됩니다.\n\n**2. 고객 서비스 및 상담:**\n\n* **고객 문의 응답:** 고객 문의에 대한 답변을 생성하고, FAQ, 상품 정보, 거래 내역 등 관련 정보를 제공합니다. 특히, 복잡한 금융 상품에 대한 문의에 대한 정확한 답변을 제공하는 데 유용합니다.\n* **맞춤형 금융 상품 추천:** 고객의 금융 상황 및 목표에 맞는 상품을 추천하기 위해 RAG를 활용합니다.\n* **챗봇 및 가상 상담:** 금융 상품 관련 질문에 대한 챗봇을 구축하고, 고객 상담을 지원합니다.\n\n**3. 시장 분석 및 예측:**\n\n* **시장 동향 분석:** 뉴스 기사, 보고서, 소셜 미디어 데이터를 분석하여 시장 동향을 파악하고, 투자 전략에 활용합니다.\n* **주가 예측:** 과거 주가 데이터, 경제 지표, 뉴스 등을 기반으로 주가 예측 모델을 구축하고, 예측 결과를 제공합니다.\n* **위험 관리:** 금융 시장의 위험 요인을 분석하고, 위험 관리 전략을 제안합니다.\n\n**4. 내부 문서 및 지식 관리:**\n\n* **법률 및 규정 검토:** 금융 관련 법률 및 규정을 검토하고, 중요한 내용을 요약하여 제공합니다.\n* **보고서 생성:** 내부 보고서 작성에 필요한 정보를 추출하고, 보고서 초안을 생성합니다.\n* **지식 관리:** 금융 기관의 지식 기반을 구축하고, 직원들이 필요한 정보를 쉽게 찾을 수 있도록 지원합니다.\n\n**5. 특정 금융 상품 (예: 부동산, 주식, 보험):**\n\n* **부동산 가격 예측:** 부동산 시장 데이터를 분석하여 부동산 가격 예측 모델을 구축합니다.\n* **주식 시장 분석:** 주식 시장 데이터를 분석하여 투자 전략을 제안합니다.\n* **보험 상품 비교:** 다양한 보험 상품을 비교 분석하여 고객에게 최적의 보험 상품을 추천합니다.\n\n**구체적인 예시:**\n\n* **챗봇:** \"최근 금리 인상에 따른 주식 투자 전략은 무엇인가요?\"\n* **보고서 생성:** \"2023년 Q3 매출 실적 분석 보고서\"\n* **규제 준수:** \"신용카드 사용자의 개인 정보 보호 규정 준수 여부 확인\"\n\n**결론적으로, 금융 도메인에서 RAG는 데이터 검색, 요약, 분석, 생성 등 다양한 작업을 자동화하고 효율성을 높이는 데 중요한 역할을 합니다. 특히, 규제 준수, 고객 서비스, 시장 분석 등 핵심적인 업무를 지원하여 금융 기관의 경쟁력 강화에 기여합니다.**\n\n더 자세한 정보가 필요하시면, 특정 금융 도메인이나 RAG 활용 사례를 언급해주시면 더욱 구체적인 답변을 드릴 수 있습니다.",
          "38": "의료 도메인에서 Query Expansion은 다음과 같은 중요한 이유로 필요합니다.\n\n**1. 복잡한 질의 이해 및 정확한 정보 추출:**\n\n* **의료 용어의 다양성:** 의료 분야는 전문 용어가 매우 다양하고, 질의가 복잡할수록 의료 전문가가 이해하기 어려울 수 있습니다. Query Expansion은 의료 용어의 의미를 파악하고, 질의의 의도를 정확하게 반영하여 검색 결과의 정확도를 높입니다.\n* **의료 지식의 복잡성:** 의료 지식은 매우 방대하고, 특정 질병이나 증상에 대한 정보가 복잡하게 얽혀 있습니다. Query Expansion은 질의의 맥락을 이해하고, 관련 지식을 추출하여 검색 결과의 깊이를 더합니다.\n* **의료 데이터의 불완전성:** 의료 데이터는 완벽하지 않으며, 때로는 오류나 누락된 정보가 포함될 수 있습니다. Query Expansion은 이러한 불완전한 데이터를 보완하고, 보다 완전한 정보를 제공합니다.\n\n**2. 맞춤형 의료 추천 및 진단:**\n\n* **환자 특성 반영:** 환자의 병력, 유전적 요인, 생활 습관 등 개인적인 특성을 고려하여 맞춤형 의료 정보를 제공해야 합니다. Query Expansion은 환자 데이터를 분석하여 환자에게 가장 적합한 정보를 추천하고, 진단의 정확도를 높입니다.\n* **병리적 질환 예측:** 특정 질병의 발생 가능성을 예측하기 위해서는 환자의 병력, 유전적 요인, 생활 습관 등 다양한 데이터를 분석해야 합니다. Query Expansion은 이러한 데이터를 통합하여 예측 모델을 구축하고, 정확한 예측을 가능하게 합니다.\n* **치료법 선택 지원:** 환자의 상태와 질병에 따라 최적의 치료법을 선택하기 위해서는 다양한 치료법의 효과, 부작용, 비용 등을 고려해야 합니다. Query Expansion은 환자의 상태를 분석하고, 최적의 치료법을 추천합니다.\n\n**3. 검색 정확도 향상:**\n\n* **의료 논문 및 데이터 검색:** 의료 분야는 방대한 양의 논문, 연구 데이터, 환자 기록 등을 포함하고 있습니다. Query Expansion은 검색어의 의미를 확장하고, 관련 정보를 더 효과적으로 추출하여 검색 정확도를 높입니다.\n* **검색 결과의 맥락 이해:** Query Expansion은 검색 결과의 문맥을 이해하고, 관련 정보를 더 잘 파악합니다. 이를 통해 검색 결과의 신뢰성을 높이고, 전문가의 판단을 돕습니다.\n\n**요약하자면, Query Expansion은 의료 데이터의 복잡성을 해소하고, 정확한 정보 추출 및 맞춤형 의료 추천을 가능하게 하여 의료 전문가의 업무 효율성을 높이고, 환자에게 최적의 의료 서비스를 제공하는 데 필수적인 과정입니다.**\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "39": "법률 도메인에서 Judge 모듈은 다음과 같은 핵심적인 역할을 수행합니다. Judge 모듈은 법률 질의를 평가하여 적절한 검색 방식 결정, 법률 해석 제공, 그리고 최종적으로 법률 관련 정보를 제공하는 핵심적인 역할을 합니다. 좀 더 자세히 설명하면 다음과 같습니다.\n\n**1. 법률 질의 평가 및 검색 방식 결정:**\n\n*   **법률 질의 분석:** 사용자의 질문을 분석하여 법률적 용어, 핵심 개념, 관련 법 조항 등을 파악합니다.\n*   **질의 유형 분류:** 질문의 유형(예: 계약, 형사, 민사 등)을 분류하여 검색 방향을 설정합니다.\n*   **적절한 검색 방식 선택:** 질문의 유형과 내용에 따라 가장 적합한 검색 방식을 선택합니다. 예를 들어, 계약 관련 질문에는 계약 조항 검색, 형사 관련 질문에는 법률 조항 검색 등을 수행합니다.\n\n**2. 법률 해석 제공:**\n\n*   **정보 추출 및 분석:** 검색된 법률 자료(판례, 법 조항, 계약서 등)에서 핵심 정보를 추출하고 분석합니다.\n*   **법률 해석 제시:** 추출된 정보를 바탕으로 법률 해석을 제공합니다. 단순히 정보를 제공하는 것을 넘어, 법률적 의미를 해석하고, 상황에 따른 법률적 판단을 제시합니다.\n\n**3. 최종 정보 제공:**\n\n*   **결론 및 추천:** 법률 해석 결과를 바탕으로 최종적인 결론을 도출하고, 사용자에게 필요한 법률 정보를 제공합니다.\n*   **추가 검색 제안:** 필요에 따라 추가적인 법률 자료를 추천하거나, 관련 법률 정보를 제공합니다.\n\n**4.  검색 결과의 신뢰성 평가 및 필터링:**\n\n*   **불필요한 정보 제거:** 검색된 법률 자료의 신뢰성을 평가하고, 불필요하거나 관련 없는 정보를 필터링하여 검색 결과의 정확성을 높입니다.\n*   **정보 검증:**  검색된 정보의 정확성을 검증하고, 오류 가능성을 줄입니다.\n\n**요약:** Judge 모듈은 법률 질의를 분석하고, 법률적 의미를 해석하여 사용자에게 필요한 정보를 제공하는 핵심적인 역할을 수행합니다.  이를 통해 법률 전문가의 도움 없이도 법률 관련 정보를 쉽게 얻을 수 있도록 돕는 역할을 합니다.\n\n**핵심적으로, Judge 모듈은 단순히 정보를 검색하는 것을 넘어, 법률적 판단을 내리고, 법률적 문제를 해결하는 데 필요한 핵심적인 역할을 수행합니다.**\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "40": "전자상거래 도메인에서 RRR 패턴 기반의 AI 개인화 추천 시스템의 구성 단계는 다음과 같습니다.\n\n1.  **Rewrite (재작성):**\n    *   **목표:** 사용자 질의를 분석하여, 사용자가 실제로 원하는 정보를 추출하기 쉽도록 질문의 표현을 변경합니다.\n    *   **방법:** 사용자 질의를 분석하여, 사용자의 의도를 파악하고, 질문의 문맥을 이해합니다.\n    *   **예시:** \"최근 테슬라 주가에 대해 알려줘\" 라는 질문을 \"테슬라 주가 변동 추이, 최근 주가 변화, 주가 예측\" 와 같이 변환합니다.\n\n2.  **Retrieve (검색):**\n    *   **목표:** 사용자 질의에 대한 관련 정보를 검색합니다.\n    *   **방법:** 검색 엔진 (BM25, 임베딩 기반 검색 등)을 활용하여, 사용자 질의와 관련된 데이터를 검색합니다.\n    *   **데이터 소스:**\n        *   **전자상거래 데이터:** 상품 정보, 사용자 구매 내역, 장바구니 정보, 리뷰, 상품 카테고리 등\n        *   **외부 데이터:** 뉴스, 경제 지표, 소셜 미디어 데이터 등\n\n3.  **Read (읽기):**\n    *   **목표:** 검색된 데이터를 분석하여, 사용자에게 가장 관련성 높은 정보를 제공합니다.\n    *   **방법:**\n        *   **개별 상품 정보 분석:** 상품의 특징, 가격, 리뷰, 판매량 등\n        *   **사용자 행동 분석:** 구매 패턴, 검색 기록, 클릭 기록 등\n        *   **머신러닝 모델 활용:** 사용자 선호도 예측, 상품 추천 등\n\n4.  **Re-rank (재순위화):**\n    *   **목표:** 검색된 데이터를 기반으로, 추천 결과의 순위를 조정합니다.\n    *   **방법:**\n        *   **신뢰도 기반 순위:** 각 데이터 출처의 신뢰도를 평가하여, 신뢰도가 높은 데이터에 높은 순위를 부여합니다.\n        *   **관련성 기반 순위:** 사용자 질의와 데이터 간의 관련성을 평가하여, 관련성이 높은 데이터에 높은 순위를 부여합니다.\n        *   **강화 학습:** 사용자 피드백을 활용하여, 추천 결과의 품질을 지속적으로 개선합니다.\n\n**핵심:** RRR 패턴은 단순히 정보를 검색하는 것을 넘어, 사용자의 의도를 파악하고, 그 의도에 맞는 정보를 제공하는 데 초점을 맞춥니다.\n\n이러한 단계들을 통해, RRR 패턴은 사용자에게 개인화된 추천을 제공하고, 전자상거래 시스템의 효율성을 높이는 데 기여합니다.",
          "41": "GraphRAG에서 '구성기(Organizer)'는 다음과 같은 중요한 역할을 수행합니다.\n\n**1. 데이터 정제 및 불필요한 정보 제거:**\n\n*   **노이즈 제거:** GraphRAG는 쿼리 프로세서에서 쿼리를 처리하는 과정에서 엉뚱한 정보나 불필요한 데이터를 제거합니다. 구성기는 이 과정을 자동화하고, 쿼리에서 불필요한 정보나 오류를 제거하여 검색 정확도를 높입니다.\n*   **정보 과도기 제거:** 쿼리에서 불필요한 정보나 겹치는 정보를 제거하여 쿼리 프로세서가 더 중요한 정보에 집중할 수 있도록 합니다.\n\n**2. 그래프 구조의 보강 및 개선:**\n\n*   **그래프 구조의 질감 개선:** 구성기는 그래프 구조를 보강하여 데이터의 관계성을 더욱 명확하게 드러냅니다. 이를 통해 그래프 기반 추론 및 장기 계획에 필요한 정보를 효과적으로 활용할 수 있도록 합니다.\n*   **데이터 품질 향상:** 그래프 구조를 기반으로 데이터의 품질을 개선하고, 오류를 줄여 데이터의 신뢰성을 높입니다.\n\n**3. 모델 학습 및 최적화:**\n\n*   **모델 학습의 효율성 증대:** 구성기는 모델 학습 과정에서 노이즈를 줄이고, 데이터 분석 및 최적화를 통해 모델의 성능을 향상시킵니다.\n*   **추론 성능 향상:** 그래프 구조를 활용하여 모델의 추론 성능을 향상시키고, 더 정확한 결과를 얻도록 돕습니다.\n\n**4.  다양한 데이터 형식 처리 및 통합:**\n\n*   **데이터 형식 변환:** GraphRAG는 다양한 데이터 형식(텍스트, 이미지, 그래프 등)을 처리하고, 그래프 구조로 변환하여 통합합니다.\n*   **데이터 통합:**  다양한 데이터 소스를 연결하여 그래프 구조를 구축하고, 이를 통해 데이터의 관계성을 활용하여 검색 정확도를 높입니다.\n\n**요약하자면, 구성기는 GraphRAG의 효율성을 높이고, 데이터의 품질을 개선하며, 모델 학습 및 최적화를 돕는 핵심적인 역할을 수행합니다.**\n\n더 자세한 내용은 GraphRAG 공식 문서 및 관련 자료를 참고하시면 좋습니다.",
          "42": "GraphRAG의 '생성기(Generator)'는 쿼리 프로세서의 결과를 바탕으로 답변을 생성하는 핵심적인 역할을 합니다. 생성기의 주요 기능은 다음과 같습니다.\n\n1.  **답변 생성:** 쿼리 프로세서가 제공한 정보를 바탕으로, 답변을 생성합니다. 쿼리 프로세서가 제공한 내용을 분석하고, 이를 바탕으로 문장 구조를 만들고, 내용을 구성합니다.\n\n2.  **문맥 생성:** 답변을 생성하기 위해, 쿼리 프로세서에서 얻은 정보를 바탕으로 문맥을 생성합니다. 즉, 답변을 생성하기 위한 배경 지식이나 관련 정보를 제공합니다.\n\n3.  **답변 형식화:** 생성된 답변을 텍스트 형태로 구성합니다. 답변의 흐름을 자연스럽게 만들고, 독자의 이해를 돕도록 합니다.\n\n4.  **추가 정보 활용:** 쿼리 프로세서에서 제공한 정보를 활용하여 답변의 정확성과 깊이를 더합니다. 예를 들어, 특정 사실에 대한 추가적인 설명을 제공하거나, 관련 예시를 제시할 수 있습니다.\n\n5.  **다양한 형식 변환:** 텍스트, 이미지, 코드 등 다양한 형식의 정보를 활용하여 답변을 생성합니다.\n\n6.  **최적화:** 생성된 답변의 품질을 높이기 위해, 다양한 최적화 기법을 적용합니다. 예를 들어, 문법 오류를 수정하거나, 문장 구조를 개선합니다.\n\n**요약하자면, 생성기는 쿼리 프로세서에서 얻은 정보를 바탕으로, 사용자에게 유용한 답변을 생성하는 핵심적인 역할을 수행합니다.**\n\n더 자세한 내용은 GraphRAG 공식 문서 및 관련 자료를 참고하시면 좋습니다.",
          "43": "GraphRAG의 데이터 소스 예시는 매우 다양하며, 각 데이터 소스는 특정 목적과 활용 분야에 맞춰 설계되었습니다. 아래는 GraphRAG의 데이터 소스 예시 세 가지를 제시합니다.\n\n**1. 지식 그래프 (Knowledge Graph)**\n\n*   **설명:** 지식 그래프는 개체(Entity), 속성(Attribute), 관계(Relationship)를 연결하여 지식을 표현하는 데이터 구조입니다. GraphRAG는 지식 그래프를 핵심 데이터 소스로 활용하여, 지식 기반 질문에 대한 답변을 제공하는 데 핵심적인 역할을 합니다.\n*   **예시:**\n    *   **Wikipedia:** Wikipedia는 다양한 주제에 대한 지식을 체계적으로 담고 있으며, GraphRAG는 Wikipedia의 내용을 기반으로 질문에 대한 답변을 생성하는 데 활용될 수 있습니다.\n    *   **DBpedia:** DBpedia는 Wikipedia의 내용을 기반으로 구축된 지식 그래프로, 다양한 지식 분야에 대한 정보를 제공합니다.\n    *   **Google Knowledge Graph:** Google의 지식 그래프는 다양한 주제에 대한 정보를 제공하며, GraphRAG는 이를 활용하여 사용자에게 관련 정보를 제공합니다.\n*   **활용:** 질문 답변, 정보 검색, 지식 기반 추천 등 다양한 분야에 활용 가능합니다.\n\n**2. 문서 그래프 (Document Graph)**\n\n*   **설명:** 문서 그래프는 문서(Document)를 개체(Entity)와 관계(Relationship)로 표현하는 데이터 구조입니다. GraphRAG는 문서 그래프를 활용하여, 문서 간의 관계를 분석하고, 문서의 내용을 기반으로 질문에 대한 답변을 생성하는 데 활용됩니다.\n*   **예시:**\n    *   **뉴스 기사:** 뉴스 기사에는 사건, 인물, 관계 등 다양한 개체와 관계가 포함되어 있습니다. GraphRAG는 뉴스 기사를 분석하여, 특정 사건과 관련된 다른 사건, 인물, 관계 등을 찾아낼 수 있습니다.\n    *   **법률 문서:** 법률 문서에는 계약, 판결, 법률 조항 등 다양한 개체와 관계가 포함되어 있습니다. GraphRAG는 법률 문서를 분석하여, 특정 조항의 의미를 파악하고, 관련 법률 조항을 찾아낼 수 있습니다.\n    *   **연구 논문:** 연구 논문에는 연구 주제, 방법, 결과 등 다양한 개체와 관계가 포함되어 있습니다. GraphRAG는 연구 논문을 분석하여, 연구 주제와 관련된 다른 연구, 방법, 결과 등을 찾아낼 수 있습니다.\n*   **활용:** 문서 분석, 정보 추출, 문서 분류, 문서 요약 등 다양한 분야에 활용 가능합니다.\n\n**3. 분자 그래프 (Molecular Graph)**\n\n*   **설명:** 분자 그래프는 분자(Molecule)를 개체(Entity)로 표현하는 데이터 구조입니다. GraphRAG는 분자 그래프를 활용하여, 분자 간의 관계를 분석하고, 분자의 특성을 파악하는 데 활용됩니다.\n*   **예시:**\n    *   **약물 개발:** 약물 개발 과정에서 분자 간의 상호 작용을 분석하고, 새로운 분자를 설계하는 데 활용될 수 있습니다.\n    *   **생물학 연구:** 생물학 연구에서 분자 간의 관계를 분석하고, 생명 현상을 이해하는 데 활용될 수 있습니다.\n    *   **신약 개발:** 신약 개발 과정에서 분자 간의 상호 작용을 분석하고, 새로운 약물을 개발하는 데 활용될 수 있습니다.\n*   **활용:** 분자 분석, 약물 개발, 생물학 연구, 신약 개발 등 다양한 분야에 활용 가능합니다.\n\n**4. 장면 그래프 (Scene Graph)**\n\n*   **설명:** 장면 그래프는 장면(Scene)을 개체(Entity)로 표현하는 데이터 구조입니다. GraphRAG는 장면 그래프를 활용하여, 장면의 내용을 분석하고, 장면 간의 관계를 파악하는 데 활용됩니다.\n*   **예시:**\n    *   **실제 장면:** 실제 장면은 다양한 개체와 관계를 포함합니다. GraphRAG는 장면을 분석하여, 장면의 특징을 파악하고, 장면 간의 관계를 파악할 수 있습니다.\n    *   **게임:** 게임은 장면을 구성하는 개체와 관계를 포함합니다. GraphRAG는 게임을 분석하여, 게임의 특징을 파악하고, 게임의 흐름을 이해하는 데 활용될 수 있습니다.\n*   **활용:** 장면 분석, 장면 기반 검색, 장면 기반 추천 등 다양한 분야에 활용 가능합니다.\n\n이 외에도 다양한 데이터 소스를 활용하여 GraphRAG의 성능을 향상시킬 수 있습니다. 각 데이터 소스의 특징과 활용 방안을 고려하여, GraphRAG의 활용 범위를 넓힐 수 있습니다.",
          "44": "Modular RAG에서 'Scheduling' Operator는 **전체 워크플로우의 실행 순서를 정의하고 관리하는 핵심적인 역할을 수행합니다.** 좀 더 자세히 설명하면 다음과 같습니다.\n\n**Scheduling Operator의 역할:**\n\n* **동적 워크플로우 관리:** 'Scheduling' Operator는 시스템의 워크플로우를 동적으로 조정하고 관리합니다. 단순히 작업을 순차적으로 수행하는 것이 아니라, 상황에 따라 작업의 우선순위를 변경하거나, 작업 간의 의존성을 고려하여 실행 순서를 결정합니다.\n* **실제 실행 순서 결정:**  'Scheduling' Operator는 LLM이 생성한 결과물(예: 답변, 문서)을 생성하기 위한 단계별 실행 순서를 결정합니다. 예를 들어, LLM이 생성한 답변을 생성하기 전에 먼저 검색을 수행하거나, 특정 데이터 필터링을 수행하는 등의 작업을 포함할 수 있습니다.\n* **실시간 의사결정:**  'Scheduling' Operator는 실시간으로 상황을 분석하고, 워크플로우의 진행 상황을 모니터링하며, 필요한 경우 실행 순서를 변경합니다.  예를 들어, LLM이 생성한 답변의 품질이 낮다고 판단되면, 해당 단계의 실행 순서를 변경하여 더 나은 답변을 생성하도록 유도할 수 있습니다.\n* **다중 작업의 병렬 실행:**  'Scheduling' Operator는 여러 작업을 동시에 실행할 수 있도록 지원합니다. 이를 통해 시스템의 처리 효율성을 높이고, 사용자에게 더 빠른 응답을 제공할 수 있습니다.\n* **자율적인 워크플로우 조정:**  'Scheduling' Operator는 시스템의 목표를 달성하기 위해 워크플로우를 자동으로 조정합니다.  예를 들어, 특정 작업이 완료될 때까지 기다리거나, 특정 조건이 충족될 때까지 작업을 계속 진행하는 등의 역할을 수행합니다.\n\n**간단한 예시:**\n\nLLM이 답변을 생성하는 과정에서, 'Scheduling' Operator는 다음과 같은 작업을 수행할 수 있습니다.\n\n1.  **검색:**  질문과 관련된 정보를 검색합니다.\n2.  **데이터 필터링:**  검색 결과에서 관련 없는 정보를 제거합니다.\n3.  **질의 확장:**  질문을 더 명확하게 만들기 위해 질문을 확장합니다.\n4.  **생성:**  필요한 정보를 바탕으로 답변을 생성합니다.\n5.  **평가:**  생성된 답변의 품질을 평가합니다.\n\n이러한 과정을 반복하면서, 'Scheduling' Operator는 워크플로우를 최적화하고, 사용자에게 더 나은 답변을 제공합니다.\n\n요약하자면, 'Scheduling' Operator는 Modular RAG 시스템의 전체적인 효율성과 유연성을 높이는 핵심적인 역할을 수행합니다.\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "45": "Modular RAG에서 'Fusion' Operator는 LLM Fusion을 통해 LLM의 출력을 정제하고, 다양한 출력을 융합하여 최종적인 응답을 생성하는 핵심적인 역할을 합니다. 좀 더 자세히 설명하면 다음과 같습니다.\n\n**Fusion Operator의 역할:**\n\n* **출력 정제 및 융합:** Fusion Operator는 LLM이 생성한 응답의 품질을 향상시키기 위해 다양한 출력을 융합합니다. 단순히 응답을 덧붙이는 것이 아니라, LLM의 답변을 개선하고, 오류를 수정하며, 더 유익한 정보를 제공합니다.\n* **다양한 출력 융합:** Fusion Operator는 LLM이 생성한 다양한 출력을 융합하여 최종적인 응답을 생성합니다. 예를 들어, LLM이 생성한 여러 답변을 비교하고, 가장 적절한 답변을 선택하거나, 두 답변의 장점을 결합하여 새로운 답변을 생성할 수 있습니다.\n* **개선 및 조정:** Fusion Operator는 LLM의 답변을 개선하고, 특정 요구 사항에 맞게 조정합니다. 이를 통해 응답의 정확성, 유용성, 관련성을 높입니다.\n* **추가 정보 제공:** Fusion Operator는 LLM의 답변에 추가적인 정보를 제공하여 사용자의 이해를 돕습니다.\n\n**Fusion Operator의 작동 방식:**\n\nFusion Operator는 다양한 융합 기법을 활용합니다. 주요 융합 기법으로는 다음과 같은 것들이 있습니다.\n\n* **Weighted Ensemble:** 여러 LLM의 출력을 가중치로 사용하여 최종 답변을 생성합니다.\n* **RRF (Reciprocal Rank Fusion):** LLM의 출력을 비교하여 가장 높은 순위를 갖는 출력을 선택합니다.\n* **Fusion & Re-rank:** LLM의 답변을 정렬하고, 가장 적절한 답변을 선택합니다.\n\n**핵심 요약:** Fusion Operator는 LLM의 답변을 개선하고, 다양한 정보를 융합하여 최종적인 응답을 생성하는 중요한 역할을 수행합니다. 이를 통해 LLM의 성능을 향상시키고, 사용자에게 더 유익한 정보를 제공합니다.\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "46": "Advanced RAG의 쿼리 재작성에 사용되는 기법 'HyDE'는 **Hybrid-Enhanced Decoding**의 약자입니다.",
          "47": "RAG에서 'BM25'는 **검색 품질을 평가하고 순위를 매기는 데 사용되는 알고리즘**입니다. 좀 더 자세히 설명하면 다음과 같습니다.\n\n**BM25 (Best Matching 25)**는 텍스트 데이터의 유사성을 측정하는 알고리즘으로, 다음과 같은 특징을 가지고 있습니다.\n\n1.  **단어 빈도 계산:** 텍스트 데이터에서 각 단어의 빈도를 계산합니다.\n2.  **유사도 점수 계산:** 계산된 단어 빈도를 기반으로 텍스트 데이터와 유사한 텍스트의 빈도를 계산합니다.\n3.  **최적의 유사도 점수 계산:** 계산된 유사도 점수를 기반으로 가장 유사한 텍스트를 찾습니다.\n4.  **순위 결정:** 가장 유사한 텍스트를 선택하여 순위를 매깁니다.\n\n**BM25는 다음과 같은 장점을 가지고 있습니다.**\n\n*   **정확성:** 텍스트의 의미를 고려하여 순위를 매기므로, 텍스트의 의미를 정확하게 반영하는 순위를 제공합니다.\n*   **효율성:** 텍스트의 길이와 단어 빈도에 따라 순위를 매기므로, 텍스트의 길이와 단어 빈도에 따라 순위를 매기는 다른 알고리즘보다 효율적입니다.\n*   **간단함:** 구현이 비교적 간단하여 쉽게 적용할 수 있습니다.\n\n**RAG 시스템에서 BM25는 주로 다음과 같은 용도로 사용됩니다.**\n\n*   **검색 결과 순위 결정:** 검색된 문서의 순위를 결정하는 데 사용됩니다.\n*   **검색 품질 평가:** 검색 결과의 품질을 평가하는 데 사용됩니다.\n*   **검색 결과 필터링:** 검색 결과의 품질을 높이기 위해 필터링에 사용될 수 있습니다.\n\n**결론적으로, BM25는 RAG 시스템에서 텍스트 데이터의 검색 품질을 평가하고 순위를 매기는 데 사용되는 중요한 검색 알고리즘입니다.**\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "48": "Modular RAG의 'Componentized Architecture'의 가장 큰 장점 중 하나는 **유연성 및 확장성**입니다.\n\n**이유:**\n\n*   **모듈화된 구조:** 각 기능(검색, 랭킹, 필터링, 생성 등)을 독립적인 모듈로 분리함으로써, 시스템을 수정하거나 새로운 기능을 추가하는 것이 훨씬 용이합니다.\n*   **업그레이드 및 교체 용이:** 특정 모듈을 업그레이드하거나 교체할 필요 없이, 전체 시스템을 재구축하지 않고도 새로운 기능을 추가하거나 기존 기능을 개선할 수 있습니다.\n*   **다양한 도메인 적용:** 각 모듈을 다른 도메인에 적용하거나, 특정 도메인에 특화된 모듈을 추가하여 시스템을 확장할 수 있습니다.\n*   **유지보수 용이:** 모듈별로 유지보수가 가능하여, 시스템의 안정성을 높이고 유지보수를 용이하게 합니다.\n\n이러한 유연성은 Modular RAG를 다양한 요구사항에 맞춰 쉽게 조정하고 발전시킬 수 있도록 해줍니다.",
          "49": "LinkedIn GraphRAG에서 검색 시 사용하는 거리 측정 방법은 다음과 같습니다.\n\n**1. Cosine Similarity (코사인 유사도):**\n\n*   **주요 방법:** GraphRAG는 주로 Cosine Similarity를 사용하여 문서 간의 유사성을 측정합니다. 이는 텍스트 임베딩(BERT, E5 등)을 사용하여 생성된 벡터를 비교하여 유사도를 계산하는 방식입니다.\n*   **원리:** Cosine Similarity는 두 벡터 간의 각도를 계산하고, 이 각도를 이용하여 유사도를 측정합니다.  두 벡터가 서로 가까울수록 유사도가 높습니다.\n*   **활용:**  이 방법은 텍스트 기반 정보의 유사성을 평가하는 데 효과적입니다.\n\n**2.  Distance-Based Metrics (거리 기반 지표):**\n\n*   **Anchor-Based Distance:**  GraphRAG는 문서의 'Anchor' (핵심 정보)를 기반으로, Anchor의 유사도를 측정하여 검색 정확도를 높입니다.\n*   **Jaccard Index (자카드 지수):**  문서 간의 단어의 차이를 기반으로 유사도를 계산합니다.\n\n**3.  Graph-Based Distance (그래프 기반 거리):**\n\n*   **Graph Embedding Distance:** GraphRAG는 그래프 구조를 활용하여 문서 간의 관계를 파악하고, 이를 기반으로 유사도를 측정합니다.  이는 그래프의 연결성, 중심성 등을 고려하여 유사도를 평가합니다.\n\n**4.  Hybrid Approaches (혼합 방법):**\n\n*   LinkedIn은 여러 거리 측정 방법을 결합하여 사용합니다. 예를 들어, Cosine Similarity를 사용하여 초기 유사도를 측정하고, 이후 Graph-Based Distance를 사용하여 더 정확한 결과를 얻습니다.\n\n**중요 사항:**\n\n*   LinkedIn은 GraphRAG의 성능을 향상시키기 위해 다양한 거리 측정 방법을 실험하고 최적화하고 있습니다.\n*   최신 연구 결과에 따르면, Cosine Similarity가 여전히 중요한 역할을 하지만, Graph-Based Distance와 Hybrid Approaches를 통해 더욱 정확한 검색 결과를 얻고 있습니다.\n\n**참고 자료:**\n\n*   LinkedIn's GraphRAG: [https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3](https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3)\n*   GraphRAG: [https://arxiv.org/pdf/2404.17723](https://arxiv.org/pdf/2404.17723)\n\n이 외에도 LinkedIn은 RAG 시스템의 성능을 개선하기 위해 지속적으로 연구를 진행하고 있으며, 새로운 거리 측정 방법을 도입하고 있습니다."
        },
        "reference": {
          "0": "Retrieval-Augmented Generation",
          "1": "색인(Indexing), 검색(Retrieval), 생성(Generation)",
          "2": "색인, 검색, 생성",
          "3": "문서를 청크로 분할 후 임베딩으로 벡터 변환하여 저장하고, 쿼리를 임베딩하여 유사한 청크를 검색 후 LLM에 입력하여 응답 생성",
          "4": "얕은 질의 이해",
          "5": "쿼리 재작성(Query Rewriting), 쿼리 확장(Query Expansion)",
          "6": "재정렬(Re-ranking), 압축(Compression)",
          "7": "독립적인 모듈과 특수 연산자로 구성된 유연하고 확장 가능한 프레임워크",
          "8": "모듈(Module), 하위 모듈(Submodule), 연산자(Operator)",
          "9": "Module: RAG 핵심 단계를 처리; Submodule: 모듈 내 세부 기능; Operator: 특정 기능 구현 단위",
          "10": "라우팅, 스케줄링, 융합 등을 통해 워크플로우 제어",
          "11": "조건부 패턴, 분기 패턴, 루프 패턴",
          "12": "BM25와 벡터 검색",
          "13": "Query Expansion, Query Transformation",
          "14": "Retriever Selection",
          "15": "Rerank, Compression",
          "16": "Generator Fine-tuning, Verification",
          "17": "핵심 기능을 개별 모듈로 분리해 독립적으로 관리 가능",
          "18": "모듈 기반으로 다양한 데이터 소스를 유연하게 조합할 수 있기 때문",
          "19": "조건부 라우팅, 병렬 처리, 순환 흐름 등 동적 워크플로우 구성",
          "20": "쿼리 프로세서, 검색기(Retriever), 구성기(Organizer), 생성기(Generator), 그래프 데이터 소스",
          "21": "관계형 지식 활용을 통한 다단계 추론 및 장기 계획 지원",
          "22": "고객 서비스 이슈 티켓 간 관계 보존으로 검색 정확도 향상",
          "23": "28.6%",
          "24": "간단한 FAQ, 문서 검색",
          "25": "법률, 금융, 의료",
          "26": "복잡한 도메인 지식이 필요한 분야",
          "27": "Naive RAG → Advanced RAG → Modular RAG",
          "28": "LLM이 사실 근거 없이 잘못된 정보를 생성하는 현상",
          "29": "반복, 재귀, 적응형 검색을 통한 상호 의존적 처리",
          "30": "다양한 조건에 따른 파이프라인 선택",
          "31": "병렬 실행을 통해 결과 다양성 증가",
          "32": "검색기와 생성기의 미세 조정을 통해 시스템 성능 최적화",
          "33": "검색된 문서 출처를 명시하는 'Citation' 기능",
          "34": "여러 개의 검색된 문서를 정리하여 최종 후보 선정",
          "35": "검색된 문서에서 핵심 내용 요약",
          "36": "자연스럽고 다양한 표현으로 변환",
          "37": "Text-to-SQL, Sentiment Analysis, Weighted Fusion",
          "38": "다양한 증상 표현을 포괄하여 검색 정확도 향상",
          "39": "질문 유형에 따라 적절한 검색 방식을 결정",
          "40": "Rewrite → Retrieve → Read",
          "41": "그래프 가지치기 및 외부 지식 보강",
          "42": "그래프 정보를 LLM에 공급하여 응답 생성",
          "43": "지식 그래프, 문서 그래프, 과학 그래프",
          "44": "Rule-based 또는 LLM 기반 의사결정 수행",
          "45": "LLM Fusion, Weighted Ensemble, RRF 등을 통해 결과 융합",
          "46": "Hypothetical Document Embeddings",
          "47": "Sparse Retrieval",
          "48": "유지보수가 용이",
          "49": "코사인 유사도"
        },
        "answer_relevancy": {
          "0": 0.8540297340621642,
          "1": 0.8902456444947565,
          "2": 0.8933957235482873,
          "3": 0.9610443547220114,
          "4": 0.9840214301823673,
          "5": 0.8892195655849382,
          "6": 0.8983444505553684,
          "7": 0.893030819932234,
          "8": 0.8547980856654677,
          "9": 0.8705682131282343,
          "10": 0.8674816283085031,
          "11": 0.8955305867210691,
          "12": 0.9144739150185149,
          "13": 0.9074338633482545,
          "14": 0.755675196173983,
          "15": 0.9045758977281522,
          "16": 0.8565122593987352,
          "17": 0.8799175084655048,
          "18": 0.8863783995516515,
          "19": 0.8063123076719729,
          "20": 0.8812839671246112,
          "21": 0.9030955650713891,
          "22": 0.8758583551401928,
          "23": 0.8033479935893647,
          "24": 0.8897007068055108,
          "25": 0.8989654308009066,
          "26": 0.8795826070075661,
          "27": 0.8557364045772257,
          "28": 0.8550804842187091,
          "29": 0.8784799838263707,
          "30": 0.8023874187073271,
          "31": 0.7924748328116671,
          "32": 0.8516222823637225,
          "33": 0.8718830910334581,
          "34": 0.9065668431245194,
          "35": 0.920789980899826,
          "36": 0.9049669534020377,
          "37": 0.0,
          "38": 0.8919664522018088,
          "39": 0.8728840128633634,
          "40": 0.8243078701936262,
          "41": 0.8860102657294885,
          "42": 0.8675548559944163,
          "43": 0.865964357730601,
          "44": 0.9259910756102187,
          "45": 0.9206440204234495,
          "46": 0.8687082023104291,
          "47": 0.877188713496487,
          "48": 0.9101778224924234,
          "49": 0.8844217678545615
        },
        "faithfulness": {
          "0": 1.0,
          "1": 0.8333333333333334,
          "2": 0.3888888888888889,
          "3": 0.7777777777777778,
          "4": 1.0,
          "5": 0.375,
          "6": 0.5789473684210527,
          "7": 0.92,
          "8": 1.0,
          "9": 1.0,
          "10": 0.2916666666666667,
          "11": 0.6363636363636364,
          "12": 0.8095238095238095,
          "13": 0.6875,
          "14": 0.8,
          "15": 0.8,
          "16": 0.0,
          "17": 1.0,
          "18": 0.9310344827586207,
          "19": 0.72,
          "20": 1.0,
          "21": 0.9743589743589743,
          "22": 1.0,
          "23": 1.0,
          "24": 0.4,
          "25": 0.7647058823529411,
          "26": 0.8723404255319149,
          "27": 0.7222222222222222,
          "28": 0.7,
          "29": 0.1794871794871795,
          "30": 0.8214285714285714,
          "31": 0.058823529411764705,
          "32": 0.5,
          "33": 0.0,
          "34": 0.0,
          "35": 0.0,
          "36": 0.38461538461538464,
          "37": 0.8,
          "38": 0.3076923076923077,
          "39": 0.625,
          "40": 1.0,
          "41": 0.4230769230769231,
          "42": 0.23809523809523808,
          "43": 0.8444444444444444,
          "44": 0.8518518518518519,
          "45": 0.5294117647058824,
          "46": 0.0,
          "47": 0.5,
          "48": 1.0,
          "49": 0.42105263157894735
        },
        "context_recall": {
          "0": 1.0,
          "1": 1.0,
          "2": 1.0,
          "3": 1.0,
          "4": 1.0,
          "5": 1.0,
          "6": 1.0,
          "7": 1.0,
          "8": 1.0,
          "9": 1.0,
          "10": 1.0,
          "11": 0.0,
          "12": 0.0,
          "13": 1.0,
          "14": 1.0,
          "15": 1.0,
          "16": 1.0,
          "17": 1.0,
          "18": 1.0,
          "19": 1.0,
          "20": 1.0,
          "21": 1.0,
          "22": 1.0,
          "23": 1.0,
          "24": 1.0,
          "25": 1.0,
          "26": 1.0,
          "27": 1.0,
          "28": 1.0,
          "29": 1.0,
          "30": 1.0,
          "31": 0.0,
          "32": 1.0,
          "33": 1.0,
          "34": 0.0,
          "35": 1.0,
          "36": 1.0,
          "37": 0.0,
          "38": 1.0,
          "39": 1.0,
          "40": 1.0,
          "41": 1.0,
          "42": 1.0,
          "43": 1.0,
          "44": 1.0,
          "45": 1.0,
          "46": 0.0,
          "47": 0.0,
          "48": 1.0,
          "49": 1.0
        },
        "context_precision": {
          "0": 0.99999999998,
          "1": 0.8874999999778125,
          "2": 0.99999999995,
          "3": 0.8874999999778125,
          "4": 0.94999999997625,
          "5": 0.8666666666377778,
          "6": 0.8666666666377778,
          "7": 0.99999999998,
          "8": 0.9166666666361111,
          "9": 0.99999999998,
          "10": 0.99999999998,
          "11": 0.249999999975,
          "12": 0.7499999999625,
          "13": 0.8333333332916666,
          "14": 0.249999999975,
          "15": 0.99999999995,
          "16": 0.9999999999,
          "17": 0.99999999998,
          "18": 0.99999999998,
          "19": 0.8041666666465626,
          "20": 0.8874999999778125,
          "21": 0.99999999998,
          "22": 0.7555555555303703,
          "23": 0.99999999995,
          "24": 0.999999999975,
          "25": 0.8055555555287036,
          "26": 0.99999999998,
          "27": 0.99999999998,
          "28": 0.9999999999,
          "29": 0.7555555555303703,
          "30": 0.49999999995,
          "31": 0.5833333333041666,
          "32": 0.5888888888692593,
          "33": 0.8874999999778125,
          "34": 0.47777777776185176,
          "35": 0.499999999975,
          "36": 0.7499999999625,
          "37": 0.0,
          "38": 0.99999999998,
          "39": 0.9166666666361111,
          "40": 0.32499999998375,
          "41": 0.9999999999,
          "42": 0.8874999999778125,
          "43": 0.9999999999666667,
          "44": 0.5333333333155555,
          "45": 0.8333333332916666,
          "46": 0.0,
          "47": 0.3333333333,
          "48": 0.999999999975,
          "49": 0.36666666664833336
        }
      },
      "average_scores": {
        "answer_relevancy": 0.860612638033349,
        "faithfulness": 0.6293728658917668,
        "context_recall": 0.86,
        "context_precision": 0.7789999999696404
      }
    },
    "Advanced RAG": {
      "detailed_scores": {
        "user_input": {
          "0": "RAG의 약자는 무엇인가?",
          "1": "RAG의 세 가지 핵심 요소는?",
          "2": "Naive RAG의 핵심 구성 요소는 무엇인가?",
          "3": "Naive RAG의 작동 방식은?",
          "4": "Naive RAG의 한계 중 하나인 'Shallow Query Understanding'을 한국어로 무엇이라 하는가?",
          "5": "Advanced RAG에서 도입된 사전 검색 처리 기법 두 가지는?",
          "6": "Advanced RAG의 사후 검색 처리 기법 예시 두 가지는?",
          "7": "Modular RAG의 핵심 개념은?",
          "8": "Modular RAG의 3단계 구조를 쓰시오.",
          "9": "Module, Submodule, Operator 각각의 역할을 간략히 설명하시오.",
          "10": "Modular RAG의 '오케스트레이션 모듈'의 기능은?",
          "11": "Modular RAG의 동적 워크플로우 예시 패턴 세 가지는?",
          "12": "Modular RAG에서 'Hybrid Search'는 어떤 검색 기법을 결합하는가?",
          "13": "Modular RAG의 'Pre-retrieval' 모듈의 Operator 예시를 두 가지 쓰시오.",
          "14": "Retrieval 모듈의 Operator 중 하나를 쓰시오.",
          "15": "Post-Retrieval 모듈의 Operator 중 두 가지는?",
          "16": "Generation 모듈에서 사용되는 Operator 예시 두 가지는?",
          "17": "Modular RAG의 장점으로 'Componentized Architecture'가 의미하는 바는?",
          "18": "Modular RAG의 다중 데이터 소스 통합이 가능한 이유는?",
          "19": "LangGraph를 활용한 오케스트레이션이 제공하는 기능은?",
          "20": "GraphRAG의 핵심 구성 요소 다섯 가지를 쓰시오.",
          "21": "GraphRAG가 기존 RAG 대비 강화하는 주요 이점은?",
          "22": "LinkedIn이 GraphRAG를 도입한 목적은?",
          "23": "LinkedIn GraphRAG 시스템이 이슈 해결 시간을 얼마나 단축했는가?",
          "24": "Naive RAG를 적용하기 적합한 분야는?",
          "25": "Advanced RAG를 주로 활용하는 도메인은?",
          "26": "Modular RAG가 특히 강력한 성능을 발휘하는 분야는?",
          "27": "RAG의 발전 순서를 나열하시오.",
          "28": "RAG의 주요 문제점 중 하나인 'Hallucination'은 무엇을 의미하는가?",
          "29": "Modular RAG의 '루프 패턴'은 어떤 처리 방식을 말하는가?",
          "30": "조건부 패턴에서 사용되는 주요 기능은?",
          "31": "분기 패턴이 제공하는 이점은?",
          "32": "Tuning Pattern의 역할은?",
          "33": "RAG의 한계 중 '출처 불명확성'을 개선하기 위한 기법은?",
          "34": "Modular RAG에서 'Reducer' 연산자의 역할은?",
          "35": "Modular RAG의 'Summarizer' Operator는 무슨 역할을 하는가?",
          "36": "Modular RAG의 'Paraphraser' Operator 기능은?",
          "37": "금융 도메인에서 활용되는 RAG 패턴은?",
          "38": "의료 도메인에서 Query Expansion이 필요한 이유는?",
          "39": "법률 도메인에서 Judge 모듈의 역할은?",
          "40": "전자상거래 도메인에서 RRR 패턴의 구성 단계는?",
          "41": "GraphRAG에서 '구성기(Organizer)'의 역할은?",
          "42": "GraphRAG를 구성하는 '생성기(Generator)'의 주요 기능은?",
          "43": "GraphRAG의 데이터 소스 예시 세가지를 쓰시오.",
          "44": "Modular RAG에서 'Scheduling' Operator의 역할은?",
          "45": "Modular RAG에서 'Fusion' Operator는 어떤 역할을 하는가?",
          "46": "Advanced RAG의 쿼리 재작성에 사용되는 기법 'HyDE'는 무엇의 약자인가?",
          "47": "RAG에서 'BM25'는 어떤 검색 방식의 일종인가?",
          "48": "Modular RAG의 'Componentized Architecture' 장점 중 하나를 쓰시오.",
          "49": "LinkedIn GraphRAG에서는 검색 시 어떤 거리 측정 방법을 사용했는가?"
        },
        "retrieved_contexts": {
          "0": [
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다."
          ],
          "1": [
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담 \n이 표를 통해 각 RAG 방법론의 특징을 비교하고, 프로젝트 목적과 요구사항에 맞는 최적의 방식을 선택하는 데 도움이 될 수 있습니다. Modular RAG는 높은 유연성과 확장성을 제공하여, 특히 복잡한 도메인 지식이 필요한 분야에서 강력한 성능을 발휘할 수 있습니다.\n3. Modular RAG의 주요 구성 요소 Modular RAG에서 계층구조의 구성 요소와 역할과 세부 내용을 알아봅니다. Agent Workflow Module 주요 프로세스(검색, 증강, 생성 등)를 담당 Submodule 모듈 내부에서 세부적인 작업 단계를 처리 Operator 데이터 처리 및 변환과 같은 기본적인 작업 단위를 수행 \n3.1 Agent 기반의 아키텍처 Modular RAG의 핵심 요소 중 하나는 Agent 기반 아키텍처입니다. 기존 AI 에이전트와 비교했을 때, Modular RAG의 에이전트는 다중 모듈을 조율하고 특정 작업을 수행하는 방식으로 설계됩니다. 이를 통해 보다 유연하고 확장 가능한 AI 시스템을 구축할 수 있습니다. \nAI Agent 아키텍처 AI 에이전트는 특정 목표를 달성하기 위해 환경에서 데이터를 감지하고, 해석하며, 행동하는 시스템입니다. AI 에이전트 아키텍처는 인공지능 시스템이 환경을 인식하고, 분석하며, 행동하는 방식을 정의하는 구조적 설계입니다. 이는 AI 에이전트가 자율적으로 작동하고 목표를 달성할 수 있도록 하는 핵심 요소를 포함하며, 다양한 구성 요소와 설계 패턴으로 이루어집니다.",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다."
          ],
          "2": [
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다."
          ],
          "3": [
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다."
          ],
          "4": [
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "Reference ※ 각 파트별 참조한 자료가 있다면 아래 출처 작성 부탁드립니다. ※ 작성 양식 : 문서/페이지명 (링크)  1번파트 - From complex to atomic: Enhancing Augmented Generation via Knowledge-aware Dual Rewriting and Reasoning (https://openreview.net/pdf/eece737929522d36939d3b6cf5da4e8c7921f2ee.pdf) - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/html/2312.10997v5  - Context window overflow: Breaking the barrier https://aws.amazon.com/jp/blogs/security/context-window-overflow-breaking-the-barrier/  - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/html/2407.21059v1  - How does Modular RAG improve upon naive RAG? https://adasci.org/how-does-modular-rag-improve-upon-naive-rag/  - Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ],
          "5": [
            "2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다. \n주요 전략 사전 검색 처리 (Pre-retrieval processing): ● 쿼리 재작성(query rewriting): 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. ● 쿼리 확장(query expansion): 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다. ● 쿼리 변환(query transformation): 원래 쿼리 대신 변환된 쿼리를 기반으로 검색 및 생성을 수행합니다.\n사후 검색 처리 (Post-retrieval processing): ● 검색 결과 재정렬(reranking): 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다. ● 압축(compression): 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다. ● 선택(selection): 관련 없는 덩어리를 직접 제거하여 LLM의 추론 효율성을 향상시킵니다.  \n특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "• 향상된 검색 기법: 질의 처리 후 하이브리드 검색(밀도 기반 임베딩 검색 + 희소 키워드 검색)을 활용해 더 풍부한 결과를 얻습니다 ibm.com . 복잡한 질문의 경우 계층적 인덱싱이나 다단계 검색(예: iterative/recursive retrieval)으로 한층 심화된 검색을 수행하여 정확도를 높입니다 arxiv.org  arxiv.org . \n• 다중 모듈 검색: 질의 종류와 목적에 따라 여러 검색 모듈을 조합합니다. 예를 들어, 임베딩 기반 벡터 검색에 더해 지식 그래프 질의나 API 호출 등 이기종 데이터 검색을 병행할 수 있습니다. 또한 복잡한 문제에 대해 반복적 검색이나 분기 검색 흐름을 구현하여 필요한 정보를 순차적으로 수집할 수 있습니다 arxiv.org . 이러한 유연한 검색 설계로 질의의 의도에 맞게 다양한 소스에서 정보를 획득합니다. 모델 아키텍처 (Model Architecture) • 선형 파이프라인 구조: 인덱싱 → 검색 → 생성의 직렬 단계로 구성된 가장 단순한 형태입니다 arxiv.org . 별도의 최적화 모듈이나 피드백 루프 없이, 검색기와 한 번의 생성기로 답변을 생성합니다. 전체 구조가 단순하여 추가 구성요소가 없습니다. \n• 개선된 단일 흐름 구조: 기본 RAG 파이프라인에 전처리/후처리 모듈을 추가한 구조입니다. 예를 들어, 질의 재작성 모듈로 입력 질문을 명확히 하고 arxiv.org , 재검색 및 재정렬 모듈로 검색 결과를 필터링한 후 LLM에 전달합니다. 응답 생성 후에는 사용자 클릭이나 피드백 등을 활용한 피드백 루프를 도입해 검색기와 생성기를 지속적으로 개선하기도 합니다 \n• 모듈식 아키텍처: 여러 독립 모듈을 레고 블록처럼 연결하여 구성한 프레임워크입니다 arxiv.org . 질의 처리, 검색, 필터링, 생성, 검증 등의 기능이 분리된 모듈로 구현되고, 이들을 제어하는 라우팅/스케줄링 컴포넌트가 존재합니다 arxiv.org . 덕분에 비선형적 흐름도 가능하며 (예: 조건분기나"
          ],
          "6": [
            "2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다. \n주요 전략 사전 검색 처리 (Pre-retrieval processing): ● 쿼리 재작성(query rewriting): 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. ● 쿼리 확장(query expansion): 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다. ● 쿼리 변환(query transformation): 원래 쿼리 대신 변환된 쿼리를 기반으로 검색 및 생성을 수행합니다.\n사후 검색 처리 (Post-retrieval processing): ● 검색 결과 재정렬(reranking): 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다. ● 압축(compression): 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다. ● 선택(selection): 관련 없는 덩어리를 직접 제거하여 LLM의 추론 효율성을 향상시킵니다.  \n특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "• 향상된 검색 기법: 질의 처리 후 하이브리드 검색(밀도 기반 임베딩 검색 + 희소 키워드 검색)을 활용해 더 풍부한 결과를 얻습니다 ibm.com . 복잡한 질문의 경우 계층적 인덱싱이나 다단계 검색(예: iterative/recursive retrieval)으로 한층 심화된 검색을 수행하여 정확도를 높입니다 arxiv.org  arxiv.org . \n• 다중 모듈 검색: 질의 종류와 목적에 따라 여러 검색 모듈을 조합합니다. 예를 들어, 임베딩 기반 벡터 검색에 더해 지식 그래프 질의나 API 호출 등 이기종 데이터 검색을 병행할 수 있습니다. 또한 복잡한 문제에 대해 반복적 검색이나 분기 검색 흐름을 구현하여 필요한 정보를 순차적으로 수집할 수 있습니다 arxiv.org . 이러한 유연한 검색 설계로 질의의 의도에 맞게 다양한 소스에서 정보를 획득합니다. 모델 아키텍처 (Model Architecture) • 선형 파이프라인 구조: 인덱싱 → 검색 → 생성의 직렬 단계로 구성된 가장 단순한 형태입니다 arxiv.org . 별도의 최적화 모듈이나 피드백 루프 없이, 검색기와 한 번의 생성기로 답변을 생성합니다. 전체 구조가 단순하여 추가 구성요소가 없습니다. \n• 개선된 단일 흐름 구조: 기본 RAG 파이프라인에 전처리/후처리 모듈을 추가한 구조입니다. 예를 들어, 질의 재작성 모듈로 입력 질문을 명확히 하고 arxiv.org , 재검색 및 재정렬 모듈로 검색 결과를 필터링한 후 LLM에 전달합니다. 응답 생성 후에는 사용자 클릭이나 피드백 등을 활용한 피드백 루프를 도입해 검색기와 생성기를 지속적으로 개선하기도 합니다 \n• 모듈식 아키텍처: 여러 독립 모듈을 레고 블록처럼 연결하여 구성한 프레임워크입니다 arxiv.org . 질의 처리, 검색, 필터링, 생성, 검증 등의 기능이 분리된 모듈로 구현되고, 이들을 제어하는 라우팅/스케줄링 컴포넌트가 존재합니다 arxiv.org . 덕분에 비선형적 흐름도 가능하며 (예: 조건분기나",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다."
          ],
          "7": [
            "한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담 \n이 표를 통해 각 RAG 방법론의 특징을 비교하고, 프로젝트 목적과 요구사항에 맞는 최적의 방식을 선택하는 데 도움이 될 수 있습니다. Modular RAG는 높은 유연성과 확장성을 제공하여, 특히 복잡한 도메인 지식이 필요한 분야에서 강력한 성능을 발휘할 수 있습니다.\n3. Modular RAG의 주요 구성 요소 Modular RAG에서 계층구조의 구성 요소와 역할과 세부 내용을 알아봅니다. Agent Workflow Module 주요 프로세스(검색, 증강, 생성 등)를 담당 Submodule 모듈 내부에서 세부적인 작업 단계를 처리 Operator 데이터 처리 및 변환과 같은 기본적인 작업 단위를 수행 \n3.1 Agent 기반의 아키텍처 Modular RAG의 핵심 요소 중 하나는 Agent 기반 아키텍처입니다. 기존 AI 에이전트와 비교했을 때, Modular RAG의 에이전트는 다중 모듈을 조율하고 특정 작업을 수행하는 방식으로 설계됩니다. 이를 통해 보다 유연하고 확장 가능한 AI 시스템을 구축할 수 있습니다. \nAI Agent 아키텍처 AI 에이전트는 특정 목표를 달성하기 위해 환경에서 데이터를 감지하고, 해석하며, 행동하는 시스템입니다. AI 에이전트 아키텍처는 인공지능 시스템이 환경을 인식하고, 분석하며, 행동하는 방식을 정의하는 구조적 설계입니다. 이는 AI 에이전트가 자율적으로 작동하고 목표를 달성할 수 있도록 하는 핵심 요소를 포함하며, 다양한 구성 요소와 설계 패턴으로 이루어집니다.",
            "Modular RAG에서 AI Agent 아키텍처 Modular RAG(Retrieval-Augmented Generation) 기반 AI 시스템은 정보 검색(Retrieval)과 생성(Generation)을 기능을 모듈화하여 구성된 구조로, 여러 독립적인 모듈을 조합하여 유연하고 확장 가능한 AI를 구축하는 방식입니다. 이 시스템의 핵심 구성 요소는 에이전트(Agent) 모듈(Modules)입니다. 에이전트(Agent)는 전체 워크플로우를 조율하여, 전체시스템의 흐름과 전략적 제어를 담당하는 핵심 역할을 합니다. 기존의 LLM(대규모 언어 모델)이 주로 사전 학습된 지식과 인컨텍스트 학습에 의존하는 것과 달리, 에이전트는 외부 도구(예: 웹 검색, API, 구조화된 데이터베이스)와 동적으로 상호작용하여 그 능력을 확장합니다. 에이전트는 주어진 작업에 따라 어떤 도구를 호출할지 자율적으로 결정하며, 이를 통해 더 정확하고 상황에 맞는 응답을 생성할 수 있습니다. 또한, 에이전트는 고급 라우팅 메커니즘을 활용하여 사용자 쿼리를 분석하고 가장 적합한 데이터 소스나 처리 경로로 안내합니다. 예를 들어, 특정 데이터베이스에서 정보를 검색해야 하는지, 웹 검색을 수행해야 하는지, 또는 도메인 특화 지식을 활용해야 하는지를 스스로 판단할 수 있습니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로"
          ],
          "8": [
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담 \n이 표를 통해 각 RAG 방법론의 특징을 비교하고, 프로젝트 목적과 요구사항에 맞는 최적의 방식을 선택하는 데 도움이 될 수 있습니다. Modular RAG는 높은 유연성과 확장성을 제공하여, 특히 복잡한 도메인 지식이 필요한 분야에서 강력한 성능을 발휘할 수 있습니다.\n3. Modular RAG의 주요 구성 요소 Modular RAG에서 계층구조의 구성 요소와 역할과 세부 내용을 알아봅니다. Agent Workflow Module 주요 프로세스(검색, 증강, 생성 등)를 담당 Submodule 모듈 내부에서 세부적인 작업 단계를 처리 Operator 데이터 처리 및 변환과 같은 기본적인 작업 단위를 수행 \n3.1 Agent 기반의 아키텍처 Modular RAG의 핵심 요소 중 하나는 Agent 기반 아키텍처입니다. 기존 AI 에이전트와 비교했을 때, Modular RAG의 에이전트는 다중 모듈을 조율하고 특정 작업을 수행하는 방식으로 설계됩니다. 이를 통해 보다 유연하고 확장 가능한 AI 시스템을 구축할 수 있습니다. \nAI Agent 아키텍처 AI 에이전트는 특정 목표를 달성하기 위해 환경에서 데이터를 감지하고, 해석하며, 행동하는 시스템입니다. AI 에이전트 아키텍처는 인공지능 시스템이 환경을 인식하고, 분석하며, 행동하는 방식을 정의하는 구조적 설계입니다. 이는 AI 에이전트가 자율적으로 작동하고 목표를 달성할 수 있도록 하는 핵심 요소를 포함하며, 다양한 구성 요소와 설계 패턴으로 이루어집니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트"
          ],
          "9": [
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다.",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다."
          ],
          "10": [
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:"
          ],
          "11": [
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담 \n이 표를 통해 각 RAG 방법론의 특징을 비교하고, 프로젝트 목적과 요구사항에 맞는 최적의 방식을 선택하는 데 도움이 될 수 있습니다. Modular RAG는 높은 유연성과 확장성을 제공하여, 특히 복잡한 도메인 지식이 필요한 분야에서 강력한 성능을 발휘할 수 있습니다.\n3. Modular RAG의 주요 구성 요소 Modular RAG에서 계층구조의 구성 요소와 역할과 세부 내용을 알아봅니다. Agent Workflow Module 주요 프로세스(검색, 증강, 생성 등)를 담당 Submodule 모듈 내부에서 세부적인 작업 단계를 처리 Operator 데이터 처리 및 변환과 같은 기본적인 작업 단위를 수행 \n3.1 Agent 기반의 아키텍처 Modular RAG의 핵심 요소 중 하나는 Agent 기반 아키텍처입니다. 기존 AI 에이전트와 비교했을 때, Modular RAG의 에이전트는 다중 모듈을 조율하고 특정 작업을 수행하는 방식으로 설계됩니다. 이를 통해 보다 유연하고 확장 가능한 AI 시스템을 구축할 수 있습니다. \nAI Agent 아키텍처 AI 에이전트는 특정 목표를 달성하기 위해 환경에서 데이터를 감지하고, 해석하며, 행동하는 시스템입니다. AI 에이전트 아키텍처는 인공지능 시스템이 환경을 인식하고, 분석하며, 행동하는 방식을 정의하는 구조적 설계입니다. 이는 AI 에이전트가 자율적으로 작동하고 목표를 달성할 수 있도록 하는 핵심 요소를 포함하며, 다양한 구성 요소와 설계 패턴으로 이루어집니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "Modular RAG에서 AI Agent 특징: ● 동적 워크플로우 관리: 상황에 따라 필요한 모듈들을 선택하고 연결하여 유연한 작업 흐름을 구성합니다. ● 라우팅(Routing) : 복잡한 문제 해결이나 전략 수립이 필요할 때, 어떤 작업을 먼저 수행할지 판단하고 전체 프로세스를 관리합니다. ● 모듈 간 인터페이스 관리: 각 모듈과 하위 모듈 간의 데이터 교환, 호출 순서, 의존성 등을 조율하여 시스템의 일관성을 유지합니다. 각 에이전트는 특정 역할(예: 검색, 생성, 데이터 처리 등)을 담당하며, 독립적으로 실행됩니다. 다중 에이전트 시스템(Multi-Agent System)에서 각 에이전트는 서로 다른 모듈과 연결되어 작업을 분담합니다. 에이전트 간 메시지 전달 및 협업을 통해 복잡한 작업을 수행합니다. ● 유연성과 확장성: 새로운 기능을 추가하려면 해당 기능을 수행하는 새로운 에이전트를 추가하면 됩니다. ● 병렬 처리: 여러 에이전트가 동시에 작업하여 효율성을 향상됩니다.   AI Agent 상호작용 Agent는 LLM과 Tools, Prompt를 활용하여 전체 워크플로우를 조율하고 작업을 수행합니다. Tools는 특정 기능(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 경우에 따라 이를 하나의 모듈로 간주할 수 있습니다. 또한, Tools 내부에서 세부적인 작업(예: API 호출 또는 데이터 필터링)을 하위 모듈로 정의할 수 있습니다. 일부 시스템에서는 LLM이 독립적인 모듈로 동작할 수도 있으며, 특정 Tools는 Agent 없이도 직접 실행될 수 있습니다. 예시 ● 검색 에이전트: 외부 데이터베이스에서 정보를 검색(tavily search, web-scrapper). ● 문서작성 에이전트: 검색된 데이터를 바탕으로 문서 작성합니다. ● 그래프 작성 에이전트: 검색된 데이터를 바탕으로 필요에 따라서 그래프 작성(python repl)합니다. ● 감독 에이전트: 여러 에이전트를 조율하여 최적의 결과를 도출합니다."
          ],
          "12": [
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "6. Conclusion 이 리포트에서는 RAG(Retrieval-Augmented Generation)의 발전 방향을 분석하기 위해, 최근 주목받고 있는 Modular RAG를 중심으로 기존 RAG 패러다임(Naive RAG, Advanced RAG)과 비교하고, 새롭게 등장한 GraphRAG까지 다루었습니다. RAG는 LLM의 한계를 보완하며, 보다 신뢰할 수 있는 검색과 응답 생성을 목표로 발전해왔습니다. 기존 Naive RAG는 단순 검색 기반이었으며, Advanced RAG는 검색 최적화를 추가하여 성능을 향상시켰습니다. 이후 Modular RAG는 검색, 생성, 색인 기능을 독립적인 모듈로 분리하여 유연성과 확장성을 극대화하는 구조로 발전했습니다.  그러나 여전히 검색된 정보의 신뢰성과 정확성을 높이는 것이 중요한 과제로 남아 있으며, 이를 해결하기 위해 GraphRAG가 도입되었습니다. GraphRAG는 기존 벡터 검색의 한계를 보완하기 위해 지식 그래프(Knowledge Graph)를 활용한 검색 방식을 도입하여, 문서 간의 관계를 반영한 보다 정밀한 정보를 제공합니다. LinkedIn 사례에서는 GraphRAG 도입 후 검색 정확도 77.6% 향상, BLEU 점수 0.32 증가, 고객 서비스 해결 시간이 28.6% 단축되는 성과를 거두었습니다. 기존 RAG는 벡터 검색(Vector RAG)에 의존했지만, 최근 GraphRAG, Adaptive Retrieval, Multi-Agent RAG 등의 개념이 등장하며 검색 정확도, 신뢰성, 실시간성, 맥락 최적화가 더욱 강화되고 있습니다. 현재까지의 발전 흐름을 보면, 앞으로는 검색 전략을 스스로 최적화하는 자율적 검색 시스템까지 발전될 수 있는 가능성이 있습니다.",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다."
          ],
          "13": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트"
          ],
          "14": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다.",
            "·         청크 최적화(Chunk Optimization): 청크 크기 조정, 겹침 조정, 메타데이터 추가. ·         구조 조직(Structural Organization): 계층적 인덱싱 및 지식 그래프(KG) 기반 인덱싱. Operator는 청크 분할 및 구조화 작업으로 데이터 처리와 관련된 역할을 합니다. 2.     Pre-Retrieval: ·         모듈: 원본 질의를 개선하여 검색 성능을 최적화하는 과정. ·         Operator: ·         Query Expansion (질의 확장): Multi-Query, Sub-Query. ·         Query Transformation (질의 변환): Rewrite, HyDE, Step-back Prompting. ·         Query Construction (질의 구성): Text-to-SQL, Text-to-Cypher. Operator는 질의를 변환하고 확장하는 작업은 데이터 변환 및 분석에 해당합니다. 3.     Retrieval: ·         모듈: 사용자 질의를 기반으로 관련 문서를 검색. ·         Operator: ·         Retriever Selection (검색기 선택): Sparse, Dense, Hybrid Retriever. ·         Retriever Fine-tuning (검색기 미세 조정): Supervised Fine-Tuning(SFT), Adapter. Operator는 검색기 선택과 미세 조정은 검색 효율성을 높이는 핵심 작업을 합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context,",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징"
          ],
          "15": [
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다.",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "·         청크 최적화(Chunk Optimization): 청크 크기 조정, 겹침 조정, 메타데이터 추가. ·         구조 조직(Structural Organization): 계층적 인덱싱 및 지식 그래프(KG) 기반 인덱싱. Operator는 청크 분할 및 구조화 작업으로 데이터 처리와 관련된 역할을 합니다. 2.     Pre-Retrieval: ·         모듈: 원본 질의를 개선하여 검색 성능을 최적화하는 과정. ·         Operator: ·         Query Expansion (질의 확장): Multi-Query, Sub-Query. ·         Query Transformation (질의 변환): Rewrite, HyDE, Step-back Prompting. ·         Query Construction (질의 구성): Text-to-SQL, Text-to-Cypher. Operator는 질의를 변환하고 확장하는 작업은 데이터 변환 및 분석에 해당합니다. 3.     Retrieval: ·         모듈: 사용자 질의를 기반으로 관련 문서를 검색. ·         Operator: ·         Retriever Selection (검색기 선택): Sparse, Dense, Hybrid Retriever. ·         Retriever Fine-tuning (검색기 미세 조정): Supervised Fine-Tuning(SFT), Adapter. Operator는 검색기 선택과 미세 조정은 검색 효율성을 높이는 핵심 작업을 합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context,",
            "모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.   \n3.3 서브모듈 하위 모듈 정의 하위 모듈은 상위 모듈의 특정 기능을 세분화하여 실행하는 단위이며, 필요에 따라 추가되거나 조합될 수도 있습니다. 부 시스템에서는 특정 하위 모듈이 여러 모듈에서 공유되거나 독립적으로 실행될 수도 있습니다   \n하위 모듈 역할 하나의 모듈 내에서 복잡한 작업을 여러 하위 단계로 분리하여, 각 단계가 담당하는 역할을 명확히 합니다. 복잡한 작업을 작은 단계로 나누어 처리함으로써 효율성을 높입니다. 상위 모듈의 성능과 유연성을 강화하기 위해 하위 모듈은 세부적인 기능 구현에 집중합니다. 각 하위 모듈은 상위 모듈의 특정 기능을 담당하며, 이를 통해 문제 발생 시 해당 부분만 집중적으로 개선하거나 수정할 수 있습니다. 즉, 하위 모듈은 상위 모듈 내에서 복잡한 작업을 여러 단계로 분리함으로써, 각 단계의 역할과 책임을 명확히 하고, 이를 통해 문제 발생 시 해당 부분만 집중적으로 개선하거나 수정할 수 있도록 지원합니다.   \n하위모듈 특징 ● 세분화 (Decomposition): 상위 모듈의 복잡한 기능을 작고 명확한 단계로 분할하여 관리합니다. ● 독립성 (Independence): 각 하위 모듈은 서로 간섭 없이 독립적으로 작동하여, 다른 부분에 미치는 영향을 최소화합니다. ● 유지보수성 (Maintainability): 문제 발생 시 개별 하위 모듈만 수정하면 되어, 전체 시스템의 유지보수가 용이합니다. ● 재사용성 (Reusability): 잘 정의된 하위 모듈은 다른 모듈이나 프로젝트에서도 쉽게 재사용할 수 있습니다.",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징"
          ],
          "16": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723"
          ],
          "17": [
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담 \n이 표를 통해 각 RAG 방법론의 특징을 비교하고, 프로젝트 목적과 요구사항에 맞는 최적의 방식을 선택하는 데 도움이 될 수 있습니다. Modular RAG는 높은 유연성과 확장성을 제공하여, 특히 복잡한 도메인 지식이 필요한 분야에서 강력한 성능을 발휘할 수 있습니다.\n3. Modular RAG의 주요 구성 요소 Modular RAG에서 계층구조의 구성 요소와 역할과 세부 내용을 알아봅니다. Agent Workflow Module 주요 프로세스(검색, 증강, 생성 등)를 담당 Submodule 모듈 내부에서 세부적인 작업 단계를 처리 Operator 데이터 처리 및 변환과 같은 기본적인 작업 단위를 수행 \n3.1 Agent 기반의 아키텍처 Modular RAG의 핵심 요소 중 하나는 Agent 기반 아키텍처입니다. 기존 AI 에이전트와 비교했을 때, Modular RAG의 에이전트는 다중 모듈을 조율하고 특정 작업을 수행하는 방식으로 설계됩니다. 이를 통해 보다 유연하고 확장 가능한 AI 시스템을 구축할 수 있습니다. \nAI Agent 아키텍처 AI 에이전트는 특정 목표를 달성하기 위해 환경에서 데이터를 감지하고, 해석하며, 행동하는 시스템입니다. AI 에이전트 아키텍처는 인공지능 시스템이 환경을 인식하고, 분석하며, 행동하는 방식을 정의하는 구조적 설계입니다. 이는 AI 에이전트가 자율적으로 작동하고 목표를 달성할 수 있도록 하는 핵심 요소를 포함하며, 다양한 구성 요소와 설계 패턴으로 이루어집니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다."
          ],
          "18": [
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다."
          ],
          "19": [
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "설계 방법 LinkedIn은 시스템은 과거 고객 서비스 문제 티켓에서 Knowledge Graph를 구축하고, 질문 응답 단계에서 소비자 쿼리를 파싱하여 관련 하위 그래프를 식별하고 답변을 생성합니다. 주요 사용 방법은 다음과 같습니다.\n● 지식 그래프 구축 (Knowledge Graph Construction) ○ Intra-ticket 트리 파싱: 텍스트 기반 티켓을 트리 구조로 변환합니다. 규칙 기반 추출과 LLM 파싱을 함께 사용하여 티켓 섹션을 식별하고 계층적으로 연결합니다. ○ Inter-ticket 연결: 개별 트리를 통합하여 포괄적인 그래프를 형성합니다. 티켓에 명시된 명시적 연결과 텍스트 의미 유사성을 기반으로 한 암시적 연결을 모두 활용합니다. ○ 임베딩 생성: BERT, E5와 같은 텍스트 임베딩 모델을 사용하여 그래프 노드 값에 대한 임베딩을 생성하고, 벡터 데이터베이스에 저장하여 검색을 용이하게 합니다. ● 검색 및 질문 응답 (Retrieval and Question Answering) ○ 쿼리 엔터티 식별 및 의도 감지: 사용자 쿼리에서 명명된 엔터티와 쿼리 의도를 추출합니다. LLM을 사용하여 쿼리를 파싱하고, 그래프 템플릿에 따라 키-값 쌍을 추출합니다.\n○ 하위 그래프의 임베딩 기반 검색: 사용자 쿼리에서 파생된 엔터티를 사용하여 관련 하위 그래프를 검색합니다. 코사인 유사도를 사용하여 티켓 수준 점수를 집계하고 상위 K개 티켓을 선택합니다. ○ 답변 생성: 검색된 데이터를 초기 쿼리와 연결하여 답변을 합성합니다. LLM은 검색된 정보를 기반으로 응답을 생성하는 디코더 역할을 합니다. 쿼리 실행에 문제가 발생하면 텍스트 기반 검색 방법으로 대체합니다."
          ],
          "20": [
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환"
          ],
          "21": [
            "6. Conclusion 이 리포트에서는 RAG(Retrieval-Augmented Generation)의 발전 방향을 분석하기 위해, 최근 주목받고 있는 Modular RAG를 중심으로 기존 RAG 패러다임(Naive RAG, Advanced RAG)과 비교하고, 새롭게 등장한 GraphRAG까지 다루었습니다. RAG는 LLM의 한계를 보완하며, 보다 신뢰할 수 있는 검색과 응답 생성을 목표로 발전해왔습니다. 기존 Naive RAG는 단순 검색 기반이었으며, Advanced RAG는 검색 최적화를 추가하여 성능을 향상시켰습니다. 이후 Modular RAG는 검색, 생성, 색인 기능을 독립적인 모듈로 분리하여 유연성과 확장성을 극대화하는 구조로 발전했습니다.  그러나 여전히 검색된 정보의 신뢰성과 정확성을 높이는 것이 중요한 과제로 남아 있으며, 이를 해결하기 위해 GraphRAG가 도입되었습니다. GraphRAG는 기존 벡터 검색의 한계를 보완하기 위해 지식 그래프(Knowledge Graph)를 활용한 검색 방식을 도입하여, 문서 간의 관계를 반영한 보다 정밀한 정보를 제공합니다. LinkedIn 사례에서는 GraphRAG 도입 후 검색 정확도 77.6% 향상, BLEU 점수 0.32 증가, 고객 서비스 해결 시간이 28.6% 단축되는 성과를 거두었습니다. 기존 RAG는 벡터 검색(Vector RAG)에 의존했지만, 최근 GraphRAG, Adaptive Retrieval, Multi-Agent RAG 등의 개념이 등장하며 검색 정확도, 신뢰성, 실시간성, 맥락 최적화가 더욱 강화되고 있습니다. 현재까지의 발전 흐름을 보면, 앞으로는 검색 전략을 스스로 최적화하는 자율적 검색 시스템까지 발전될 수 있는 가능성이 있습니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다."
          ],
          "22": [
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "개선사항 구조를 무시하여 발생하는 검색 정확도 저하를 개선 이슈 추적 문서(예: Jira)는 고유한 구조를 가지고 있으며, \"이슈 A는 이슈 B와 관련됨/복사됨/원인이 됨\"과 같은 참조로 상호 연결됩니다. 문서를 텍스트 덩어리로 압축하는 기존 방식은 중요한 정보의 손실을 초래할 수 있습니다. LinkedIn의 접근 방식은 이슈 티켓을 트리로 파싱하고 개별 이슈 티켓을 연결하여 상호 연결된 그래프를 형성함으로써 엔터티 간의 내재적 관계를 유지하여 높은 검색 성능을 달성합니다. \n세분화로 인한 답변 품질 저하를 개선 임베딩 모델의 컨텍스트 길이 제약을 수용하기 위해 광범위한 이슈 티켓을 고정 길이 세그먼트로 분할하면 관련 콘텐츠가 단절되어 불완전한 답변이 발생할 수 있습니다. 예를 들어, 이슈 티켓이 시작 부분에 이슈를 설명하고 끝 부분에 솔루션을 설명하는 경우 텍스트 세분화 프로세스 중에 분할되어 솔루션의 중요한 부분이 생략될 수 있습니다. LinkedIn의 그래프 기반 파싱 방법은 티켓 섹션의 논리적 일관성을 유지하여 완전하고 고품질의 응답을 제공함으로써 이 문제를 극복합니다.  \n결과 LinkedIn의 고객 서비스 팀 내에서 이 방법론을 사용한 결과, 이슈당 중간 해결 시간이 28.6% 감소했습니다. 이는 기존의 수동 방법에 비해 상당한 개선입니다. 구체적으로, Knowledge Graph를 사용하지 않은 그룹의 평균 이슈 해결 시간은 40시간인데 반해, Knowledge Graph를 사용한 그룹은 15시간으로 단축되었습니다. 이는 RAG와 지식 그래프의 통합이 고객 서비스 효율성을 향상시킬 수 있음을 보여줍니다",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ],
          "23": [
            "개선사항 구조를 무시하여 발생하는 검색 정확도 저하를 개선 이슈 추적 문서(예: Jira)는 고유한 구조를 가지고 있으며, \"이슈 A는 이슈 B와 관련됨/복사됨/원인이 됨\"과 같은 참조로 상호 연결됩니다. 문서를 텍스트 덩어리로 압축하는 기존 방식은 중요한 정보의 손실을 초래할 수 있습니다. LinkedIn의 접근 방식은 이슈 티켓을 트리로 파싱하고 개별 이슈 티켓을 연결하여 상호 연결된 그래프를 형성함으로써 엔터티 간의 내재적 관계를 유지하여 높은 검색 성능을 달성합니다. \n세분화로 인한 답변 품질 저하를 개선 임베딩 모델의 컨텍스트 길이 제약을 수용하기 위해 광범위한 이슈 티켓을 고정 길이 세그먼트로 분할하면 관련 콘텐츠가 단절되어 불완전한 답변이 발생할 수 있습니다. 예를 들어, 이슈 티켓이 시작 부분에 이슈를 설명하고 끝 부분에 솔루션을 설명하는 경우 텍스트 세분화 프로세스 중에 분할되어 솔루션의 중요한 부분이 생략될 수 있습니다. LinkedIn의 그래프 기반 파싱 방법은 티켓 섹션의 논리적 일관성을 유지하여 완전하고 고품질의 응답을 제공함으로써 이 문제를 극복합니다.  \n결과 LinkedIn의 고객 서비스 팀 내에서 이 방법론을 사용한 결과, 이슈당 중간 해결 시간이 28.6% 감소했습니다. 이는 기존의 수동 방법에 비해 상당한 개선입니다. 구체적으로, Knowledge Graph를 사용하지 않은 그룹의 평균 이슈 해결 시간은 40시간인데 반해, Knowledge Graph를 사용한 그룹은 15시간으로 단축되었습니다. 이는 RAG와 지식 그래프의 통합이 고객 서비스 효율성을 향상시킬 수 있음을 보여줍니다",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "6. Conclusion 이 리포트에서는 RAG(Retrieval-Augmented Generation)의 발전 방향을 분석하기 위해, 최근 주목받고 있는 Modular RAG를 중심으로 기존 RAG 패러다임(Naive RAG, Advanced RAG)과 비교하고, 새롭게 등장한 GraphRAG까지 다루었습니다. RAG는 LLM의 한계를 보완하며, 보다 신뢰할 수 있는 검색과 응답 생성을 목표로 발전해왔습니다. 기존 Naive RAG는 단순 검색 기반이었으며, Advanced RAG는 검색 최적화를 추가하여 성능을 향상시켰습니다. 이후 Modular RAG는 검색, 생성, 색인 기능을 독립적인 모듈로 분리하여 유연성과 확장성을 극대화하는 구조로 발전했습니다.  그러나 여전히 검색된 정보의 신뢰성과 정확성을 높이는 것이 중요한 과제로 남아 있으며, 이를 해결하기 위해 GraphRAG가 도입되었습니다. GraphRAG는 기존 벡터 검색의 한계를 보완하기 위해 지식 그래프(Knowledge Graph)를 활용한 검색 방식을 도입하여, 문서 간의 관계를 반영한 보다 정밀한 정보를 제공합니다. LinkedIn 사례에서는 GraphRAG 도입 후 검색 정확도 77.6% 향상, BLEU 점수 0.32 증가, 고객 서비스 해결 시간이 28.6% 단축되는 성과를 거두었습니다. 기존 RAG는 벡터 검색(Vector RAG)에 의존했지만, 최근 GraphRAG, Adaptive Retrieval, Multi-Agent RAG 등의 개념이 등장하며 검색 정확도, 신뢰성, 실시간성, 맥락 최적화가 더욱 강화되고 있습니다. 현재까지의 발전 흐름을 보면, 앞으로는 검색 전략을 스스로 최적화하는 자율적 검색 시스템까지 발전될 수 있는 가능성이 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다."
          ],
          "24": [
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다."
          ],
          "25": [
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다."
          ],
          "26": [
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다."
          ],
          "27": [
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "6. Conclusion 이 리포트에서는 RAG(Retrieval-Augmented Generation)의 발전 방향을 분석하기 위해, 최근 주목받고 있는 Modular RAG를 중심으로 기존 RAG 패러다임(Naive RAG, Advanced RAG)과 비교하고, 새롭게 등장한 GraphRAG까지 다루었습니다. RAG는 LLM의 한계를 보완하며, 보다 신뢰할 수 있는 검색과 응답 생성을 목표로 발전해왔습니다. 기존 Naive RAG는 단순 검색 기반이었으며, Advanced RAG는 검색 최적화를 추가하여 성능을 향상시켰습니다. 이후 Modular RAG는 검색, 생성, 색인 기능을 독립적인 모듈로 분리하여 유연성과 확장성을 극대화하는 구조로 발전했습니다.  그러나 여전히 검색된 정보의 신뢰성과 정확성을 높이는 것이 중요한 과제로 남아 있으며, 이를 해결하기 위해 GraphRAG가 도입되었습니다. GraphRAG는 기존 벡터 검색의 한계를 보완하기 위해 지식 그래프(Knowledge Graph)를 활용한 검색 방식을 도입하여, 문서 간의 관계를 반영한 보다 정밀한 정보를 제공합니다. LinkedIn 사례에서는 GraphRAG 도입 후 검색 정확도 77.6% 향상, BLEU 점수 0.32 증가, 고객 서비스 해결 시간이 28.6% 단축되는 성과를 거두었습니다. 기존 RAG는 벡터 검색(Vector RAG)에 의존했지만, 최근 GraphRAG, Adaptive Retrieval, Multi-Agent RAG 등의 개념이 등장하며 검색 정확도, 신뢰성, 실시간성, 맥락 최적화가 더욱 강화되고 있습니다. 현재까지의 발전 흐름을 보면, 앞으로는 검색 전략을 스스로 최적화하는 자율적 검색 시스템까지 발전될 수 있는 가능성이 있습니다.",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ],
          "28": [
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다."
          ],
          "29": [
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자"
          ],
          "30": [
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다."
          ],
          "31": [
            "• 향상된 검색 기법: 질의 처리 후 하이브리드 검색(밀도 기반 임베딩 검색 + 희소 키워드 검색)을 활용해 더 풍부한 결과를 얻습니다 ibm.com . 복잡한 질문의 경우 계층적 인덱싱이나 다단계 검색(예: iterative/recursive retrieval)으로 한층 심화된 검색을 수행하여 정확도를 높입니다 arxiv.org  arxiv.org . \n• 다중 모듈 검색: 질의 종류와 목적에 따라 여러 검색 모듈을 조합합니다. 예를 들어, 임베딩 기반 벡터 검색에 더해 지식 그래프 질의나 API 호출 등 이기종 데이터 검색을 병행할 수 있습니다. 또한 복잡한 문제에 대해 반복적 검색이나 분기 검색 흐름을 구현하여 필요한 정보를 순차적으로 수집할 수 있습니다 arxiv.org . 이러한 유연한 검색 설계로 질의의 의도에 맞게 다양한 소스에서 정보를 획득합니다. 모델 아키텍처 (Model Architecture) • 선형 파이프라인 구조: 인덱싱 → 검색 → 생성의 직렬 단계로 구성된 가장 단순한 형태입니다 arxiv.org . 별도의 최적화 모듈이나 피드백 루프 없이, 검색기와 한 번의 생성기로 답변을 생성합니다. 전체 구조가 단순하여 추가 구성요소가 없습니다. \n• 개선된 단일 흐름 구조: 기본 RAG 파이프라인에 전처리/후처리 모듈을 추가한 구조입니다. 예를 들어, 질의 재작성 모듈로 입력 질문을 명확히 하고 arxiv.org , 재검색 및 재정렬 모듈로 검색 결과를 필터링한 후 LLM에 전달합니다. 응답 생성 후에는 사용자 클릭이나 피드백 등을 활용한 피드백 루프를 도입해 검색기와 생성기를 지속적으로 개선하기도 합니다 \n• 모듈식 아키텍처: 여러 독립 모듈을 레고 블록처럼 연결하여 구성한 프레임워크입니다 arxiv.org . 질의 처리, 검색, 필터링, 생성, 검증 등의 기능이 분리된 모듈로 구현되고, 이들을 제어하는 라우팅/스케줄링 컴포넌트가 존재합니다 arxiv.org . 덕분에 비선형적 흐름도 가능하며 (예: 조건분기나",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "• 최고의 유연성 & 확장성: 모듈 단위로 구성요소를 교체하거나 조정할 수 있어 요구사항 변경에 대응하기 쉽고 유지보수 용이합니다 ibm.com . 또한 각 컴포넌트를 독립적으로 최적화 또는 병렬화할 수 있어 대규모 지식베이스나 복잡한 작업에도 성능과 규모를 확장하기 유리합니다. 여러 데이터 소스를 통합하고 다양한 NLP 기능(요약, 번역, 대화 등)을 결합할 수 있어 복합적인 AI 시스템 구축에 적합합니다 arxiv.org ibm.com 단점 (Disadvantages) • 제한된 이해도와 신뢰성: 질의를 피상적으로 매칭하므로 질문의 의도나 맥락을 깊게 반영하지 못해 복잡한 질문에는 오답을 내기 쉽습니다 arxiv.org . 또한 검색된 문서를 여과 없이 모두 투입하기 때문에 불필요한 정보까지 포함되어 LLM이 혼란을 일으키거나 **환각 정보(hallucination)**를 생성할 위험이 있습니다 arxiv.org . 요약하면 간단한 구조로 인해 성능 한계가 뚜렷합니다. \n• 높은 복잡도와 비용: 추가 단계들로 인해 모델 처리 지연이 증가하고, 하이브리드 인덱싱 및 재랭킹 등에 따른 계산/메모리 비용이 큽니다 ibm.com . 구성요소(검색기, 랭커, 생성기 등)를 모두 관리하고 튜닝해야 하므로 시스템 구현과 유지보수가 복잡하며, 규모가 커질수록 이러한 복잡성이 배가됩니다. 결국 대규모 프로덕션 환경에 곧바로 적용하기 어렵고 충분한 자원과 전문성이 요구됩니다 ibm.com  ibm.com .",
            "개선사항 구조를 무시하여 발생하는 검색 정확도 저하를 개선 이슈 추적 문서(예: Jira)는 고유한 구조를 가지고 있으며, \"이슈 A는 이슈 B와 관련됨/복사됨/원인이 됨\"과 같은 참조로 상호 연결됩니다. 문서를 텍스트 덩어리로 압축하는 기존 방식은 중요한 정보의 손실을 초래할 수 있습니다. LinkedIn의 접근 방식은 이슈 티켓을 트리로 파싱하고 개별 이슈 티켓을 연결하여 상호 연결된 그래프를 형성함으로써 엔터티 간의 내재적 관계를 유지하여 높은 검색 성능을 달성합니다. \n세분화로 인한 답변 품질 저하를 개선 임베딩 모델의 컨텍스트 길이 제약을 수용하기 위해 광범위한 이슈 티켓을 고정 길이 세그먼트로 분할하면 관련 콘텐츠가 단절되어 불완전한 답변이 발생할 수 있습니다. 예를 들어, 이슈 티켓이 시작 부분에 이슈를 설명하고 끝 부분에 솔루션을 설명하는 경우 텍스트 세분화 프로세스 중에 분할되어 솔루션의 중요한 부분이 생략될 수 있습니다. LinkedIn의 그래프 기반 파싱 방법은 티켓 섹션의 논리적 일관성을 유지하여 완전하고 고품질의 응답을 제공함으로써 이 문제를 극복합니다.  \n결과 LinkedIn의 고객 서비스 팀 내에서 이 방법론을 사용한 결과, 이슈당 중간 해결 시간이 28.6% 감소했습니다. 이는 기존의 수동 방법에 비해 상당한 개선입니다. 구체적으로, Knowledge Graph를 사용하지 않은 그룹의 평균 이슈 해결 시간은 40시간인데 반해, Knowledge Graph를 사용한 그룹은 15시간으로 단축되었습니다. 이는 RAG와 지식 그래프의 통합이 고객 서비스 효율성을 향상시킬 수 있음을 보여줍니다"
          ],
          "32": [
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "핵심 모듈 조합 ● 질문 재작성(Query Rewrite): 모델 기반 접근 방식을 사용하여 사용자 질의를 변환해 보다 정밀한 추천 제공 ● 검색(Retrieve): 희소 인코딩(BM25)을 활용한 키워드 검색과 밀집 임베딩을 통한 의미적 검색을 결합한 하이브리드 검색 방식 적용\n● 생성(Generate): API 기반 또는 온프레미스 LLM을 활용하여 최적의 추천 결과를 생성하고 사용자 맞춤형 설명 제공 ● LLM 보상 강화 학습(LLM Reward Reinforcement Learning): 클릭 및 구매 데이터를 학습하여 질문 재작성 및 검색 프로세스를 지속적으로 최적화 \n설계 흐름 \n 1. 질문 재작성(Query Rewrite) ● 사용자의 검색 질의를 분석하고 최적화하여 추천 정확도를 향상 ● 예시: \"여름 샌들 추천\" → \"2024년 여름 인기 샌들 + 편안한 착용감 + 최신 할인 정보 포함\" 2. 검색(Retrieve) ● 하이브리드 검색 방식을 활용: ○ BM25 (희소 인코딩): 제품 설명, 고객 리뷰, 트렌드 데이터를 직접 키워드 매칭을 통해 검색 ○ 밀집 임베딩(Dense Embeddings): 제품과 사용자 선호도 간의 의미적 관계를 분석하여 맞춤형 추천 제공 ○ 하이브리드 점수 계산: 희소 및 밀집 검색 결과를 결합하여 정밀도와 재현율을 최적화 ● 예시: \"무선 청소기를 최근 검색한 사용자\" → \"무선 청소기 액세서리 + 베스트셀러 청소기 추천\" 3. 생성(Generate) ● API 기반 또는 온프레미스 LLM을 활용하여 개인 맞춤형 추천을 제공하며 설명까지 포함 ● 예시: \"이 제품은 최근 검색한 무선 청소기와 호환되며, 높은 사용자 평점을 받은 제품입니다.\" 4. LLM 보상 강화 학습(LLM Reward Reinforcement Learning) ● 사용자 상호작용(클릭 및 구매 데이터)을 학습하여 질문 재작성 및 검색 프로세스를 최적화 ● 보상 기반 강화 학습을 통해 실시간으로 추천 품질을 조정",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:"
          ],
          "33": [
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "Reference ※ 각 파트별 참조한 자료가 있다면 아래 출처 작성 부탁드립니다. ※ 작성 양식 : 문서/페이지명 (링크)  1번파트 - From complex to atomic: Enhancing Augmented Generation via Knowledge-aware Dual Rewriting and Reasoning (https://openreview.net/pdf/eece737929522d36939d3b6cf5da4e8c7921f2ee.pdf) - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/html/2312.10997v5  - Context window overflow: Breaking the barrier https://aws.amazon.com/jp/blogs/security/context-window-overflow-breaking-the-barrier/  - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/html/2407.21059v1  - How does Modular RAG improve upon naive RAG? https://adasci.org/how-does-modular-rag-improve-upon-naive-rag/  - Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures"
          ],
          "34": [
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환"
          ],
          "35": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트"
          ],
          "36": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트"
          ],
          "37": [
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이"
          ],
          "38": [
            "4.3 의료 도메인 - AI 기반 진단 및 치료 추천 목표 전통적인 의료 검색 시스템은 주로 학술 논문을 기반으로 하지만, 환자의 증상 및 임상 데이터를 통합하면 더 정밀한 의료 정보를 제공할 수 있습니다. 모듈형 RAG 프레임워크를 활용하여 다수의 의료 데이터 소스를 결합함으로써 신뢰도 높은 검색 결과를 도출하고, 환자의 병력 및 유전적 요인을 반영하여 맞춤형 의료 추천을 제공합니다. \n핵심 모듈 조합 ● 질문 확장(Query Expansion): 사용자의 질의를 세분화하여 관련된 다중 질의 생성 ● 하이브리드 검색(Dense + Knowledge Graph): 증상 기반으로 의료 논문과 임상 가이드를 검색 ● 생성(Generation, Optional): 필요 시 검색된 정보를 기반으로 초기 답변 생성 ● 융합(Fusion): 연구 논문과 임상 가이드를 결합하여 최적의 답변 도출\n● 환자 병력 통합(Patient Medical History): 환자의 병력 및 유전적 요인을 반영하여 최적의 치료법 결정 ● 생성(Generation): 최종적으로 융합된 데이터를 바탕으로 최적의 답변 생성 \n설계 흐름",
            "● 환자 병력 통합(Patient Medical History): 환자의 병력 및 유전적 요인을 반영하여 최적의 치료법 결정 ● 생성(Generation): 최종적으로 융합된 데이터를 바탕으로 최적의 답변 생성 \n설계 흐름 \n 1. 질문 확장(Query Expansion) ● 사용자의 입력을 분석하여 다중 관련 질의 생성 ● 예시: “3일 이상 38도 이상의 발열과 기침\" → \"발열을 유발하는 감염 질환\", \"발열과 기침이 동반되는 질환\" 2. 하이브리드 검색(Hybrid Retrieval) ● Dense Retrieval: 유사 증상을 기반으로 의료 문헌 검색 ● Knowledge Graph: 증상과 질병 간 관계 매핑 3. 생성(Generation, Optional) ● 검색된 정보가 부족할 경우, LLM을 활용하여 초안 생성 4. 융합(Fusion) ● 연구 논문과 임상 가이드를 통합하여 종합적인 답변 도출 ● 신뢰성을 높이기 위해 출처 명확히 명시 5. 환자 병력 통합(Patient Medical History) ● 환자의 병력 및 유전적 요인을 반영하여 맞춤형 치료를 적용 ● 예시: \"당뇨 가족력이 있는 환자를 위한 최적의 독감 치료 옵션\" 6. 생성(Generation) ● 최종 융합된 정보를 바탕으로 사용자 친화적인 의료 조언 제공  \n개선점 ● 단순한 학술 논문 검색을 넘어 임상 데이터와 의료 가이드를 통합하여 더 정밀한 추천 제공 ● 환자 병력 기반 맞춤형 검색을 구현하여 진단의 정확도 향상",
            "설계 흐름 \n 1. 쿼리 변환(Query Transformation) ● 사용자의 질의를 변환하여 SQL 쿼리를 생성 ● 예시: \"테슬라의 최근 3개 분기의 재무 성과를 보여줘\" SELECT revenue, net_income, eps FROM financials WHERE company = 'Tesla' AND quarter IN ('Q1 2024', 'Q2 2024', 'Q3 2024'); 2. 질문 확장(Query Expansion) ● 사용자의 질문을 다중 질의로 변환하여 더 깊이 있는 검색 수행 ● 예시: \"테슬라의 최근 실적\" → \"테슬라의 분기별 매출\", \"테슬라의 EPS 변동 추이\" 3. 쿼리 구성(Query Construction, Text-to-SQL) ● 금융 데이터를 검색하기 위한 최적의 SQL 문 생성 4. 다중 검색(Multi-source Retrieval) ● 기업 공시(SEC Filings & Corporate Disclosures): 공식 재무제표 및 실적 보고서 검색 ● 애널리스트 보고서(Analyst Reports): 전문가의 시장 전망 및 주식 평가 분석 ● 경제 뉴스(Economic News): 거시 경제 동향 및 관련 기업 뉴스 모니터링 ● 소셜 미디어 트렌드(Social Media Trends): Twitter, Reddit, Bloomberg 댓글 등을 분석하여 실시간 시장 심리 파악",
            "4.1 도메인별 최적화 전략 각 도메인에 따라 검색 및 생성 패턴을 차별화하여 적용하면, 보다 신뢰도 높은 질의응답 시스템을 구축할 수 있습니다. ● 의료: 신뢰성과 정확성이 중요하므로 하이브리드 검색(Dense + Knowledge Graph) 과 환자 병력 반영을 적용해 맞춤형 치료를 추천합니다. ● 법률: 법적 근거와 판례 분석이 핵심이므로 판단 모듈(Judge) 과 LLM 비판적 평가(Critique) 를 활용해 신뢰성을 높입니다. ● 금융: 실시간 시장 변동 반영이 필수이므로 Text-to-SQL 과 감성 분석(Sentiment Analysis) 을 사용해 투자 인사이트를 강화합니다. ● 전자상거래: 개인화된 추천이 필요하므로 RRR(Rewrite-Retrieve-Read) 패턴 과 강화 학습(LLM Reward RL) 을 활용해 사용자 맞춤 추천을 제공합니다.\n4.2 핵심 개념 정리 \n ● Dense vs. Sparse Retrieval: ○ Dense Retrieval: 의미적 유사도를 기반으로 벡터 검색을 수행하여 가장 관련성이 높은 정보를 검색 ○ Sparse Retrieval (BM25 등): 키워드 기반 검색 방식으로 문서 내 키워드의 빈도 및 위치를 고려해 검색 정확도 향상 ● Query Expansion / Transformation: 사용자의 질의를 보다 풍부하고 정확하게 변형하여 검색 결과 품질 개선 ● Knowledge Graph: 개념 간의 관계를 그래프 구조로 저장하여, 검색 질의와 관련 정보 간 연관성을 강화",
            "개선점 ● 단순한 학술 논문 검색을 넘어 임상 데이터와 의료 가이드를 통합하여 더 정밀한 추천 제공 ● 환자 병력 기반 맞춤형 검색을 구현하여 진단의 정확도 향상\n● 최신 의료 연구 데이터를 실시간 반영하여 최신 치료 방법을 신속하게 제공  4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 목표 전통적인 법률 검색 시스템은 주로 법률 조항을 검색하는 데 초점을 맞추고 있습니다. 하지만 판례, 전문가 의견, 계약 데이터를 통합하여 보다 정밀한 법률 해석을 제공할 수 있다면 어떨까요? 모듈형 RAG 프레임워크를 적용함으로써 법률 문서를 종합적으로 분석하고, 특정 사건과 관할권에 맞는 법률 해석을 추천할 수 있습니다. \n핵심 모듈 조합 ● 판단 모듈(Judge): 사용자의 법률 질의를 분석하여 적절한 검색 방식 결정 ● 검색(Retrieve): 법률 문서, 판례, 계약서 데이터베이스에서 관련 정보 검색 ● 생성(Generate): 검색된 정보를 기반으로 초기 법률 해석 제공 ● 질문 변환(Query Transformation, Optional): 필요 시 사용자의 질문을 법률적 용어로 변환하여 추가 검색 수행 ● LLM 비판적 평가(LLM Critique): 검색된 법률 자료의 신뢰성을 평가하고 불필요한 정보를 필터링 ● 적응형 검색 및 생성(Adaptive Retrieval & Generation): 부족한 법률 자료가 발견되면 추가 검색 수행 ● 반복 RAG 흐름 제어(Loop RAG Flow Orchestration): 법률 질문 유형에 따라 검색 및 생성 프로세스 동적 조정 \n설계 흐름 \n 1. 판단(Judge)"
          ],
          "39": [
            "개선점 ● 단순한 학술 논문 검색을 넘어 임상 데이터와 의료 가이드를 통합하여 더 정밀한 추천 제공 ● 환자 병력 기반 맞춤형 검색을 구현하여 진단의 정확도 향상\n● 최신 의료 연구 데이터를 실시간 반영하여 최신 치료 방법을 신속하게 제공  4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 목표 전통적인 법률 검색 시스템은 주로 법률 조항을 검색하는 데 초점을 맞추고 있습니다. 하지만 판례, 전문가 의견, 계약 데이터를 통합하여 보다 정밀한 법률 해석을 제공할 수 있다면 어떨까요? 모듈형 RAG 프레임워크를 적용함으로써 법률 문서를 종합적으로 분석하고, 특정 사건과 관할권에 맞는 법률 해석을 추천할 수 있습니다. \n핵심 모듈 조합 ● 판단 모듈(Judge): 사용자의 법률 질의를 분석하여 적절한 검색 방식 결정 ● 검색(Retrieve): 법률 문서, 판례, 계약서 데이터베이스에서 관련 정보 검색 ● 생성(Generate): 검색된 정보를 기반으로 초기 법률 해석 제공 ● 질문 변환(Query Transformation, Optional): 필요 시 사용자의 질문을 법률적 용어로 변환하여 추가 검색 수행 ● LLM 비판적 평가(LLM Critique): 검색된 법률 자료의 신뢰성을 평가하고 불필요한 정보를 필터링 ● 적응형 검색 및 생성(Adaptive Retrieval & Generation): 부족한 법률 자료가 발견되면 추가 검색 수행 ● 반복 RAG 흐름 제어(Loop RAG Flow Orchestration): 법률 질문 유형에 따라 검색 및 생성 프로세스 동적 조정 \n설계 흐름 \n 1. 판단(Judge)",
            "설계 흐름 \n 1. 판단(Judge)\n● 사용자의 질문을 평가하여 검색이 필요한지 직접 생성이 필요한지 결정 ● 예시: \"근무 시간 변경 요청을 거부할 수 있는가?\" → \"근로 계약서에 명시되지 않은 근무 시간 변경 거부 가능 여부\" 2. 검색(Retrieve) ● 판례 검색(Case Law): 관련 과거 판결 사례 검색 ● 법률 조항 검색(Legislation): 관련 법 조항 검색 ● 계약서 데이터베이스 검색(Contracts DB): 표준 계약 조항 확인 3. 생성(Generate) ● 검색된 정보를 바탕으로 법률 해석을 제공 4. LLM 비판적 평가(LLM Critique) ● 검색된 법률 자료의 신뢰성과 관련성을 평가하여 불필요한 정보를 필터링 5. 적응형 검색 및 생성(Adaptive Retrieval & Generation) ● 추가적인 법률 참고 자료가 필요하면 자동으로 추가 검색 수행 ● 전문가 의견을 반영하여 법률 해석 강화 6. 반복 RAG 흐름 제어(Loop RAG Flow Orchestration) ● 계약 관련 질의 → 계약 조항 + 판례 검색 ● 형사법 관련 질의 → 법률 조항 + 형사 판례 검색 ● 행정법 관련 질의 → 정부 가이드라인 검색  \n개선점 ● 단순한 법률 조항 검색을 넘어 판례, 계약, 전문가 의견을 통합하여 실용적인 법률 상담 시스템 구축 ● 최신 법률 개정 사항을 자동 반영하여 신뢰도를 높이고, 지역별 법률 차이를 반영 ● 사용자 의도를 분석하여 보다 정밀한 법률 추천 제공  \n4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 목표 투자 정보를 검색할 때 단순한 데이터 검색만으로는 충분하지 않습니다. 금융 재무제표, 경제 뉴스, 애널리스트 보고서를 통합하여 보다 포괄적인 분석을 제공할 수 있다면 어떨까요? 모듈형 RAG을 활용하여 다양한 데이터 소스를 결합함으로써 보다 정밀한 투자 인사이트를 제공하고 실시간 시장 변동에 적응하는 검색 시스템을 구축할 수 있습니다.",
            "3.2 모듈  모듈 정의 모듈은 Modular RAG 시스템의 핵심 구성 블록으로 시스템의 주요 기능이나 임무(예: 정보 검색, 요약, 텍스트 생성 등)를 독립적으로 수행하는 단위입니다. 각 모듈은 특정 작업을 독립적으로 수행하도록 설계되며, 다른 모듈과 별개로 동작할 수 있습니다.  \n모듈의 역할 모듈은 사용자의 요청에 따른 특정 기능을 직접 수행합니다. 모듈은 특정 기능이나 작업을 독립적으로 수행하는 구성 요소입니다. 각 모듈은 전문화된 기능을 담당하며, 에이전트의 지시에 따라 협력하여 최종 목표를 달성합니다.  예를 들어, 검색 모듈은 외부 데이터 소스에서 관련 정보를 검색하고, 생성 모듈은 최종 응답을 생성하는 역할, 데이터 전처리, 텍스트 생성 등의 개별 기능을 담당할 수 있습니다.   \n모듈의 특징 ● 독립성 및 모듈화: 모듈은 독립적인 단위로 설계되어 다른 모듈과 별개로 작동할 수 있으며, 모듈화된 구조를 유지합니다. ● 전문화: 각 모듈은 특정 작업이나 기능에 집중하여 해당 분야에서 최적화되고 전문성을 갖출 수 있습니다. ● 재사용성 및 유연성: 모듈은 시스템 내에서 재사용할 수 있으며, 필요에 따라 쉽게 수정, 교체, 확장할 수 있습니다. 또한, 다른 프로젝트에서도 활용할 수 있습니다. ● 확장성: 새로운 기능이나 서비스가 필요할 경우, 기존 모듈을 확장하거나 새로운 모듈을 추가하여 시스템을 발전시킬 수 있습니다. ● 조합성: 여러 모듈을 결합하여 복잡한 작업을 처리하거나 새로운 기능을 추가할 수 있습니다.\n모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다."
          ],
          "40": [
            "5. 순위 조정(Re-rank) ● 검색된 데이터를 신뢰도 및 관련성에 따라 재정렬 6. 감성 분석(Sentiment Analysis) ● 뉴스 및 소셜 미디어의 감성 분석을 통해 투자 심리 평가 ● 예시: \"테슬라 주가가 최근 하락했지만 소셜 미디어에서 긍정적인 분위기가 나타나 단기 회복 가능성이 있음\" 7. 가중 융합(Weighted Fusion) ● 각 데이터 출처의 신뢰도를 기반으로 가중치를 부여하여 최적의 투자 보고서 생성 ● 예시: SEC 공식 공시 > 애널리스트 보고서 > 뉴스 > 소셜 미디어 (신뢰도 높은 순서) 8. 생성(Generation) ● AI 기반 투자 조언 및 시장 분석 제공 ● 예시: \"테슬라의 최근 분기 실적이 예상보다 높았지만 원자재 가격 상승이 향후 이익률에 압박을 가할 수 있음\" \n개선점 ● 자연어 질의를 SQL로 변환(Text-to-SQL)하여 사용자가 특정 금융 지표를 직접 검색할 수 있도록 지원 ● 애널리스트 보고서, 경제 뉴스, 소셜 미디어 감성 분석을 통합하여 투자 판단의 신뢰도 향상 ● 실시간 시장 반응을 분석하여 최신 경제 데이터를 자동 반영하는 적응형 검색 기능 구현  \n4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 목표 기존 전자상거래 추천 시스템은 주로 협업 필터링에 의존하지만, 개별 사용자의 취향과 실시간 검색 의도를 정확하게 반영하는 데 어려움이 있습니다. 이를 해결하기 위해 RRR(Rewrite-Retrieve-Read) 패턴 기반의 RAG 추천 시스템을 적용할 수 있습니다. 이 시스템은 사용자 질의를 최적화하고, 다양한 소스에서 관련 데이터를 검색하며, 실시간으로 개인화된 추천을 제공합니다. 또한, 강화 학습을 활용하여 추천 품질을 지속적으로 개선할 수 있습니다.",
            "● Fusion & Re-rank: 다중 검색 결과를 조합하고 가중치를 조정하여 최적의 답변을 생성 ● Text-to-SQL: 자연어 질의를 SQL 쿼리로 변환하여 구조화된 데이터에서 정밀 검색 수행 ● RRR (Rewrite-Retrieve-Read): 검색 질의를 효과적으로 변형(Rewrite) → 검색(Retrieve) 수행 → 검색된 정보를 해석(Read)하여 최적의 답변 생성 ● LLM Reward RL (LLM 보상 강화 학습): AI 모델이 사용자 상호작용 데이터를 학습하여 검색 및 추천 시스템을 지속적으로 개선 ● Adaptive Retrieval & Generation (적응형 검색 및 생성): 초기 검색 결과가 부족할 경우 추가 검색을 수행하고, 생성 모델이 정보를 보강하여 최적의 답변 제공 ● LLM Critique (LLM 비판적 평가): 생성된 응답의 신뢰도를 평가하고 오류를 수정하여 정확성을 보장 ● Hybrid Search (하이브리드 검색): Sparse 검색(BM25)과 Dense 검색(임베딩 검색)을 결합하여 검색 성능 최적화 RAG 기반 검색 시스템을 도메인별 특성에 맞춰 최적화하면, 의료, 법률, 금융, 전자상거래 등 다양한 분야에서 정확성, 신뢰성, 개인화, 실시간성을 극대화할 수 있습니다. 이 과정에서 Agent가 적절한 Module과 Operator를 조합하여 실행하는 방식이 중요한 역할을 하며, 이를 통해 복잡한 질의응답 프로세스를 효과적으로 처리할 수 있습니다. 이제부터는 각 도메인별로 최적화된 검색 및 생성 패턴이 어떻게 적용되는지 구체적인 사례를 살펴보겠습니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723"
          ],
          "41": [
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ],
          "42": [
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ],
          "43": [
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com"
          ],
          "44": [
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담 \n이 표를 통해 각 RAG 방법론의 특징을 비교하고, 프로젝트 목적과 요구사항에 맞는 최적의 방식을 선택하는 데 도움이 될 수 있습니다. Modular RAG는 높은 유연성과 확장성을 제공하여, 특히 복잡한 도메인 지식이 필요한 분야에서 강력한 성능을 발휘할 수 있습니다.\n3. Modular RAG의 주요 구성 요소 Modular RAG에서 계층구조의 구성 요소와 역할과 세부 내용을 알아봅니다. Agent Workflow Module 주요 프로세스(검색, 증강, 생성 등)를 담당 Submodule 모듈 내부에서 세부적인 작업 단계를 처리 Operator 데이터 처리 및 변환과 같은 기본적인 작업 단위를 수행 \n3.1 Agent 기반의 아키텍처 Modular RAG의 핵심 요소 중 하나는 Agent 기반 아키텍처입니다. 기존 AI 에이전트와 비교했을 때, Modular RAG의 에이전트는 다중 모듈을 조율하고 특정 작업을 수행하는 방식으로 설계됩니다. 이를 통해 보다 유연하고 확장 가능한 AI 시스템을 구축할 수 있습니다. \nAI Agent 아키텍처 AI 에이전트는 특정 목표를 달성하기 위해 환경에서 데이터를 감지하고, 해석하며, 행동하는 시스템입니다. AI 에이전트 아키텍처는 인공지능 시스템이 환경을 인식하고, 분석하며, 행동하는 방식을 정의하는 구조적 설계입니다. 이는 AI 에이전트가 자율적으로 작동하고 목표를 달성할 수 있도록 하는 핵심 요소를 포함하며, 다양한 구성 요소와 설계 패턴으로 이루어집니다.",
            "의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여 적절한 모듈을 호출하고 실행 순서를 조정하며, 필요할 경우 실행 도중 워크플로우를 변경할 수도 있습니다. AI 에이전트는 자율적으로 환경과 상호작용하며 특정 목표를 달성하기 위해 설계된 독립적인 시스템입니다. 에이전트는 데이터를 감지하고, 분석하며, 의사결정을 내리고, 행동을 수행하는 능력을 갖추고 있습니다. Tools는 Agent가 직접 호출할 수도 있고, 특정 모듈 내부에서 독립적인 기능을 수행할 수도 있습니다. 예를 들어, API 호출 기능을 수행하는 Tools는 모듈에서 직접 호출될 수 있으며, 경우에 따라 Agent가 직접 Tools를 실행하여 특정 기능을 수행할 수도 있습니다.",
            "Modular RAG에서 AI Agent 아키텍처 Modular RAG(Retrieval-Augmented Generation) 기반 AI 시스템은 정보 검색(Retrieval)과 생성(Generation)을 기능을 모듈화하여 구성된 구조로, 여러 독립적인 모듈을 조합하여 유연하고 확장 가능한 AI를 구축하는 방식입니다. 이 시스템의 핵심 구성 요소는 에이전트(Agent) 모듈(Modules)입니다. 에이전트(Agent)는 전체 워크플로우를 조율하여, 전체시스템의 흐름과 전략적 제어를 담당하는 핵심 역할을 합니다. 기존의 LLM(대규모 언어 모델)이 주로 사전 학습된 지식과 인컨텍스트 학습에 의존하는 것과 달리, 에이전트는 외부 도구(예: 웹 검색, API, 구조화된 데이터베이스)와 동적으로 상호작용하여 그 능력을 확장합니다. 에이전트는 주어진 작업에 따라 어떤 도구를 호출할지 자율적으로 결정하며, 이를 통해 더 정확하고 상황에 맞는 응답을 생성할 수 있습니다. 또한, 에이전트는 고급 라우팅 메커니즘을 활용하여 사용자 쿼리를 분석하고 가장 적합한 데이터 소스나 처리 경로로 안내합니다. 예를 들어, 특정 데이터베이스에서 정보를 검색해야 하는지, 웹 검색을 수행해야 하는지, 또는 도메인 특화 지식을 활용해야 하는지를 스스로 판단할 수 있습니다."
          ],
          "45": [
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "Modular RAG에서 AI Agent 아키텍처 Modular RAG(Retrieval-Augmented Generation) 기반 AI 시스템은 정보 검색(Retrieval)과 생성(Generation)을 기능을 모듈화하여 구성된 구조로, 여러 독립적인 모듈을 조합하여 유연하고 확장 가능한 AI를 구축하는 방식입니다. 이 시스템의 핵심 구성 요소는 에이전트(Agent) 모듈(Modules)입니다. 에이전트(Agent)는 전체 워크플로우를 조율하여, 전체시스템의 흐름과 전략적 제어를 담당하는 핵심 역할을 합니다. 기존의 LLM(대규모 언어 모델)이 주로 사전 학습된 지식과 인컨텍스트 학습에 의존하는 것과 달리, 에이전트는 외부 도구(예: 웹 검색, API, 구조화된 데이터베이스)와 동적으로 상호작용하여 그 능력을 확장합니다. 에이전트는 주어진 작업에 따라 어떤 도구를 호출할지 자율적으로 결정하며, 이를 통해 더 정확하고 상황에 맞는 응답을 생성할 수 있습니다. 또한, 에이전트는 고급 라우팅 메커니즘을 활용하여 사용자 쿼리를 분석하고 가장 적합한 데이터 소스나 처리 경로로 안내합니다. 예를 들어, 특정 데이터베이스에서 정보를 검색해야 하는지, 웹 검색을 수행해야 하는지, 또는 도메인 특화 지식을 활용해야 하는지를 스스로 판단할 수 있습니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다."
          ],
          "46": [
            "2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다. \n주요 전략 사전 검색 처리 (Pre-retrieval processing): ● 쿼리 재작성(query rewriting): 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. ● 쿼리 확장(query expansion): 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다. ● 쿼리 변환(query transformation): 원래 쿼리 대신 변환된 쿼리를 기반으로 검색 및 생성을 수행합니다.\n사후 검색 처리 (Post-retrieval processing): ● 검색 결과 재정렬(reranking): 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다. ● 압축(compression): 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다. ● 선택(selection): 관련 없는 덩어리를 직접 제거하여 LLM의 추론 효율성을 향상시킵니다.  \n특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징"
          ],
          "47": [
            "● Fusion & Re-rank: 다중 검색 결과를 조합하고 가중치를 조정하여 최적의 답변을 생성 ● Text-to-SQL: 자연어 질의를 SQL 쿼리로 변환하여 구조화된 데이터에서 정밀 검색 수행 ● RRR (Rewrite-Retrieve-Read): 검색 질의를 효과적으로 변형(Rewrite) → 검색(Retrieve) 수행 → 검색된 정보를 해석(Read)하여 최적의 답변 생성 ● LLM Reward RL (LLM 보상 강화 학습): AI 모델이 사용자 상호작용 데이터를 학습하여 검색 및 추천 시스템을 지속적으로 개선 ● Adaptive Retrieval & Generation (적응형 검색 및 생성): 초기 검색 결과가 부족할 경우 추가 검색을 수행하고, 생성 모델이 정보를 보강하여 최적의 답변 제공 ● LLM Critique (LLM 비판적 평가): 생성된 응답의 신뢰도를 평가하고 오류를 수정하여 정확성을 보장 ● Hybrid Search (하이브리드 검색): Sparse 검색(BM25)과 Dense 검색(임베딩 검색)을 결합하여 검색 성능 최적화 RAG 기반 검색 시스템을 도메인별 특성에 맞춰 최적화하면, 의료, 법률, 금융, 전자상거래 등 다양한 분야에서 정확성, 신뢰성, 개인화, 실시간성을 극대화할 수 있습니다. 이 과정에서 Agent가 적절한 Module과 Operator를 조합하여 실행하는 방식이 중요한 역할을 하며, 이를 통해 복잡한 질의응답 프로세스를 효과적으로 처리할 수 있습니다. 이제부터는 각 도메인별로 최적화된 검색 및 생성 패턴이 어떻게 적용되는지 구체적인 사례를 살펴보겠습니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "• 향상된 검색 기법: 질의 처리 후 하이브리드 검색(밀도 기반 임베딩 검색 + 희소 키워드 검색)을 활용해 더 풍부한 결과를 얻습니다 ibm.com . 복잡한 질문의 경우 계층적 인덱싱이나 다단계 검색(예: iterative/recursive retrieval)으로 한층 심화된 검색을 수행하여 정확도를 높입니다 arxiv.org  arxiv.org . \n• 다중 모듈 검색: 질의 종류와 목적에 따라 여러 검색 모듈을 조합합니다. 예를 들어, 임베딩 기반 벡터 검색에 더해 지식 그래프 질의나 API 호출 등 이기종 데이터 검색을 병행할 수 있습니다. 또한 복잡한 문제에 대해 반복적 검색이나 분기 검색 흐름을 구현하여 필요한 정보를 순차적으로 수집할 수 있습니다 arxiv.org . 이러한 유연한 검색 설계로 질의의 의도에 맞게 다양한 소스에서 정보를 획득합니다. 모델 아키텍처 (Model Architecture) • 선형 파이프라인 구조: 인덱싱 → 검색 → 생성의 직렬 단계로 구성된 가장 단순한 형태입니다 arxiv.org . 별도의 최적화 모듈이나 피드백 루프 없이, 검색기와 한 번의 생성기로 답변을 생성합니다. 전체 구조가 단순하여 추가 구성요소가 없습니다. \n• 개선된 단일 흐름 구조: 기본 RAG 파이프라인에 전처리/후처리 모듈을 추가한 구조입니다. 예를 들어, 질의 재작성 모듈로 입력 질문을 명확히 하고 arxiv.org , 재검색 및 재정렬 모듈로 검색 결과를 필터링한 후 LLM에 전달합니다. 응답 생성 후에는 사용자 클릭이나 피드백 등을 활용한 피드백 루프를 도입해 검색기와 생성기를 지속적으로 개선하기도 합니다 \n• 모듈식 아키텍처: 여러 독립 모듈을 레고 블록처럼 연결하여 구성한 프레임워크입니다 arxiv.org . 질의 처리, 검색, 필터링, 생성, 검증 등의 기능이 분리된 모듈로 구현되고, 이들을 제어하는 라우팅/스케줄링 컴포넌트가 존재합니다 arxiv.org . 덕분에 비선형적 흐름도 가능하며 (예: 조건분기나",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다."
          ],
          "48": [
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담 \n이 표를 통해 각 RAG 방법론의 특징을 비교하고, 프로젝트 목적과 요구사항에 맞는 최적의 방식을 선택하는 데 도움이 될 수 있습니다. Modular RAG는 높은 유연성과 확장성을 제공하여, 특히 복잡한 도메인 지식이 필요한 분야에서 강력한 성능을 발휘할 수 있습니다.\n3. Modular RAG의 주요 구성 요소 Modular RAG에서 계층구조의 구성 요소와 역할과 세부 내용을 알아봅니다. Agent Workflow Module 주요 프로세스(검색, 증강, 생성 등)를 담당 Submodule 모듈 내부에서 세부적인 작업 단계를 처리 Operator 데이터 처리 및 변환과 같은 기본적인 작업 단위를 수행 \n3.1 Agent 기반의 아키텍처 Modular RAG의 핵심 요소 중 하나는 Agent 기반 아키텍처입니다. 기존 AI 에이전트와 비교했을 때, Modular RAG의 에이전트는 다중 모듈을 조율하고 특정 작업을 수행하는 방식으로 설계됩니다. 이를 통해 보다 유연하고 확장 가능한 AI 시스템을 구축할 수 있습니다. \nAI Agent 아키텍처 AI 에이전트는 특정 목표를 달성하기 위해 환경에서 데이터를 감지하고, 해석하며, 행동하는 시스템입니다. AI 에이전트 아키텍처는 인공지능 시스템이 환경을 인식하고, 분석하며, 행동하는 방식을 정의하는 구조적 설계입니다. 이는 AI 에이전트가 자율적으로 작동하고 목표를 달성할 수 있도록 하는 핵심 요소를 포함하며, 다양한 구성 요소와 설계 패턴으로 이루어집니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담"
          ],
          "49": [
            "6. Conclusion 이 리포트에서는 RAG(Retrieval-Augmented Generation)의 발전 방향을 분석하기 위해, 최근 주목받고 있는 Modular RAG를 중심으로 기존 RAG 패러다임(Naive RAG, Advanced RAG)과 비교하고, 새롭게 등장한 GraphRAG까지 다루었습니다. RAG는 LLM의 한계를 보완하며, 보다 신뢰할 수 있는 검색과 응답 생성을 목표로 발전해왔습니다. 기존 Naive RAG는 단순 검색 기반이었으며, Advanced RAG는 검색 최적화를 추가하여 성능을 향상시켰습니다. 이후 Modular RAG는 검색, 생성, 색인 기능을 독립적인 모듈로 분리하여 유연성과 확장성을 극대화하는 구조로 발전했습니다.  그러나 여전히 검색된 정보의 신뢰성과 정확성을 높이는 것이 중요한 과제로 남아 있으며, 이를 해결하기 위해 GraphRAG가 도입되었습니다. GraphRAG는 기존 벡터 검색의 한계를 보완하기 위해 지식 그래프(Knowledge Graph)를 활용한 검색 방식을 도입하여, 문서 간의 관계를 반영한 보다 정밀한 정보를 제공합니다. LinkedIn 사례에서는 GraphRAG 도입 후 검색 정확도 77.6% 향상, BLEU 점수 0.32 증가, 고객 서비스 해결 시간이 28.6% 단축되는 성과를 거두었습니다. 기존 RAG는 벡터 검색(Vector RAG)에 의존했지만, 최근 GraphRAG, Adaptive Retrieval, Multi-Agent RAG 등의 개념이 등장하며 검색 정확도, 신뢰성, 실시간성, 맥락 최적화가 더욱 강화되고 있습니다. 현재까지의 발전 흐름을 보면, 앞으로는 검색 전략을 스스로 최적화하는 자율적 검색 시스템까지 발전될 수 있는 가능성이 있습니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "• 향상된 검색 기법: 질의 처리 후 하이브리드 검색(밀도 기반 임베딩 검색 + 희소 키워드 검색)을 활용해 더 풍부한 결과를 얻습니다 ibm.com . 복잡한 질문의 경우 계층적 인덱싱이나 다단계 검색(예: iterative/recursive retrieval)으로 한층 심화된 검색을 수행하여 정확도를 높입니다 arxiv.org  arxiv.org . \n• 다중 모듈 검색: 질의 종류와 목적에 따라 여러 검색 모듈을 조합합니다. 예를 들어, 임베딩 기반 벡터 검색에 더해 지식 그래프 질의나 API 호출 등 이기종 데이터 검색을 병행할 수 있습니다. 또한 복잡한 문제에 대해 반복적 검색이나 분기 검색 흐름을 구현하여 필요한 정보를 순차적으로 수집할 수 있습니다 arxiv.org . 이러한 유연한 검색 설계로 질의의 의도에 맞게 다양한 소스에서 정보를 획득합니다. 모델 아키텍처 (Model Architecture) • 선형 파이프라인 구조: 인덱싱 → 검색 → 생성의 직렬 단계로 구성된 가장 단순한 형태입니다 arxiv.org . 별도의 최적화 모듈이나 피드백 루프 없이, 검색기와 한 번의 생성기로 답변을 생성합니다. 전체 구조가 단순하여 추가 구성요소가 없습니다. \n• 개선된 단일 흐름 구조: 기본 RAG 파이프라인에 전처리/후처리 모듈을 추가한 구조입니다. 예를 들어, 질의 재작성 모듈로 입력 질문을 명확히 하고 arxiv.org , 재검색 및 재정렬 모듈로 검색 결과를 필터링한 후 LLM에 전달합니다. 응답 생성 후에는 사용자 클릭이나 피드백 등을 활용한 피드백 루프를 도입해 검색기와 생성기를 지속적으로 개선하기도 합니다 \n• 모듈식 아키텍처: 여러 독립 모듈을 레고 블록처럼 연결하여 구성한 프레임워크입니다 arxiv.org . 질의 처리, 검색, 필터링, 생성, 검증 등의 기능이 분리된 모듈로 구현되고, 이들을 제어하는 라우팅/스케줄링 컴포넌트가 존재합니다 arxiv.org . 덕분에 비선형적 흐름도 가능하며 (예: 조건분기나",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ]
        },
        "response": {
          "0": "RAG는 **Retrieval-Augmented Generation**의 약자입니다.",
          "1": "RAG의 세 가지 핵심 요소는 다음과 같습니다.\n\n1.  **색인 (Indexing):** 문서를 검색 가능한 벡터로 변환합니다.\n2.  **검색 (Retrieval):** 사용자의 질의에 기반하여 관련 문서를 검색합니다.\n3.  **생성 (Generation):** 검색된 데이터를 활용하여 LLM이 응답을 생성합니다.\n\n이 세 가지 요소는 서로 연관되어 작동하며, RAG 시스템의 핵심적인 구성 요소입니다.",
          "2": "Naive RAG의 핵심 구성 요소는 다음과 같습니다.\n\n1.  **색인 (Indexing):** 텍스트 데이터를 저장하고 검색하기 위한 시스템입니다.\n2.  **검색 (Retrieval):** 사용자의 질문에 대한 관련 문서를 찾아서 제공합니다.\n3.  **생성 (Generation):** 질문에 대한 답변을 생성합니다.\n4.  **구성기 (Organizer):** 검색된 정보를 정리하고, 노이즈를 제거하여 답변 품질을 향상시킵니다.\n5.  **그래프 데이터 소스 (Graph Data Source):** 다양한 유형의 지식 그래프를 활용하여 검색 및 생성 과정을 지원합니다. (예: 지식 그래프, 문서 그래프, 과학 그래프 등)\n\n요약하자면, Naive RAG는 색인, 검색, 생성, 구성, 그래프 데이터 소스이라는 5가지 핵심 요소로 구성되어 있습니다.",
          "3": "Naive RAG는 단순한 유사성 기반 검색을 통해 정보를 얻는 방식입니다. 핵심적인 작동 방식은 다음과 같습니다.\n\n1. **질의 입력:** 사용자가 질문을 입력합니다.\n2. **임베딩 생성:** 질문을 텍스트 임베딩으로 변환합니다. (예: OpenAI의 GPT 모델을 사용하여 텍스트를 임베딩으로 변환)\n3. **검색:** 변환된 임베딩을 사용하여 데이터베이스(예: ChromaDB, Pinecone 등)에서 유사도가 높은 문서들을 찾습니다.  이 과정에서 단순히 유사성 점수를 계산하는 것뿐만 아니라, 문맥을 고려하여 검색합니다.\n4. **결과 제시:** 가장 관련성이 높은 문서들을 제시합니다.\n\n**핵심 특징:**\n\n*   **단순 유사성:** 유사성 점수를 기반으로 검색합니다.  즉, 문장이나 단어의 의미가 유사하면 해당 문서를 찾습니다.\n*   **고정된 워크플로우:** 검색 후 생성(Retrieve-then-Generate)이라는 고정된 순서로 정보를 처리합니다.\n*   **낮은 유연성:** 사용자가 검색 전략을 세밀하게 조정할 수 없습니다.\n\n**간단히 말하면, Naive RAG는 질문에 가장 적합한 문서를 찾기 위해 유사한 문서를 검색하고, 그 중에서 가장 관련성이 높은 문서를 선택하는 방식입니다.**\n\n**참고:** Naive RAG는 비교적 간단하고 구현하기 쉬운 방식이지만, 복잡한 질문이나 맥락을 고려해야 하는 경우에는 성능이 떨어질 수 있습니다.\n\n더 자세한 내용은 다음 자료를 참고하시면 좋습니다.\n\n*   [Naive RAG: A Simple and Efficient Retrieval-Augmented Generation Approach](https://arxiv.org/pdf/2501.09136v1)\n*   [Advanced RAG: Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선](https://medium.com/drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e)\n\n이 외에도 다양한 연구 자료들이 존재합니다.",
          "4": "Naive RAG의 한계 중 'Shallow Query Understanding'은 한국어로 **단순한 질의 이해** 또는 **키워드 기반 이해**라고 합니다. \n\n좀 더 자세히 설명하자면, Naive RAG는 키워드나 벡터 기반의 유사성 매칭에 의존하기 때문에, 질문의 의도를 정확하게 파악하지 못하고, 질문의 핵심 의미를 제대로 반영하지 못한다는 의미입니다.",
          "5": "Advanced RAG에서 도입된 사전 검색 처리 기법은 다음과 같습니다.\n\n1.  **쿼리 재작성 (Query Rewriting):**\n    *   **목표:** 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다.\n    *   **방법:** 쿼리를 분석하여 불필요한 단어, 문장 구조, 또는 의미적 불일치를 제거합니다. 쿼리를 재구성하여 검색 엔진이 더 정확하게 이해할 수 있도록 돕습니다.\n    *   **예시:** \"자동차\"라는 쿼리를 \"현대 쏘나타 가격\"으로 재작성합니다.\n\n2.  **제한적인 프로세스 제어 (Limited Process Control):**\n    *   **목표:** 사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있도록 합니다.\n    *   **방법:** 사용자가 검색 결과에 대한 우선순위를 설정하거나, 특정 문서 유형을 강조하거나, 응답 생성 방식에 대한 제어를 제공합니다.\n    *   **예시:** 사용자가 \"고양이\"라는 쿼리에 대해 \"반려동물\" 또는 \"고양이 사진\"을 우선적으로 검색하도록 설정할 수 있도록 합니다.\n\n이러한 사전 검색 처리 기법들을 통해 Advanced RAG는 쿼리의 의미를 더 정확하게 파악하고, 검색 결과의 품질을 향상시키고 있습니다.",
          "6": "Advanced RAG의 사후 검색 처리 기법은 다음과 같습니다.\n\n1.  **재정렬 (Reranking):** 이 기법은 검색된 문서의 순위를 재조정하여 더 중요한 문서 덩어리의 가시성을 높이는 데 중점을 둡니다. 검색된 덩어리의 내용을 변경하지 않고도 검색 정확도를 높이는 데 효과적입니다. 예를 들어, 검색된 문서의 내용을 분석하여 중요한 문서를 다시 검색하거나, 검색된 문서의 길이를 줄이는 등의 조치를 취할 수 있습니다.\n\n2.  **계층적 인덱싱 (Hierarchical Indexing):** 이 기법은 검색된 문서들을 계층적으로 정렬하여 검색 효율성을 높입니다. 예를 들어, 검색된 문서들을 여러 계층으로 나누어 각 계층에 대한 검색을 수행하고, 검색 결과의 우선순위를 조정합니다. 이를 통해 사용자는 검색 결과의 관련성을 더 쉽게 파악할 수 있습니다.\n\n이러한 기법들은 Advanced RAG의 초기 설계 난이도를 낮추고, 사용자에게 더 유연한 검색 경험을 제공하는 데 기여합니다.",
          "7": "Modular RAG의 핵심 개념은 다음과 같습니다.\n\n**1. 독립적인 모듈과 특수 연산자:**\n\n*   **모듈:** 각 기능(검색, 증강, 생성 등)을 담당하는 독립적인 구성 요소입니다. 예를 들어, 웹 검색 모듈, 관계형 데이터베이스 모듈, 지식 그래프 모듈 등이 있습니다.\n*   **특수 연산자:** 각 모듈의 특정 작업을 수행하는 역할을 담당하는 코드 블록입니다.\n\n**2. Agent 기반 아키텍처:**\n\n*   **Agent:**  AI 에이전트라는 이름에서 알 수 있듯이, 특정 목표를 달성하기 위해 설계된 인공지능 구성 요소입니다.\n*   **역할:**  특정 작업을 수행하도록 설계된 에이전트의 역할과 책임이 정의됩니다.\n*   **자율적 상호작용:** 에이전트는 외부 도구(검색 엔진, 데이터베이스 등)와 상호작용하며, 이를 통해 시스템을 조율하고 최적의 결과를 도출합니다.\n\n**3. 유연하고 확장 가능한 프레임워크:**\n\n*   **다중 데이터 소스 통합:**  기존 RAG의 한계를 극복하고, 다양한 데이터 소스를 활용하여 지식을 보강합니다.\n*   **동적 워크플로우:**  질의의 복잡성과 의도에 따라 워크플로우를 조정하여 효율성을 높입니다.\n*   **향상된 제어 및 사용자 맞춤 설정:**  개발자와 시스템 설계자가 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 세밀하게 조정할 수 있도록 합니다.\n\n**4.  추론 및 라우팅 프레임워크 활용:**\n\n*   **ReAct 프로세스:**  Reasoning (추론) + Acting (행동) 프로세스를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다.\n\n**요약하자면, Modular RAG는 독립적인 모듈과 Agent를 통해 유연하고 확장 가능한 시스템을 구축하는 것을 목표로 합니다.  이를 통해 다양한 데이터 소스를 활용하고, 사용자 요구에 따라 워크플로우를 조정하며, AI 에이전트의 자율적인 의사결정을 가능하게 합니다.**\n\n이러한 핵심 개념들을 통해 Modular RAG는 기존 RAG의 한계를 극복하고, 더욱 강력하고 유연한 AI 시스템을 구축할 수 있도록 돕습니다.",
          "8": "## Modular RAG 3단계 구조 (예시)\n\nModular RAG는 핵심적인 프로세스들을 3단계로 구성하여 효율성과 유연성을 높입니다. 각 단계는 서로 연관되어 있으며, 데이터 처리, 정보 추출, 그리고 최종 답변 생성 과정을 거칩니다.\n\n**1. Retrieval (검색) 단계:**\n\n* **역할:** 검색된 문서들을 효율적으로 수집하고, 관련성 높은 정보를 추출합니다.\n* **주요 작업:**\n    * **문서 수집:**  검색 엔진 (예: 웹 스크래퍼, API 호출)을 통해 검색 대상 문서들을 수집합니다.\n    * **문서 정제:**  불필요한 정보 제거, 중복 제거, 오류 수정 등 문서 품질을 향상시킵니다.\n    * **문서 필터링:**  특정 조건에 맞는 문서만 선택합니다. (예: 특정 키워드 포함, 특정 주제 관련)\n    * **문서 랭킹:**  문서의 관련성 및 중요도를 평가하여 검색 결과의 순위를 결정합니다.\n* **기능:**\n    * **검색 엔진 연동:**  다양한 검색 엔진 (예: 웹 스크래퍼, API)과 연동합니다.\n    * **문서 저장:**  수집된 문서들을 효율적으로 저장하고 관리합니다.\n    * **검색 결과 관리:**  검색 결과의 품질을 유지하고, 필요에 따라 재검색합니다.\n\n**2. Augmentation (증강) 단계:**\n\n* **역할:** 검색된 문서의 정보를 활용하여, 답변 생성에 필요한 추가적인 정보를 생성합니다.\n* **주요 작업:**\n    * **정보 추출:**  문서에서 핵심 정보를 추출합니다. (예: 핵심 키워드, 중요한 사실, 데이터)\n    * **문맥 확장:**  문서의 내용을 바탕으로 질문에 대한 답변을 확장합니다.\n    * **추가 정보 생성:**  필요한 경우, 추가적인 정보를 생성합니다. (예: 예시, 설명, 관련 데이터)\n* **기능:**\n    * **정보 추출 모델 연동:**  정보 추출 모델 (예: Named Entity Recognition, Relation Extraction)과 연동합니다.\n    * **문맥 분석:**  문서의 문맥을 분석하여 정보 추출의 정확도를 높입니다.\n    * **답변 생성 엔진 연동:**  추출된 정보를 기반으로 답변 생성 엔진에 전달합니다.\n\n**3. Generation (생성) 단계:**\n\n* **역할:**  증강된 정보를 바탕으로 자연어 응답을 생성합니다.\n* **주요 작업:**\n    * **답변 생성:**  문제를 해결하거나 질문에 답변하는 자연어 응답을 생성합니다.\n    * **문장 구성:**  답변의 문장 구조를 구성합니다.\n    * **문장 완성:**  문장 완성 및 문법 검사 등을 수행합니다.\n* **기능:**\n    * **생성 모델 연동:**  생성 모델 (예: Transformer, GPT)과 연동합니다.\n    * **답변 품질 평가:**  생성된 답변의 품질을 평가합니다.\n    * **답변 조정:**  답변의 자연스러움, 정확성 등을 개선합니다.\n\n**핵심:** 이 3단계는 서로 영향을 주고받으며, 전체적인 답변 생성 과정을 진행합니다. 각 단계는 독립적으로 작동하지만, 서로 협력하여 최종적인 답변을 생성합니다.\n\n**참고:** 이 3단계 구조는 예시이며, 실제 구현 시에는 요구사항에 따라 조정될 수 있습니다. 예를 들어, 각 단계에서 사용되는 모델이나 알고리즘을 추가하거나, 단계 간의 연결을 강화할 수 있습니다.",
          "9": "## Module, Submodule, Operator의 역할 간략 설명\n\n다음은 각 요소의 역할을 간략하게 설명합니다.\n\n**1. Module (인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration):**\n\n* **역할:**  모듈은 **특정 기능을 수행하는 독립적인 단위**입니다.  각 모듈은 특정 작업을 수행하며, 전체 시스템의 특정 부분 역할을 담당합니다.\n* **예시:**\n    * **인덱싱:** 문서 청크를 최적화하는 역할\n    * **Pre-Retrieval:** 검색을 시작하기 전에 문서의 중요도를 평가하는 역할\n    * **Retrieval:**  검색된 문서에서 관련 정보를 추출하는 역할\n    * **Post-Retriever:**  추출된 정보를 바탕으로 답변을 생성하는 역할\n    * **Generation:**  생성된 답변을 생성하는 역할\n    * **Orchestration:** 전체 시스템의 흐름을 관리하고, 각 단계의 작업을 연결하는 역할\n\n**2. Submodule (데이터 검색 모듈, API 호출, 파싱 연산자, 데이터 필터링 연산자, 검색 결과 랭킹 연산자):**\n\n* **역할:**  모듈은 **더 작은 단위**로, 특정 작업을 수행하며, 다른 모듈과 **상호 작용**합니다.  모듈은 특정 기능을 수행하며, 다른 모듈의 기능을 보완하거나 확장합니다.\n* **예시:**\n    * **웹 스크래퍼 (Web Scraping):** 웹 페이지에서 데이터를 추출하는 역할\n    * **API 호출 (Tavily API):**  Tavily API를 사용하여 데이터를 가져오는 역할\n    * **파싱 연산자:** 데이터를 특정 형식으로 변환하는 역할\n    * **데이터 필터링 연산자:** 특정 조건에 맞는 데이터를 선택하는 역할\n    * **검색 결과 랭킹 연산자:** 검색 결과의 순위를 정렬하는 역할\n\n**3. Operator (Parser, Generator, Fine-tuning, Scheduling, Rerank, Fusion, Verification):**\n\n* **역할:**  **특정 작업을 수행하는 최소 단위**입니다.  각 Operator는 특정 기능을 수행하며, 다른 Operator와 **협력**하여 전체 시스템을 구성합니다.\n* **예시:**\n    * **Parser:** 데이터를 특정 형식으로 변환하는 역할 (예: 텍스트를 숫자 데이터로 변환)\n    * **Generator:**  새로운 데이터를 생성하는 역할 (예: 텍스트를 질문으로 변환)\n    * **Fine-tuning:**  모델을 특정 데이터에 맞게 조정하는 역할\n    * **Scheduling:**  각 단계의 작업을 시간 순서대로 정렬하는 역할\n    * **Rerank:**  검색 결과의 품질을 개선하는 역할\n    * **Fusion:**  LLM을 결합하여 더 강력한 성능을 얻는 역할\n    * **Verification:**  데이터의 정확성을 검증하는 역할\n\n**핵심:**\n\n* **모듈:**  특정 기능을 수행하는 독립적인 단위\n* **Submodule:**  모듈의 특정 기능을 수행하는 작은 단위\n* **Operator:**  특정 작업을 수행하는 최소 단위\n\n이러한 구성은 Modular RAG 아키텍처의 핵심이며, 각 요소가 서로 연관되어 전체적인 시스템을 구성합니다.\n\n이 설명이 도움이 되셨기를 바랍니다.",
          "10": "Modular RAG의 '오케스트레이션 모듈'은 RAG 시스템의 핵심적인 역할을 수행하며, 다음과 같은 주요 기능들을 가지고 있습니다.\n\n**1. 작업 분해 및 관리:**\n\n*   **작업 분해:** 모듈들은 특정 작업을 수행하도록 분리되어 있습니다. 예를 들어, '검색' 모듈은 문서 검색을 담당하고, '질의 확장' 모듈은 사용자의 질문을 이해하고 관련 정보를 추출합니다.\n*   **작업 순서 관리:** 오케스트레이션 모듈은 각 작업의 순서를 관리하고, 작업 간의 흐름을 제어합니다. 예를 들어, '검색' 모듈이 먼저 문서를 검색하고, 그 결과를 바탕으로 '질의 확장' 모듈이 질문을 이해하고, '생성' 모듈이 응답을 생성하는 방식으로 작동합니다.\n\n**2. 모듈 간의 협업 및 조정:**\n\n*   **상호 작용 제어:** 오케스트레이션 모듈은 모듈 간의 상호 작용을 관리하고, 각 모듈이 서로 어떻게 협력해야 하는지 정의합니다.\n*   **동적 경로 변경:**  시스템은 필요에 따라 모듈의 순서를 변경하거나, 각 모듈의 역할을 변경하여 최적의 결과를 도출할 수 있도록 합니다.\n*   **병렬 처리:**  모듈 간의 작업을 병렬로 처리하여 전체 처리 시간을 단축합니다.\n\n**3.  지속적인 최적화 및 학습:**\n\n*   **실시간 피드백:**  오케스트레이션 모듈은 사용자 피드백이나 시스템의 결과를 기반으로 작업의 효율성을 지속적으로 평가하고 개선합니다.\n*   **학습 및 조정:**  시스템은 학습을 통해 작업의 효율성을 개선하고, 새로운 작업에 대한 적응력을 높입니다.\n\n**4.  RAG 시스템의 유연성 및 확장성 향상:**\n\n*   **모듈 교체 및 변경:**  오케스트레이션 모듈은 필요에 따라 모듈을 교체하거나 변경하여 시스템의 기능을 확장하고 유연성을 높입니다.\n*   **새로운 기능 추가:**  새로운 모듈을 추가하여 시스템의 기능을 확장하고 새로운 데이터 소스를 통합할 수 있습니다.\n\n**요약:**\n\n오케스트레이션 모듈은 RAG 시스템의 전체적인 효율성을 높이고, 사용자에게 더 나은 응답을 제공하기 위한 핵심적인 역할을 수행합니다.  모듈 간의 협업, 작업 순서 관리, 지속적인 최적화 등을 통해 시스템의 성능과 유연성을 향상시키는 데 기여합니다.\n\n더 자세한 내용은 Modular RAG 공식 문서나 관련 자료를 참고하시면 도움이 될 것입니다.",
          "11": "Modular RAG의 동적 워크플로우 예시 패턴 세 가지는 다음과 같습니다. 각 패턴은 특정 상황에서 RAG 시스템이 어떻게 작동하는지 보여줍니다.\n\n1.  **조건부 라우팅 (Conditional Routing):**\n\n    *   **설명:** 이 패턴은 질문의 의도를 파악하고, 질문의 유형에 따라 적절한 데이터 소스를 선택하여 검색 및 처리 과정을 조정합니다.\n    *   **예시:**\n        *   **질문:** \"최근에 발표된 삼성의 새로운 스마트폰 모델에 대해 알려줘.\"\n        *   **라우팅:**  \"삼성 스마트폰 관련 정보\" 데이터 소스를 선택하고, 해당 데이터 소스에서 최신 정보를 검색합니다.\n        *   **변화:**  검색 결과가 특정 모델에 집중될 경우, \"삼성 스마트폰\" 관련 데이터 소스를 우선적으로 활용합니다.\n2.  **병렬 처리 (Fan-out/Fan-in):**\n\n    *   **설명:** 이 패턴은 여러 데이터 소스를 동시에 활용하여 검색 및 처리 과정을 분산합니다.\n    *   **예시:**\n        *   **질문:** \"고려대 연구 논문 검색\"\n        *   **병렬 처리:**  \"고려대 연구 논문\" 데이터 소스를 검색하고, 검색 결과가 있을 경우, \"고려대 연구 논문\" 데이터 소스에서 관련 정보를 추출하여 랭킹합니다.  검색 결과가 없을 경우, \"고려대 연구 논문\" 데이터 소스를 활용하지 않고, 다른 데이터 소스를 활용합니다.\n        *   **변화:**  검색 결과가 있을 경우, \"고려대 연구 논문\" 데이터 소스에서 특정 내용을 추출하여 랭킹합니다.\n3.  **순환 흐름 (Cyclic Workflow):**\n\n    *   **설명:** 이 패턴은 질문을 처리하는 동안, 시스템이 이전 단계의 결과를 기반으로 다음 단계로 이동합니다.\n    *   **예시:**\n        *   **질문:** \"최근 영화 트렌드 분석\"\n        *   **순환 흐름:**\n            1.  **검색:** \"최근 영화 트렌드\" 데이터 소스를 검색합니다.\n            2.  **증강:** 검색 결과에서 인기 있는 영화, 장르, 감독 등을 추출합니다.\n            3.  **생성:**  추출된 정보를 바탕으로 영화 추천 시스템을 구축합니다.\n            4.  **결과:** 추천된 영화를 생성합니다.\n        *   **변화:**  추천된 영화가 특정 유형의 영화를 보여주도록 시스템을 조정합니다.\n\n이러한 패턴들을 조합하여 Modular RAG 시스템을 구축하면, 다양한 유형의 질문에 대한 정확하고 유용한 답변을 제공할 수 있습니다.",
          "12": "Modular RAG에서 'Hybrid Search'는 BM25와 벡터 검색을 조합하여 최적화하는 검색 기법입니다. 좀 더 자세히 설명하면 다음과 같습니다.\n\n**1. BM25 (Best Matching 25):**\n\n*   **역할:** 검색된 문서의 순위를 평가하고, 가장 관련성이 높은 문서들을 Top-N으로 보여주는 데 사용됩니다.\n*   **특징:**  문서의 키워드와 관련성을 기반으로 순위를 매기는 알고리즘입니다.\n\n**2. 벡터 검색 (Vector Search):**\n\n*   **역할:**  문서의 내용을 벡터 형태로 변환하여, 유사도 계산을 통해 가장 유사한 문서들을 찾습니다.\n*   **특징:**  문서의 의미와 내용을 파악하여 검색 정확도를 높입니다.\n\n**Hybrid Search의 작동 방식:**\n\nHybrid Search는 BM25와 벡터 검색을 결합하여 다음과 같은 효과를 얻습니다.\n\n*   **BM25의 장점 활용:**  문서의 키워드와 관련성을 기반으로 검색의 초기 순위를 결정합니다.\n*   **벡터 검색의 장점 활용:**  문서의 의미와 내용을 파악하여, 더 정확하고 관련성 높은 문서들을 찾습니다.\n\n**결론적으로, Hybrid Search는 BM25를 기반으로 검색을 시작하고, 벡터 검색을 통해 검색 결과의 정확도를 높이는 방식으로 작동합니다.**\n\n**추가적으로, Modular RAG에서는 Hybrid Search를 다양한 방식으로 조정하고 최적화합니다.** 예를 들어, 특정 유형의 문서에 대해서는 BM25를 더 많이 사용하고, 다른 유형의 문서에는 벡터 검색을 더 많이 사용하는 방식으로 구성할 수 있습니다.\n\n이러한 Hybrid Search는 Modular RAG의 검색 성능을 향상시키는 핵심적인 요소 중 하나입니다.",
          "13": "Modular RAG의 'Pre-retrieval' 모듈의 Operator 예시는 다음과 같습니다.\n\n1.  **Operator: 웹 스크래퍼 (Web Scraping)**: 이 Operator는 특정 웹사이트에서 데이터를 추출하는 역할을 합니다. 웹 스크래퍼는 웹 페이지의 HTML, XML, JSON 등 다양한 형태의 데이터를 추출하여 데이터베이스나 API에 저장할 수 있도록 합니다.\n\n2.  **Operator: 데이터 필터링 연산자**: 이 Operator는 추출된 데이터의 특정 조건을 만족하는 데이터만 선택적으로 가져오도록 합니다. 예를 들어, 특정 키워드를 포함하는 데이터만 추출하거나, 특정 기간 동안 생성된 데이터만 추출하는 등의 작업을 수행할 수 있습니다.\n\n이 두 Operator는 'Pre-retrieval' 모듈의 핵심적인 역할을 수행하며, 데이터의 품질과 정확성을 높이는 데 기여합니다.",
          "14": "Retrieval 모듈의 Operator 중 하나로 **Sparse Search**를 선택하겠습니다.\n\n**Sparse Search Operator (Sparse Search)**\n\n*   **설명:** Sparse Search는 검색 결과의 일부만 사용하고, 전체 검색 결과에서 불필요한 부분을 제거하여 검색 속도를 높이고, 관련성 높은 결과를 얻는 데 초점을 맞춥니다.\n*   **작동 방식:**\n    *   **검색 쿼리:** 사용자가 입력한 질의를 기반으로 검색 쿼리를 생성합니다.\n    *   **스파이스 검색:** 쿼리를 기반으로, 검색 엔진에서 제공하는 스파이스 검색을 수행합니다. 스파이스 검색은 쿼리를 여러 개의 작은 부분으로 나누어 검색합니다.\n    *   **불필요한 정보 제거:** 검색 결과에서 불필요한 정보(예: 관련 없는 문서, 검색 엔진의 광고)를 제거합니다.\n    *   **결과 필터링:** 검색된 결과의 관련성을 평가하고, 가장 관련성이 높은 결과를 선택합니다.\n*   **장점:**\n    *   **속도 향상:** 불필요한 정보 제거를 통해 검색 속도를 향상시킵니다.\n    *   **정확도 향상:** 관련성이 높은 결과를 선택하여 검색 정확도를 높입니다.\n    *   **자원 효율성:** 검색에 필요한 자원을 절약합니다.\n*   **적용 시점:**  질의 응답의 정확도를 높이고, 검색 결과의 효율성을 개선하기 위해 사용될 수 있습니다.\n\n**추가 고려 사항:**\n\n*   **스파이스 검색 엔진:**  검색 엔진에 따라 스파이스 검색 방식이 달라질 수 있습니다.\n*   **필터링:**  검색 결과에 대한 필터링을 통해 검색 정확도를 높일 수 있습니다.\n*   **랭킹:**  검색 결과의 순위를 조정하여 검색 결과의 품질을 높일 수 있습니다.\n\n이러한 Operator를 조합하여 사용하면, Retrieval 모듈은 더욱 효과적으로 검색된 정보를 활용하여 사용자에게 정확하고 관련성 높은 답변을 제공할 수 있습니다.",
          "15": "Post-Retrieval 모듈의 Operator는 다음과 같습니다:\n\n*   **Re-rank (재정렬):** 검색된 청크를 다시 평가하여 품질을 향상시킵니다.\n*   **Compression (압축):** 청크를 압축하여 효율성을 높입니다.",
          "16": "Generation 모듈에서 사용되는 Operator 예시 두 가지는 다음과 같습니다.\n\n1.  **Generator Fine-tuning:** (생성 모델을 미세 조정) - 이 Operator는 생성된 텍스트의 품질을 향상시키기 위해 모델을 추가적으로 학습시키는 역할을 합니다. 특히, 특정 도메인이나 스타일의 텍스트를 생성하는 데 유용합니다.\n\n2.  **Routing:** (라우팅) - 이 Operator는 생성된 텍스트를 특정 목적에 맞게 라우팅하는 역할을 합니다. 예를 들어, 특정 질문에 대한 답변을 생성하거나, 특정 형식의 텍스트를 생성하는 데 사용될 수 있습니다.\n\n이 두 Operator는 Generation 모듈의 핵심적인 역할을 수행하며, 생성된 텍스트의 품질과 관련성을 높이는 데 기여합니다.",
          "17": "Modular RAG의 'Componentized Architecture'는 단순히 모듈을 분리하는 것을 넘어, **시스템의 유연성, 확장성, 유지보수성, 그리고 재사용성을 극대화**하는 핵심적인 장점입니다. 좀 더 자세히 풀어 설명하면 다음과 같습니다.\n\n**1. 유연성 및 확장성:**\n\n*   **모듈 간의 독립성:** 각 모듈은 특정 기능을 수행하며, 다른 모듈과 독립적으로 개발, 테스트, 배포될 수 있습니다.  예를 들어, 검색 모듈, 증강 모듈, 생성 모듈 등 각 모듈은 특정 작업에 특화되어 있어, 필요에 따라 다른 모듈을 추가하거나 수정하여 시스템을 확장할 수 있습니다.\n*   **새로운 기능 추가 용이:** 새로운 기능이나 개선 사항을 추가할 때, 기존 모듈을 수정하거나 새로운 모듈을 개발하는 것보다 훨씬 쉽습니다.  새로운 모듈을 추가하면 기존 시스템에 영향을 주지 않고 새로운 기능을 쉽게 구현할 수 있습니다.\n\n**2. 유지보수성 및 재사용성:**\n\n*   **단일 오류 감소:**  하나의 모듈에 문제가 발생하면 전체 시스템에 영향을 미치지 않고, 해당 모듈만 수정하면 됩니다.\n*   **모듈 재사용:**  다른 프로젝트나 시스템에서 특정 모듈을 재사용할 수 있습니다.  예를 들어, 검색 모듈을 다른 분야의 시스템에 재사용할 수 있습니다.\n*   **개발 효율성 향상:**  개발자는 특정 모듈에 집중하여 작업할 수 있으므로, 전체 시스템의 복잡성을 줄이고 개발 효율성을 높일 수 있습니다.\n\n**3.  자율적인 개발 및 테스트:**\n\n*   **테스트 용이성:** 각 모듈은 독립적으로 테스트될 수 있으므로, 시스템 전체의 안정성을 높일 수 있습니다.\n*   **개발 속도 향상:**  개발자는 특정 모듈에 집중하여 작업하므로, 전체 시스템 개발 속도를 높일 수 있습니다.\n\n**4.  AI 에이전트의 유연성:**\n\n*   **다양한 작업 수행:** Modular RAG는 AI 에이전트가 다양한 작업을 수행할 수 있도록 설계되었습니다.  각 모듈은 특정 작업에 특화되어 있지만, 전체 시스템을 조율하는 에이전트의 역할을 수행합니다.\n*   **자율적인 의사결정:** 에이전트는 환경을 인식하고 분석하여, 최적의 처리 경로를 결정하고, 적절한 도구를 호출하여 작업을 수행합니다.\n\n**결론적으로, Modular RAG의 'Componentized Architecture'는 시스템의 복잡성을 줄이고, 유연성을 높이며, 유지보수를 용이하게 만들어, AI 에이전트가 더 효과적으로 작동할 수 있도록 돕는 핵심적인 설계 원칙입니다.**\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "18": "Modular RAG의 다중 데이터 소스 통합은 핵심적인 특징 중 하나이며, 다음과 같은 이유로 가능합니다.\n\n**1. 데이터 소스 다양성 확보:**\n\n* **데이터의 폭넓은 활용:** Modular RAG는 다양한 데이터 소스(웹 스크래퍼, API, 데이터베이스, 문서 등)를 통합하여 지식 기반을 확장할 수 있습니다. 각 데이터 소스는 고유한 정보와 특성을 가지고 있으며, 이를 통합하면 더욱 풍부하고 정확한 지식을 얻을 수 있습니다.\n* **데이터의 활용도 증대:** 다양한 데이터 소스에 접근할 수 있게 되면, 데이터의 활용도를 높일 수 있습니다. 예를 들어, 웹 스크래퍼를 통해 최신 정보를 얻고, API를 통해 실시간 데이터를 활용하여 지식 업데이트를 지속적으로 수행할 수 있습니다.\n\n**2. 조건부 라우팅 및 유연한 워크플로우:**\n\n* **데이터 소스 기반 검색:** Modular RAG는 특정 데이터 소스에 대한 검색을 수행하고, 그 결과를 기반으로 검색 방향을 결정할 수 있습니다. 예를 들어, 특정 웹사이트에서 정보를 얻고, 그 정보를 바탕으로 특정 질문에 대한 답변을 생성할 수 있습니다.\n* **데이터 소스 연결:** 데이터 소스에 대한 연결을 설정하여, 특정 데이터 소스에 대한 검색을 자동화하고, 데이터 소스에 따라 검색 전략을 조정할 수 있습니다.\n* **병렬 처리 및 흐름 제어:** 다중 데이터 소스에 대한 검색을 병렬적으로 처리하고, 각 데이터 소스에서 얻은 정보를 기반으로 응답 생성 흐름을 제어할 수 있습니다.\n\n**3. 지식 확장 및 업데이트:**\n\n* **지속적인 데이터 통합:** Modular RAG는 새로운 데이터 소스를 지속적으로 통합하여 지식 기반을 확장할 수 있습니다.\n* **데이터 소스 업데이트:** 데이터 소스에 대한 연결을 유지하면서, 데이터 소스 업데이트를 자동으로 처리할 수 있습니다.\n\n**4. 사용자 맞춤형 검색 및 응답:**\n\n* **데이터 소스 기반 필터링:** 각 데이터 소스에 대한 필터링을 통해 검색 결과의 정확도를 높일 수 있습니다.\n* **데이터 소스 기반 랭킹:** 각 데이터 소스에 대한 랭킹을 통해 검색 결과의 순위를 조정하여 사용자에게 가장 관련성 높은 결과를 제공할 수 있습니다.\n\n**요약하자면, Modular RAG는 다양한 데이터 소스를 통합하여 지식 기반을 확장하고, 조건부 라우팅 및 유연한 워크플로우를 통해 사용자에게 맞춤형 검색 및 응답을 제공하는 데 핵심적인 역할을 합니다.**\n\n더 자세한 내용은 Modular RAG의 설계 문서 및 관련 자료를 참고하시면 도움이 될 것입니다.",
          "19": "LangGraph를 활용한 오케스트레이션은 다음과 같은 기능들을 제공합니다.\n\n1.  **유연한 워크플로우 구성:** LangGraph는 의사결정, 스케줄링, 데이터 융합 등 다양한 기법을 활용하여 복잡한 워크플로우를 구성하고 최적화합니다. 이를 통해 데이터 처리 과정을 더욱 효율적으로 만들 수 있습니다.\n\n2.  **지속적인 경로 변경:** LangGraph는 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고, 실행 중 동적으로 경로를 변경할 수 있도록 지원합니다. 이를 통해 데이터 소스에 따라 최적의 경로를 선택하고, 데이터 처리 과정을 더욱 유연하게 만들 수 있습니다.\n\n3.  **병렬 처리 (Fan-out/Fan-in):** LangGraph는 특정 데이터 소스에 집중하지 않고, 여러 데이터 소스를 동시에 활용하여 병렬 처리를 가능하게 합니다. 이를 통해 데이터 처리 속도를 향상시키고, 전체적인 처리 시간을 단축할 수 있습니다.\n\n4.  **순환 흐름 (Cyclic Workflow):** LangGraph는 데이터 소스 간의 상호작용을 최적화하고, 데이터 처리 과정을 순환적으로 진행하도록 지원합니다. 이를 통해 데이터 처리 과정을 더욱 효율적으로 만들 수 있습니다.\n\n5.  **지식 그래프 구축 및 관리:** LangGraph는 Intra-ticket 트리 파싱을 통해 텍스트 기반 티켓을 트리 구조로 변환하고, 이를 기반으로 지식 그래프를 구축합니다. 이를 통해 사용자 쿼리를 이해하고, 관련 정보를 빠르게 검색할 수 있도록 지원합니다.\n\n6.  **데이터 융합 (Fusion):** LangGraph는 다양한 데이터 소스를 융합하여 더욱 정확하고 풍부한 응답을 생성할 수 있도록 지원합니다.\n\n7.  **추론 및 정렬:** LangGraph는 데이터 소스에 대한 추론 및 정렬을 수행하여, 최적의 데이터 소스를 선택하고, 데이터 처리 과정을 효율적으로 만들 수 있도록 지원합니다.\n\n요약하자면, LangGraph를 활용한 오케스트레이션은 복잡한 워크플로우를 구성하고, 데이터 처리 과정을 유연하게 관리하며, 최적의 데이터 처리 경로를 구축하는 데 도움을 줍니다.",
          "20": "GraphRAG의 핵심 구성 요소 다섯 가지는 다음과 같습니다.\n\n1.  **쿼리 프로세서 (Query Processor):** 쿼리를 입력받아 분석하고, 쿼리의 의미를 파악하여 검색에 적합한 형태로 변환합니다.\n2.  **검색기 (Retriever):** 그래프 데이터 소스에서 관련 정보를 검색하고, 쿼리에 맞는 데이터를 추출합니다.\n3.  **구성기 (Organizer):** 검색된 그래프에서 노이즈를 제거하고, 불필요한 정보를 제거하여 검색 결과의 품질을 향상시킵니다.\n4.  **생성기 (Generator):** 검색된 정보를 바탕으로 답변을 생성합니다.\n5.  **그래프 데이터 소스 (Graph Data Source):** 지식 그래프, 문서 그래프, 과학 그래프 등 다양한 형태의 그래프 데이터를 저장하고 활용합니다.\n\n이 다섯 가지 구성 요소들이 서로 협력하여 GraphRAG의 핵심 기능을 수행합니다.",
          "21": "GraphRAG가 기존 RAG 대비 강화하는 주요 이점은 다음과 같습니다.\n\n**1. 지식 기반 검색의 정밀도 향상:**\n\n* **지식 그래프 활용:** GraphRAG는 지식 그래프를 활용하여 문서 간의 관계를 명확하게 파악하고, 이를 기반으로 검색 정확도를 높입니다.\n* **관계성 기반 검색:** 단순히 문서를 검색하는 것을 넘어, 문서 간의 관계를 분석하여 더 정확하고 관련성 높은 정보를 제공합니다.\n* **장기 추론 및 계획 지원:** 지식 그래프를 통해 과거 데이터와 현재 상황을 연결하여 장기적인 추론 및 계획을 지원합니다.\n\n**2. 정보 신뢰성 및 출처 명확화:**\n\n* **문서 출처 추적:** 지식 그래프를 통해 문서의 출처를 추적하고, 정보의 신뢰성을 높입니다.\n* **데이터 업데이트 용이:** 지식 그래프를 기반으로 정보를 지속적으로 업데이트할 수 있어, 최신 정보 반영이 용이합니다.\n* **출처 명확화:** 문서의 출처를 명확하게 파악하여 정보의 신뢰성을 높입니다.\n\n**3. 복잡한 질문 처리 능력 향상:**\n\n* **관계적 추론:** 지식 그래프를 활용하여 질문의 의미를 파악하고, 관련된 정보를 추출하여 답변을 생성합니다.\n* **다단계 추론:** 지식 그래프를 통해 여러 단계를 거쳐 답변을 생성할 수 있습니다.\n* **맥락 이해:** 지식 그래프를 통해 질문의 맥락을 이해하고, 더 정확한 답변을 제공합니다.\n\n**4. 사용자 경험 개선:**\n\n* **정확한 답변:** 지식 기반 검색을 통해 사용자에게 정확하고 관련성 높은 답변을 제공합니다.\n* **개인화된 정보:** 사용자 데이터를 활용하여 개인화된 정보를 제공합니다.\n* **효율적인 정보 탐색:** 지식 그래프를 통해 정보 탐색을 용이하게 합니다.\n\n**5. 다양한 활용 분야에서의 적용 가능성 확대:**\n\n* **법률:** 법률 문서의 관계성을 분석하여 법률 자문 및 판례 검색에 활용 가능\n* **의료:** 환자 데이터, 논문, 의학 지식 그래프를 활용하여 질병 진단, 치료 추천 등에 활용 가능\n* **금융:** 금융 데이터, 시장 정보, 규제 정보 등을 활용하여 투자 분석, 위험 관리 등에 활용 가능\n\n이러한 강점들을 통해 GraphRAG는 기존 RAG보다 더 강력하고 유용한 정보 검색 및 생성 시스템으로 자리매김하고 있습니다.",
          "22": "LinkedIn이 GraphRAG를 도입한 목적은 다음과 같습니다.\n\n* **검색 정확도 향상:** Knowledge Graph를 활용하여 검색 결과의 정확도를 높이고, 사용자에게 더 관련성 높은 정보를 제공합니다.\n* **개인화된 추천:** 사용자 데이터를 기반으로 개인화된 제품 추천을 제공하여 사용자 경험을 개선합니다.\n* **동적 질의 확장 (Query Expansion):** 사용자가 질문을 변경할 때마다 검색 결과를 자동으로 확장하여 더 많은 정보를 제공합니다.\n* **재랭킹 (Re-ranking):** 검색 결과의 순위를 조정하여 사용자에게 가장 관련성 높은 결과를 우선적으로 보여줍니다.\n* **다중 회차 대화 지원:**  사용자가 여러 단계의 질문을 할 때, 이전 질문과의 관계를 유지하여 더 자연스러운 대화 흐름을 제공합니다.\n* **데이터 통합 및 분석:** 다양한 데이터 소스(LinkedIn 데이터, 외부 데이터 등)를 통합하여 데이터 분석 및 인사이트를 얻습니다.\n* **Human-in-the-Loop 활용:** 사용자 개입을 통해 응답의 신뢰도를 높이고, 오류를 줄입니다.\n* **지속적인 개선:**  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합 등 다양한 기법을 최적화하여 시스템의 효율성을 높입니다.\n\n요약하자면, LinkedIn은 GraphRAG를 통해 검색 정확도를 높이고, 사용자 경험을 개선하며, 데이터 분석 및 인사이트를 얻는 것을 목표로 합니다.",
          "23": "LinkedIn 사례에서 GraphRAG 시스템이 이슈 해결 시간을 **28.6%** 단축했다는 내용이 제시되어 있습니다.",
          "24": "Naive RAG는 다양한 분야에서 활용될 수 있지만, 특히 다음과 같은 분야에서 뛰어난 성능을 보입니다.\n\n**1. 정보 검색 및 분석:**\n\n*   **법률 및 규정 검색:** 복잡한 법률 용어와 규정 내용을 이해하고, 관련 정보를 빠르게 검색하는 데 유용합니다.\n*   **의료 정보 검색:** 환자 기록, 논문, 의학 지식 등 의료 관련 정보를 검색하고, 질병 관련 정보를 제공하는 데 활용될 수 있습니다.\n*   **금융 정보 검색:** 시장 분석, 투자 전략, 위험 관리 등 금융 관련 정보를 검색하고, 투자 결정에 도움을 주는 데 사용될 수 있습니다.\n*   **기술 문서 검색:** 기술 문서, 보고서, 특허 등을 검색하고, 관련 정보를 요약하여 제공하는 데 활용될 수 있습니다.\n\n**2. 고객 지원 및 FAQ:**\n\n*   **고객 문의 응답:** 고객 문의 내용을 분석하고, FAQ와 관련된 정보를 제공하여 고객 만족도를 높일 수 있습니다.\n*   **제품 정보 검색:** 제품 설명, 사용 방법, 문제 해결 방법 등 제품 관련 정보를 검색하고, 고객에게 필요한 정보를 제공할 수 있습니다.\n\n**3. 콘텐츠 생성 및 요약:**\n\n*   **기사 요약:** 긴 기사를 요약하여 핵심 내용을 빠르게 파악할 수 있도록 돕습니다.\n*   **블로그 게시물 요약:** 블로그 게시물을 요약하여 독자에게 핵심 내용을 전달합니다.\n*   **자료 요약:** 보고서, 논문, 책 등 자료를 요약하여 핵심 내용을 빠르게 파악할 수 있도록 돕습니다.\n\n**4. 교육 및 학습:**\n\n*   **개인 맞춤형 학습 자료:** 학습자의 수준과 필요에 맞는 학습 자료를 추천하고, 학습 과정을 안내합니다.\n*   **질문 답변:** 학습자의 질문에 대한 답변을 제공하여 학습을 돕습니다.\n\n**5. 기타:**\n\n*   **데이터 분석:** 데이터에서 패턴을 추출하고, 의미 있는 정보를 발견하는 데 활용될 수 있습니다.\n*   **챗봇:** 사용자 질문에 대한 답변을 제공하고, 챗봇의 기능을 확장하는 데 활용될 수 있습니다.\n\n**핵심적으로, Naive RAG는 다음과 같은 특징을 가진 분야에 적합합니다.**\n\n*   **데이터의 양이 적거나 복잡한 데이터:**  단순한 유사성 기반 검색으로 빠르게 정보를 찾을 수 있습니다.\n*   **빠른 응답이 필요한 경우:**  생성 과정이 복잡하지 않아 빠르게 결과를 제공할 수 있습니다.\n*   **간단한 질의 응답:**  질의를 이해하고, 관련 정보를 제공하는 데 적합합니다.\n\n**주의:** Naive RAG는 높은 수준의 정보 검색이 필요하지 않으며, 정확한 정보 제공에는 한계가 있을 수 있습니다.  따라서, 답변의 정확성을 높이기 위해 추가적인 검증 및 필터링 과정이 필요합니다.\n\n더 자세한 정보는 다음 자료를 참고하시면 좋습니다.\n\n*   **IBM - Beyond the Training Set: Empowering LLMs to Seek Knowledge:** [https://blog.boxcars.ai/p/beyond-the-training-set-empowering](https://blog.boxcars.ai/p/beyond-the-training-set-empowering)\n*   **Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures:** [https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/](https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/)\n*   **Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG:** [https://arxiv.org/pdf/2501.09136v1](https://arxiv.org/pdf/2501.09136v1)\n\n이 정보가 Naive RAG를 적용하기에 도움이 되기를 바랍니다.",
          "25": "Advanced RAG는 특히 다음과 같은 도메인에서 활발하게 활용되고 있습니다.\n\n*   **법률 (Legal):** 법률 문서, 판례, 규정 등 복잡한 법률 정보 검색에 효과적입니다.\n*   **의료 (Healthcare):** 의료 기록, 논문, 의학 지식 등 의료 관련 정보 검색에 활용됩니다.\n*   **금융 (Finance):** 금융 보고서, 시장 분석, 규정 준수 등 금융 관련 정보 검색에 사용됩니다.\n*   **기술 (Technology):** 기술 문서, 연구 논문, 제품 설명 등 기술 관련 정보 검색에 유용합니다.\n*   **엔지니어링 (Engineering):** 설계 문서, 기술 보고서, 문제 해결 가이드 등 엔지니어링 관련 정보 검색에 활용됩니다.\n*   **교육 (Education):** 학습 자료, 교재, 시험 문제 등 교육 관련 정보 검색에 활용됩니다.\n\n**핵심적으로는 복잡하고 전문적인 정보 검색이 필요한 분야에서 높은 성능을 보입니다.**\n\n물론, 다양한 분야에서 활용되고 있지만, 위에 언급된 도메인들이 Advanced RAG를 활용하는 주요 분야라고 할 수 있습니다.",
          "26": "Modular RAG가 특히 강력한 성능을 발휘하는 분야는 다음과 같습니다. \n\n**1. 복잡한 데이터 처리 및 분석:**\n\n*   **지식 그래프 (Knowledge Graph) 기반 추론:** Modular RAG는 지식 그래프를 활용하여 데이터 간의 관계를 분석하고, 복잡한 추론을 수행하는 데 탁월합니다. 예를 들어, 금융 데이터 분석, 의료 정보 분석, 법률 문서 분석 등에서 복잡한 패턴과 관계를 파악하여 정확한 의사결정을 내리는 데 중요한 역할을 합니다.\n*   **다양한 데이터 소스 통합 및 처리:** Modular RAG는 여러 데이터 소스를 통합하고, 각 소스의 특징을 분석하여 데이터를 효과적으로 처리합니다. 예를 들어, 웹 데이터, 문서 데이터, 이미지 데이터 등 다양한 데이터 소스를 활용하여 분석 결과를 종합적으로 제공합니다.\n*   **데이터 정제 및 변환:** Modular RAG는 데이터의 품질을 향상시키기 위해 데이터 정제 및 변환 과정을 자동화합니다. 예를 들어, 불필요한 정보 제거, 데이터 형식 변환, 데이터 표준화 등을 수행하여 데이터 분석의 정확도를 높입니다.\n\n**2. 사용자 맞춤형 응답 생성:**\n\n*   **개인화된 응답 생성:** Modular RAG는 사용자 데이터를 기반으로 응답을 개인화합니다. 예를 들어, 사용자 선호도, 과거 행동, 현재 상황 등을 고려하여 맞춤형 응답을 제공합니다.\n*   **다양한 응답 형식 생성:** Modular RAG는 텍스트, 이미지, 비디오 등 다양한 형식의 응답을 생성합니다. 예를 들어, FAQ 응답, 제품 추천, 뉴스 요약 등 다양한 응답 형식을 제공합니다.\n*   **응답 생성 과정의 제어:** Modular RAG는 응답 생성 과정에 대한 제어를 제공합니다. 예를 들어, 응답의 어조, 스타일, 내용 등을 사용자 지정할 수 있습니다.\n\n**3. 유연하고 확장 가능한 시스템:**\n\n*   **모듈화된 구조:** Modular RAG는 독립적인 모듈로 구성되어 있어, 필요에 따라 특정 기능을 추가하거나 수정할 수 있습니다.\n*   **확장성:** Modular RAG는 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다.\n*   **다양한 워크플로우 지원:** Modular RAG는 다양한 워크플로우를 지원합니다. 예를 들어, 챗봇, 검색 엔진, 데이터 분석 등 다양한 워크플로우를 지원합니다.\n\n**4.  복잡한 질문 처리:**\n\n*   **의미론적 이해:** Modular RAG는 질문의 의미를 정확하게 이해하고, 질문의 의도를 파악합니다.\n*   **추론 및 지식 활용:** Modular RAG는 질문에 대한 답변을 생성하기 위해 지식 베이스를 활용하고, 추론을 수행합니다.\n*   **다양한 답변 형식:** Modular RAG는 질문에 대한 답변을 다양한 형식으로 제공합니다.\n\n**결론적으로, Modular RAG는 복잡한 데이터 처리, 사용자 맞춤형 응답 생성, 유연하고 확장 가능한 시스템 구축 등 다양한 측면에서 강력한 성능을 발휘하며, 특히 지식 그래프 기반 추론, 데이터 분석, 개인화된 응답 생성 등에서 뛰어난 성능을 보입니다.**\n\n더 자세한 정보가 필요하시면, 특정 분야나 사용 사례를 알려주시면 더욱 자세한 답변을 드릴 수 있습니다.",
          "27": "RAG의 발전 순서를 다음과 같이 나열할 수 있습니다.\n\n1.  **Naive RAG:** 가장 초기 형태의 RAG 모델로, 단순한 유사성 기반 검색을 수행합니다.\n2.  **Advanced RAG:** Naive RAG의 한계를 극복하기 위해 개선된 모델을 적용합니다.\n3.  **Modular RAG:** 검색, 생성, 그리고 데이터 통합을 위한 모듈화된 구조를 도입합니다.\n4.  **GraphRAG:** 그래프 구조를 활용하여 검색 정확도, 신뢰성, 실시간성, 맥락 최적화 등을 향상시키는 모델입니다.\n5.  **Adaptive Retrieval:** 검색 정확도를 높이기 위해 다양한 검색 전략을 적용합니다.\n6.  **Multi-Agent RAG:** 여러 개의 Agent를 활용하여 검색 및 생성 과정을 분담합니다.\n7.  **기타 발전 방향:**  RAG의 성능 향상을 위한 다양한 연구 및 기술 발전 (예:  Semantic Search, Contextualization 등)\n\n**참고:** 이 순서는 RAG의 현재 발전 방향을 보여주는 주요 단계입니다.  각 단계는 서로 연관되어 있으며, 지속적인 연구와 개선을 통해 RAG의 성능을 더욱 향상시키고 있습니다.",
          "28": "RAG의 주요 문제점 중 하나인 \"Hallucination\"은 **가짜 정보 생성**을 의미합니다. 쉽게 말해, RAG 시스템이 사실과 다른 정보를 마치 사실인 것처럼 생성하는 현상을 말합니다. \n\n좀 더 자세히 설명하자면, RAG는 쿼리에 대한 답변을 생성하기 위해 외부 데이터베이스(예: 웹 페이지, 문서 등)에서 정보를 검색하고, 그 정보를 바탕으로 답변을 만들어냅니다. 하지만 RAG 시스템은 단순히 검색된 정보를 바탕으로 답변을 생성하는 것이기 때문에, 때로는 사실과 다른 정보를 생성할 수 있습니다. \n\n**Hallucination의 원인:**\n\n* **검색 결과의 불확실성:** RAG 시스템은 검색 결과의 정확성을 판단하기 어렵기 때문에, 잘못된 정보를 생성할 가능성이 높습니다.\n* **문맥 이해 부족:** 쿼리와 검색 결과 간의 연결을 제대로 이해하지 못하면, 잘못된 정보를 생성할 수 있습니다.\n* **생성 과정의 오류:** 답변 생성 과정에서 오류가 발생하면, 잘못된 정보를 생성할 수 있습니다.\n* **데이터의 불확실성:** 검색된 데이터의 품질이 낮으면, Hallucination이 발생할 가능성이 높아집니다.\n\n**Hallucination의 영향:**\n\n* **정보 신뢰성 저하:** 사용자가 RAG 시스템의 답변을 믿지 못하게 만들 수 있습니다.\n* **오해 유발:** 사용자가 잘못된 정보를 얻게 만들 수 있습니다.\n* **신뢰성 문제:** RAG 시스템의 신뢰성을 떨어뜨릴 수 있습니다.\n\n**RAG에서 Hallucination을 줄이기 위한 노력:**\n\n* **Retrieval-Augmented Generation (RAG)의 개선:** 검색 결과의 정확성을 높이고, 답변 생성 과정에서 오류를 줄이기 위한 기술 개발\n* **Fact Verification:** 답변 생성 후 사실 여부를 검증하는 기술 적용\n* **Contextualization:** 쿼리와 검색 결과 간의 연결을 강화하여, 잘못된 정보를 생성하지 않도록 돕는 기술 적용\n\nRAG 시스템의 Hallucination 문제는 해결해야 할 중요한 과제이며, 지속적인 연구와 개선을 통해 해결해야 합니다.",
          "29": "Modular RAG의 '루프 패턴'은 검색 결과의 순환적인 흐름을 관리하고, 사용자에게 지속적인 가치 있는 정보를 제공하기 위한 핵심적인 메커니즘입니다. 좀 더 자세히 설명하면 다음과 같습니다.\n\n**루프 패턴의 핵심 목표:**\n\n* **지속적인 정보 제공:** 사용자에게 끊임없이 새로운 정보와 관련성을 제공하여, 검색 결과가 지루해지지 않도록 합니다.\n* **탐색 및 발견 촉진:** 사용자가 검색 결과에 갇히지 않고, 다양한 정보를 탐색하도록 유도합니다.\n* **사용자 참여 유도:** 사용자가 검색 과정에 적극적으로 참여하도록 하여, 정보에 대한 이해도를 높입니다.\n* **데이터 보존 및 활용:** 이전 대화 및 검색 이력을 기억하고, 이를 기반으로 더욱 정확하고 관련성 높은 정보를 제공합니다.\n\n**루프 패턴의 주요 처리 방식:**\n\n1. **역방향 탐색 (Reverse Exploration):**\n   - 사용자가 검색한 결과에서 시작하여, 이전 검색 결과와 관련된 정보를 다시 검색합니다.\n   - 이를 통해 사용자가 검색 과정에서 얻은 정보를 바탕으로, 더 깊이 있는 탐색을 가능하게 합니다.\n\n2. **루프 생성 (Loop Generation):**\n   - 사용자의 검색 패턴을 분석하여, 반복적인 검색을 유도하는 루프를 생성합니다.\n   - 예를 들어, 특정 주제에 대한 검색을 반복적으로 진행하거나, 특정 유형의 정보를 반복적으로 검색하는 경우 루프를 생성합니다.\n\n3. **루프 종료 및 전환 (Loop Termination & Transition):**\n   - 루프가 특정 조건 (예: 사용자가 특정 질문에 대한 답변을 얻는 경우)에 도달하면, 루프를 종료하고 다음 단계로 넘어갑니다.\n   - 루프 종료 시, 이전 검색 결과와 관련된 정보를 다시 검색하거나, 새로운 정보를 제공하여 사용자에게 새로운 관점을 제시합니다.\n\n4. **데이터 보존 및 활용 (Data Retention & Utilization):**\n   - 루프 패턴을 통해 얻은 정보를 이전 대화 및 검색 이력에 저장합니다.\n   - 이를 통해 사용자가 이전 검색 과정에서 얻은 정보를 바탕으로, 더욱 개인화된 검색 경험을 제공합니다.\n\n**구체적인 예시:**\n\n* **질문 기반 검색:** 사용자가 \"고양이 사진\"을 검색하면, Modular RAG는 \"고양이 사진\"과 관련된 이전 검색 결과, 관련 문서, 이미지 등을 다시 검색하여 사용자에게 더 많은 정보를 제공합니다.\n* **탐색 기반 검색:** 사용자가 \"여행\"을 검색하면, Modular RAG는 \"여행\"과 관련된 이전 검색 결과, 여행 관련 문서, 여행지 정보 등을 다시 검색하여 사용자에게 다양한 옵션을 제시합니다.\n\n**결론적으로, Modular RAG의 루프 패턴은 단순히 검색 결과를 반복하는 것이 아니라, 사용자의 탐색을 유도하고, 정보를 보존하며, 사용자 참여를 유도하는 핵심적인 메커니즘입니다.**\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "30": "조건부 패턴에서 사용되는 주요 기능은 다음과 같습니다.\n\n1.  **조건부 경로 결정:**\n    *   **조건:** 사용자가 제시하는 조건에 따라 RAG 파이프라인의 실행 순서를 결정합니다. 예를 들어, \"특정 키워드가 포함된 문서를 검색해줘\" 와 같이 사용자가 원하는 검색 결과를 정의할 수 있습니다.\n    *   **결과:** 특정 조건에 따라 다른 모듈을 선택적으로 실행하여 검색 및 생성 과정을 조정합니다.\n\n2.  **다양한 RAG 파이프라인 선택:**\n    *   **선택:** 조건에 따라 여러 RAG 파이프라인을 선택하여 실행합니다. 예를 들어, \"특정 문서에 대한 답변을 생성해줘\" 와 같이 특정 문서에 대한 답변을 생성하는 데 필요한 단계들을 분리하여 실행할 수 있습니다.\n\n3.  **반복적인 작업 수행:**\n    *   **반복:** 조건에 따라 여러 단계의 RAG 파이프라인을 반복적으로 실행합니다. 예를 들어, \"특정 문서에서 키워드를 추출하고, 그 키워드를 기반으로 답변을 생성해줘\" 와 같이 특정 단계를 여러 번 실행하여 답변을 생성할 수 있습니다.\n\n4.  **유연한 검색 및 생성:**\n    *   **맞춤형 검색:** 특정 조건에 따라 검색을 유연하게 조정합니다.\n    *   **맞춤형 생성:** 특정 조건에 따라 답변을 맞춤형으로 생성합니다.\n\n5.  **자동화된 워크플로우:**\n    *   **자동화:** 조건부 패턴을 통해 RAG 파이프라인을 자동화하여 효율적인 시스템 구축을 가능하게 합니다.\n\n**요약하자면, 조건부 패턴은 사용자가 원하는 결과를 얻기 위해 RAG 파이프라인을 유연하게 조합하고, 조건에 따라 실행 순서를 조절하는 기능을 제공합니다.**\n\n이러한 기능들을 통해 사용자는 특정 조건에 따라 RAG 시스템을 더욱 효과적으로 활용할 수 있습니다.",
          "31": "분기 패턴은 LinkedIn에서 제공하는 핵심적인 이점들을 다음과 같이 정리할 수 있습니다.\n\n**1. 정확도 향상 및 답변 품질 개선:**\n\n*   **심화 검색:** 이슈 티켓을 분기하여 각 부분에 집중적인 검색을 수행합니다. 이는 핵심 정보와 관련 내용을 더 정확하게 파악하여 답변의 품질을 높입니다.\n*   **정확한 정보 추출:** 각 분기에서 얻은 정보를 바탕으로 답변을 구성합니다.\n*   **오답 방지:** 질문의 의도를 정확히 파악하여 오답을 줄입니다.\n\n**2. 유연성 및 확장성 증대:**\n\n*   **모듈식 아키텍처:** 복잡한 질문에 대한 답변을 쉽게 구성하고 수정할 수 있습니다.\n*   **유연한 구성:** 필요한 부분만 선택적으로 활용하여 답변을 구성할 수 있습니다.\n*   **확장성:**  새로운 질문이나 정보에 쉽게 대응할 수 있습니다.\n\n**3. 효율성 및 비용 절감:**\n\n*   **단순화된 구조:** 복잡한 질문을 단순화하여 처리합니다.\n*   **효율적인 인덱싱:**  정보를 효율적으로 관리하고 검색합니다.\n*   **비용 절감:**  모델 처리 지연을 줄이고, 메모리 사용량을 최적화합니다.\n\n**4. 지속적인 개선:**\n\n*   **피드백 루프:** 사용자 피드백을 활용하여 모델을 지속적으로 개선합니다.\n*   **모델 재학습:**  최신 정보와 지식을 반영하여 모델을 업데이트합니다.\n*   **지식 그래프 활용:**  지식 그래프를 활용하여 정보의 연결성을 강화합니다.\n\n**5.  상호 연결된 그래프 구축:**\n\n*   **내재적 관계 유지:** 이슈 티켓을 연결하여 상호 연결된 그래프를 구축합니다.\n*   **고품질 데이터:**  데이터의 일관성을 유지하고, 불완전한 답변을 방지합니다.\n\n**요약하자면, 분기 패턴은 단순히 질문에 답하는 것을 넘어, 정보의 흐름을 파악하고, 정확하고 유용한 답변을 제공하기 위한 핵심적인 기술입니다.**\n\n이러한 이점들을 통해 LinkedIn은 고객 서비스 질문 답변의 정확성과 효율성을 크게 향상시키고 있습니다.",
          "32": "Tuning Pattern의 역할은 RAG 시스템의 성능을 최적화하고, 특정 요구사항에 맞춰 모델을 조정하는 데 중요한 역할을 합니다. 좀 더 자세히 설명하면 다음과 같습니다.\n\n**Tuning Pattern의 주요 역할:**\n\n1.  **검색 결과 품질 향상:**\n    *   **검색기 최적화:**  Tuning Pattern은 검색기(예: BM25, Dense Embeddings)를 미세 조정하여 검색 결과의 정확도와 재현율을 높입니다.\n    *   **추천 정확도 향상:**  사용자의 선호도를 정확하게 반영하고, 추천의 관련성을 높입니다.\n2.  **생성 결과 품질 향상:**\n    *   **생성기 미세 조정:**  생성(Generate) 모듈의 모델을 미세 조정하여, 답변의 자연스러움, 관련성, 정확성을 높입니다.\n    *   **답변 품질 향상:**  사용자의 질문에 대한 답변이 명확하고, 이해하기 쉽도록 합니다.\n3.  **시스템 전체 성능 최적화:**\n    *   **RAG 프로세스 최적화:**  검색, 생성, 융합 등 RAG 전체 과정을 최적화하여 시스템의 효율성을 높입니다.\n    *   **오류 감소:**  검색 과정에서 발생하는 오류를 줄이고, 시스템의 안정성을 향상시킵니다.\n\n**Tuning Pattern의 종류 (예시):**\n\n*   **검색기 미세 조정:**  검색기(예: BM25)의 파라미터를 조정하여 검색 결과의 정확도를 높입니다.\n*   **생성기 미세 조정:**  생성(Generate) 모듈의 모델을 미세 조정하여 답변의 품질을 높입니다.\n*   **융합 전략 최적화:**  검색 결과와 생성 결과의 융합 전략을 조정하여 시스템의 성능을 향상시킵니다.\n\n**요약:** Tuning Pattern은 RAG 시스템의 성능을 개선하기 위한 핵심적인 역할을 수행하며, 시스템의 정확도, 관련성, 자연스러움을 높이는 데 기여합니다.\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "33": "RAG의 '출처 불명확성' 문제는, RAG가 답변 생성에 사용되는 정보의 출처를 명확하게 밝히지 않아, 답변의 신뢰성을 떨어뜨리는 주요한 한계점입니다. 이 문제를 개선하기 위한 다양한 기법들이 연구되고 있으며, 현재 가장 활발하게 연구되고 있는 방법들은 다음과 같습니다.\n\n**1. 메타데이터 기반 출처 명시:**\n\n* **문서 메타데이터 활용:** 각 문서에 포함된 메타데이터 (저자, 작성 날짜, 출처, 관련 링크 등)를 활용하여 출처를 명시합니다.\n* **지속적인 업데이트:** 문서의 메타데이터를 지속적으로 업데이트하여 정보의 최신성을 유지합니다.\n* **출처 추적 시스템:** RAG 시스템 내에서 각 문서의 출처를 추적하고, 사용자가 해당 출처를 확인하고 확인할 수 있도록 합니다.\n\n**2. 지식 그래프 기반 출처 추적:**\n\n* **지식 그래프 구축:** RAG 시스템에서 생성된 답변과 관련된 지식 그래프를 구축합니다.\n* **지식 그래프 내 정보 연결:** 답변 생성 과정에서 지식 그래프 내의 정보를 활용하여 답변의 근거를 명확하게 제시합니다.\n* **지식 그래프 기반 출처 추적:** 지식 그래프를 통해 답변 생성에 사용된 정보의 출처를 추적하고, 출처를 명시합니다.\n\n**3. 답변 생성 과정에서의 출처 명시:**\n\n* **출처 강조:** 답변 생성 시, 출처를 명확하게 강조합니다. (예: \"본 답변은 [출처]에 따라 작성되었습니다.\")\n* **출처 링크 제공:** 답변 생성에 사용된 문서나 지식 그래프의 링크를 제공합니다.\n* **출처 정보 자동 생성:**  출처를 자동으로 생성하는 기술을 개발하여, 사용자가 쉽게 출처를 확인할 수 있도록 합니다.\n\n**4. 사용자에게 정보 출처 제공:**\n\n* **출처 정보 제공:** 사용자가 답변을 생성하는 문서나 지식 그래프에 대한 출처 정보를 제공합니다.\n* **출처 확인 기능:** 사용자가 답변의 출처를 직접 확인할 수 있도록 기능을 제공합니다.\n\n**5.  LLM 활용:**\n\n* **출처 추론 능력 강화:** LLM을 활용하여 답변 생성 과정에서 출처를 추론하고, 출처를 명확하게 제시합니다.\n* **출처 기반 답변 생성:** LLM이 답변 생성 시 출처를 기반으로 답변을 생성하도록 유도합니다.\n\n**6.  Retrieval-Augmentation 전략 개선:**\n\n* **Retrieval Context 강화:**  검색된 문서를 더 풍부하게 활용하여, 답변 생성에 필요한 정보의 범위를 넓힙니다.\n* **Context Window 최적화:**  문서의 크기를 줄이거나, 문맥을 더 효과적으로 활용하여, 모델이 더 많은 정보를 처리할 수 있도록 합니다.\n\n**7.  RAG 모델 자체 개선:**\n\n* **출처 추적 학습:** RAG 모델 자체를 학습시켜, 출처를 추적하고, 출처를 명확하게 제시하도록 합니다.\n* **출처 기반 답변 생성:** RAG 모델이 답변 생성 시 출처를 고려하여 답변을 생성하도록 학습시킵니다.\n\n**추가적으로 고려해야 할 사항:**\n\n* **사용자 편의성:** 출처 명시를 통해 사용자가 정보를 쉽게 확인할 수 있도록 사용자 인터페이스를 개선해야 합니다.\n* **지속적인 업데이트:**  출처 정보는 시간이 지남에 따라 변경될 수 있으므로, 지속적으로 업데이트해야 합니다.\n* **다양한 출처에 대한 처리:**  다양한 출처에 대한 출처 명시를 위한 기술을 개발해야 합니다.\n\n이러한 기법들을 종합적으로 적용하여 RAG 시스템의 '출처 불명확성' 문제를 해결하고, 답변의 신뢰성을 높일 수 있습니다.  각 기법의 효과는 데이터의 특성, RAG 모델의 구조, 그리고 사용자의 요구 사항에 따라 달라질 수 있습니다.",
          "34": "Modular RAG에서 'Reducer' 연산자는 검색된 문서를 정리하고 최종 후보를 선택하는 데 중요한 역할을 합니다. 좀 더 자세히 설명하면 다음과 같습니다.\n\n**Reducer 연산자의 역할:**\n\n* **문서 정렬 및 필터링:** 'Reducer'는 검색된 문서를 특정 기준에 따라 정렬하고 필터링합니다. 예를 들어, 특정 키워드를 포함하는 문서를 우선적으로 선택하거나, 특정 유형의 문서를 제외할 수 있습니다.\n* **최적 후보 선정:** 'Reducer'는 검색된 문서를 기반으로 가장 관련성이 높은 후보 문서를 선택합니다. 이를 통해 검색 결과의 품질을 향상시키고, 사용자에게 더 유용한 정보를 제공합니다.\n* **문서 간의 관계 파악:** 'Reducer'는 문서를 연결하여 문맥을 파악하고, 더 나아가 문장 간의 관계를 분석합니다. 이를 통해 검색 결과의 정확성과 신뢰성을 높입니다.\n* **중복 제거:** 'Reducer'는 유사한 문서를 제거하여 검색 결과의 효율성을 높입니다.\n\n**Reducer 연산자의 중요성:**\n\n'Reducer'는 Modular RAG의 성능을 크게 향상시키는 핵심 요소입니다.  검색된 문서를 효율적으로 관리하고, 최적의 후보를 선택함으로써 사용자에게 더 정확하고 유용한 정보를 제공할 수 있도록 합니다.\n\n**요약:** 'Reducer'는 검색된 문서를 정렬하고 필터링하여 최종 후보를 선택하는 역할을 수행하며, 이를 통해 Modular RAG의 성능을 향상시키는 데 중요한 역할을 합니다.\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "35": "Modular RAG의 'Summarizer' Operator는 다음과 같은 중요한 역할을 수행합니다.\n\n**핵심 역할:**\n\n* **문서 요약:** 'Summarizer' Operator는 주어진 문서(Retrieval Context)를 분석하여 핵심 내용을 추출하고 요약하는 역할을 합니다.\n* **요약 생성:** 추출된 핵심 내용을 바탕으로, 사용자가 원하는 정보의 핵심을 빠르게 파악할 수 있도록 요약된 결과를 생성합니다.\n* **정보 추출:** 문서에서 중요한 정보(예: 키워드, 사실, 결론 등)를 추출하여 요약에 포함시킵니다.\n\n**구체적인 기능:**\n\n* **요약 길이 조절:** 사용자가 원하는 요약 길이(예: 100단어, 500단어)에 맞춰 요약의 길이를 조절할 수 있도록 합니다.\n* **특정 정보 추출:** 사용자가 특정 정보(예: 특정 키워드, 특정 유형의 정보)를 추출하도록 유도합니다.\n* **요약 형식 지정:** 요약의 형식(예: 핵심 내용, 요약, 핵심 키워드 등)을 지정할 수 있도록 합니다.\n\n**왜 중요할까요?**\n\n* **정보 과부하 방지:** LLM이 너무 많은 정보를 처리하지 않고 핵심 내용만 전달하도록 돕습니다.\n* **빠른 정보 접근:** 사용자가 필요한 정보를 빠르게 얻을 수 있도록 합니다.\n* **효율적인 정보 활용:** 사용자가 필요한 정보를 효율적으로 활용할 수 있도록 합니다.\n\n**요약하자면, 'Summarizer' Operator는 'Summarizer'의 역할이자 핵심적인 기능으로, 문서의 내용을 효과적으로 요약하고 활용하는 데 중요한 역할을 수행합니다.**\n\n더 자세한 내용은 Modular RAG 문서에서 찾을 수 있습니다. (https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e)",
          "36": "Modular RAG의 'Paraphraser' Operator는 주어진 텍스트를 다른 표현으로 변환하는 역할을 합니다. 즉, 텍스트의 의미를 유지하면서 다른 단어, 문장 구조, 어휘 등을 사용하여 텍스트를 재구성하는 것을 목표로 합니다. \n\n좀 더 자세히 설명하면 다음과 같습니다.\n\n*   **목표:** 텍스트의 의미를 유지하면서 문맥에 맞게 다른 표현으로 바꾸는 것\n*   **작동 방식:** 텍스트를 입력받아, 다양한 paraphraser 알고리즘을 적용하여 변환합니다.\n*   **활용:** 텍스트의 가독성을 높이거나, 텍스트를 다른 형식으로 변환하거나, 텍스트의 의미를 더 명확하게 전달하기 위해 사용됩니다.\n\nModular RAG에서 'Paraphraser' Operator는 텍스트를 변환하는 데 필요한 핵심적인 기능 중 하나이며, 다양한 텍스트 변환 작업에 활용될 수 있습니다.",
          "37": "금융 도메인에서 활용되는 RAG(Retrieval-Augmented Generation) 패턴은 매우 다양하며, 특히 다음과 같은 측면에서 활용됩니다.\n\n**1. 규제 준수 및 보고서 생성:**\n\n* **규제 준수 자동화:** 금융 기관은 규제 기관에 제출해야 하는 보고서 생성에 RAG를 활용하여, 규제 요구 사항을 충족하는 핵심 정보를 자동으로 추출하고 요약합니다. 예를 들어, 고객 데이터, 거래 내역, 규정 준수 관련 문서 등을 검색하여 보고서 초안을 생성합니다.\n* **보고서 요약 및 분석:** 복잡한 금융 보고서를 RAG를 통해 요약하고, 중요한 통찰력을 추출하여 분석가의 시간을 절약합니다.\n* **사례 연구 및 위험 평가:** 특정 금융 상품 또는 시장 상황에 대한 사례 연구를 생성하고, 위험 평가를 자동화합니다.\n\n**2. 고객 서비스 및 상담:**\n\n* **고객 문의 응답:** 고객 문의에 대한 답변을 RAG를 통해 생성하여, 고객 서비스 담당자의 업무 부담을 줄입니다. 특히, 복잡한 금융 상품에 대한 질문에 대한 답변을 빠르게 제공할 수 있습니다.\n* **맞춤형 금융 상품 추천:** 고객의 금융 상황과 목표에 맞춰 맞춤형 금융 상품을 추천하기 위해 RAG를 활용합니다.\n* **금융 상품 정보 제공:** 고객에게 금융 상품의 특징, 위험, 수익 등을 RAG를 통해 제공합니다.\n\n**3. 시장 분석 및 투자 전략:**\n\n* **시장 동향 분석:** 뉴스 기사, 증권 정보, 경제 지표 등을 RAG를 통해 검색하여 시장 동향을 분석하고, 투자 전략을 수립합니다.\n* **투자 보고서 생성:** 특정 산업 또는 시장에 대한 투자 보고서를 RAG를 통해 생성합니다.\n* **사전 분석 및 위험 관리:** 시장 데이터 및 뉴스 기사를 RAG를 통해 검색하여 잠재적인 위험 요소를 식별하고, 위험 관리를 수행합니다.\n\n**4. 내부 문서 및 데이터 관리:**\n\n* **법률 및 규정 준수:** 금융 기관은 법률 및 규정 준수를 위해 방대한 양의 문서를 관리합니다. RAG를 활용하여 관련 문서를 검색하고, 법률 및 규정 준수 관련 정보를 추출합니다.\n* **데이터 품질 관리:** 데이터 품질을 유지하고 관리하기 위해 RAG를 활용합니다.\n\n**5. 특정 금융 상품 (예: 부동산, 보험):**\n\n* **부동산 시장 분석:** 부동산 관련 뉴스, 시장 데이터, 법률 정보를 RAG를 통해 검색하여 부동산 시장 동향을 분석합니다.\n* **보험 상품 비교:** 다양한 보험 상품의 특징, 위험, 보험료 등을 RAG를 통해 비교 분석합니다.\n\n**구체적인 예시:**\n\n* **고객에게 \"주식 시장 전망\" 질문에 대한 답변 생성:** 고객의 질문을 RAG를 통해 검색하고, 관련 정보를 요약하여 고객에게 제공합니다.\n* **특정 금융 상품의 위험 요약:** 고객에게 상품의 위험 요약을 RAG를 통해 제공합니다.\n* **규제 변화에 따른 보고서 자동 생성:** 규제 변화를 RAG를 통해 검색하고, 관련 보고서를 자동으로 생성합니다.\n\n**핵심 고려 사항:**\n\n* **정확성 및 신뢰성:** 금융 데이터는 매우 중요하므로, RAG 시스템은 정확하고 신뢰할 수 있는 정보를 제공해야 합니다.\n* **데이터 보안 및 개인 정보 보호:** 금융 데이터는 민감한 정보이므로, 데이터 보안 및 개인 정보 보호를 위한 적절한 조치를 취해야 합니다.\n* **지속적인 학습 및 업데이트:** 금융 시장은 끊임없이 변화하므로, RAG 시스템은 지속적으로 학습하고 업데이트해야 합니다.\n\n이러한 다양한 활용 사례를 통해 금융 도메인에서 RAG는 더욱 효율적이고 정확한 업무를 수행할 수 있도록 지원하고 있습니다.",
          "38": "의료 도메인에서 Query Expansion은 다음과 같은 중요한 이유로 필요합니다. \n\n**1. 정확도 향상 및 검색 결과 품질 개선:**\n\n* **복잡한 질의 처리:** 의료 검색은 종종 복잡하고 다층적인 질문을 포함합니다. 단순히 키워드만 기반으로 검색하는 것보다, 사용자가 의도하는 의미를 더 정확하게 파악하고, 관련 정보를 더 효과적으로 검색할 수 있도록 돕습니다.\n* **의료 전문 용어 및 개념의 미묘한 차이:** 의료 분야는 전문 용어와 개념이 매우 다양합니다. 단순히 키워드를 검색하는 것만으로는 이러한 미묘한 차이를 파악하기 어렵습니다. Query Expansion은 사용자의 의도를 반영하여, 더 정확한 검색 결과를 제공합니다.\n* **의료 지식의 불확실성:** 의료 정보는 끊임없이 변화하고, 때로는 불확실성이 존재합니다. Query Expansion은 사용자의 질문을 더 풍부하게 변형하여, 검색 결과의 신뢰성을 높입니다.\n\n**2. 특정 질의에 대한 정보 획득:**\n\n* **의료 논문 및 연구 자료의 복잡성:** 의료 논문은 복잡한 문장 구조와 전문 용어를 포함합니다. Query Expansion은 사용자의 질문을 더 쉽게 이해하고, 관련 정보를 추출하는 데 도움을 줍니다.\n* **임상 데이터 및 환자 정보 활용:** 환자의 병력, 유전 정보, 임상 데이터 등은 의료 검색에 매우 중요한 요소입니다. Query Expansion은 이러한 데이터를 활용하여, 더 정확하고 개인화된 검색 결과를 제공합니다.\n\n**3. 검색 결과의 다양성 확보:**\n\n* **다양한 검색 시도:** 사용자가 검색하는 질문은 다양한 방식으로 표현될 수 있습니다. Query Expansion은 사용자가 다양한 질문을 시도하도록 유도하여, 검색 결과의 다양성을 확보합니다.\n* **오해 방지:** 사용자가 의도한 의미를 정확하게 파악하지 못하는 경우, Query Expansion은 사용자의 의도를 파악하고, 검색 결과를 수정하여 오해를 방지합니다.\n\n**4. 의료 전문가의 의사 결정 지원:**\n\n* **추가적인 정보 제공:** 검색 결과에 대한 추가적인 정보를 제공하여, 의료 전문가가 더 정확한 진단 및 치료 결정을 내릴 수 있도록 돕습니다.\n\n**요약하자면, Query Expansion은 의료 검색의 정확도와 품질을 향상시키고, 의료 전문가의 의사 결정 지원에 중요한 역할을 합니다.**\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "39": "법률 도메인에서 Judge 모듈은 핵심적인 역할을 수행하며, 크게 다음과 같은 역할을 합니다.\n\n**1. 사용자의 질문 평가 및 검색 방향 결정:**\n\n*   **질의 분석:** Judge 모듈은 사용자의 법률 질문을 분석하여 질문의 의도를 파악합니다. 단순히 질문을 읽어주는 것을 넘어, 질문의 핵심 내용을 이해하고, 어떤 종류의 법률 지식이 필요한지 파악합니다.\n*   **검색 방향 결정:** 분석 결과를 바탕으로, 사용자가 원하는 답변을 얻기 위해 어떤 종류의 법률 자료를 검색해야 하는지 판단합니다. 예를 들어, \"근무 시간 변경 요청을 거부할 수 있는가?\" 와 같은 질문은 \"근로 계약서에 명시되지 않은 근무 시간 변경 거부 가능 여부\" 와 같이 구체적인 법률 지식을 필요로 합니다.\n\n**2. 검색 방식 결정 및 효율성 증대:**\n\n*   **적절한 검색 방식 선택:** 사용자의 질문 유형에 따라 적절한 검색 방식을 선택합니다. 예를 들어, \"근무 시간 변경 요청을 거부할 수 있는가?\" 와 같은 질문은 \"근로 계약서에 명시되지 않은 근무 시간 변경 거부 가능 여부\" 와 같이 특정 법률 지식을 필요로 하는 검색을 수행합니다.\n*   **검색 효율성 증대:**  검색 알고리즘을 최적화하여 검색 결과의 정확성과 효율성을 높입니다.\n\n**3.  검색 결과의 품질 향상:**\n\n*   **필터링 및 정렬:**  검색된 법률 자료를 필터링하여 관련성 높은 자료만 선택하고, 정렬하여 검색 결과를 효율적으로 관리합니다.\n*   **불필요한 정보 제거:**  검색 결과에서 불필요한 정보를 제거하여 사용자에게 필요한 정보만 제공합니다.\n\n**4.  Agent의 작업 효율성 증대:**\n\n*   **자동화된 법률 해석:**  검색된 법률 자료를 기반으로, 사용자의 질문에 대한 법률 해석을 자동으로 제공합니다.\n*   **추가 검색 제안:**  검색 결과가 부족할 경우, 추가적인 법률 자료를 추천하거나, 관련 법률 지식을 제공하여 사용자의 의도를 더욱 명확하게 합니다.\n\n**요약:** Judge 모듈은 법률 질문을 정확하게 이해하고, 적절한 법률 자료를 검색하여 사용자가 필요한 정보를 효율적으로 제공하는 핵심적인 역할을 수행합니다.\n\n더 자세한 내용은 다음 자료를 참고하시면 좋습니다.\n\n*   [https://www.ibm.com/blogs/solutions/ai-legal-research-and-analysis](https://www.ibm.com/blogs/solutions/ai-legal-research-and-analysis)\n*   [https://www.oracle.com/path/cs/ai/legal-research-judge/](https://www.oracle.com/path/cs/ai/legal-research-judge/)\n\n이 외에도 Judge 모듈의 역할은 법률 도메인 전체의 효율성을 높이는 데 중요한 역할을 합니다.",
          "40": "전자상거래 도메인에서 RRR 패턴의 구성 단계는 다음과 같습니다.\n\n1.  **1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다.** (기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크)\n2.  **2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다.** (기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크)\n3.  **3단계 구조:**\n    *   **1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다.**\n    *   **2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다.** (기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크)\n    *   **4단계 (추가 단계):**\n        *   **4.1 융합 메커니즘:** 검색된 문서를 기반으로 최적의 답변을 생성하기 위해 융합 메커니즘을 적용합니다.\n        *   **4.2 스케줄링:** 각 도메인별로 최적화된 검색 및 생성 패턴을 적용하기 위해 스케줄링을 수행합니다.\n        *   **4.3 렌더링:** 생성된 응답을 사용자에게 제공하기 위해 렌더링합니다.\n        *   **4.4 평가:** 생성된 응답의 품질을 평가하고 개선합니다.\n\n**요약:** RAG 패턴은 모듈화된 구조를 통해 각 단계별로 독립적으로 작동하며, 융합, 스케줄링, 렌더링, 평가 등의 과정을 거쳐 최종적으로 최적의 답변을 생성합니다.\n\n이러한 단계들을 통해 RAG 시스템의 성능과 효율성을 지속적으로 개선하고, 다양한 전자상거래 도메인에 최적화된 서비스를 제공할 수 있습니다.",
          "41": "GraphRAG에서 '구성기(Organizer)'는 다음과 같은 중요한 역할을 수행합니다.\n\n**1. 노이즈 및 불필요한 정보를 제거하여 그래프를 보강합니다.**\n\n*   **가치 있는 정보 추출:** GraphRAG는 쿼리에서 불필요하거나 관련 없는 정보를 제거하여 그래프를 더욱 핵심적인 정보에 집중시킵니다.\n*   **데이터 정리:** 쿼리 과정에서 쿼리된 데이터의 품질을 높이기 위해 데이터의 불필요한 부분을 제거합니다.\n\n**2. 그래프의 구조를 개선하고, 쿼리 효율성을 높입니다.**\n\n*   **노이즈 감소:** 쿼리 과정에서 발생하는 노이즈를 줄여 쿼리 결과의 정확도를 높입니다.\n*   **추가 정보 캡처:** 쿼리에서 필요한 정보만 추출하여 그래프에 추가함으로써, 쿼리 결과의 품질을 향상시킵니다.\n\n**3.  추가적인 분석 및 추론을 위한 기반을 마련합니다.**\n\n*   **데이터 연결:** 그래프 구조를 통해 다양한 데이터 간의 관계를 파악하고, 이를 기반으로 더 깊이 있는 분석을 수행할 수 있도록 돕습니다.\n*   **추론 과정 지원:**  GraphRAG는 구성기를 통해 쿼리된 정보를 바탕으로 추론 과정을 지원합니다.\n\n**요약하자면, 구성기는 GraphRAG의 효율성을 높이고, 쿼리 결과의 품질을 향상시키는 핵심적인 역할을 수행합니다.**\n\n**추가적으로, GraphRAG의 구성기(Organizer)는 다음과 같은 기능들을 포함할 수 있습니다.**\n\n*   **데이터 필터링:** 쿼리된 데이터의 특정 조건을 만족하는 데이터만 선택합니다.\n*   **데이터 정렬:** 쿼리된 데이터의 중요도에 따라 데이터를 정렬합니다.\n*   **데이터 그룹화:** 유사한 데이터를 그룹화하여 분석을 용이하게 합니다.\n*   **데이터 변환:** 쿼리된 데이터의 형태를 변경하여 분석에 적합하게 만듭니다.\n\n이러한 기능들을 통해 GraphRAG는 쿼리 결과의 품질을 높이고, 더 정확하고 유용한 정보를 제공할 수 있습니다.",
          "42": "GraphRAG의 '생성기(Generator)'는 핵심적인 역할을 수행하며, 크게 다음과 같은 주요 기능을 수행합니다.\n\n**1. 쿼리 처리 및 그래프 구조 확장:**\n\n*   **쿼리 분석 및 이해:** 쿼리를 분석하여 텍스트, SMILES, 장면 그래프 등 다양한 형식으로 변환합니다.\n*   **그래프 구조 확장:** 쿼리에서 추출된 정보를 기반으로 그래프 구조를 확장하고, 새로운 노드와 엣지를 생성합니다.\n*   **정보 추출 및 연결:** 쿼리에서 필요한 정보를 추출하고, 그래프 구조 내에서 관련 정보를 연결합니다.\n\n**2. 그래프 구조 보강 및 최적화:**\n\n*   **노드 및 엣지 추가:** 쿼리에서 추출된 정보를 바탕으로 새로운 노드와 엣지를 추가하여 그래프 구조를 확장합니다.\n*   **노드 및 엣지 정렬:** 그래프 구조의 효율성을 높이기 위해 노드와 엣지를 정렬합니다.\n*   **노드 및 엣지 연결:** 쿼리에서 추출된 정보를 기반으로 노드와 엣지를 연결하여 그래프 구조를 개선합니다.\n\n**3. 생성 결과 개선:**\n\n*   **생성된 텍스트 생성:** 쿼리된 정보를 바탕으로 텍스트를 생성합니다.\n*   **추론 및 답변 생성:** 생성된 텍스트를 기반으로 추론 및 답변을 생성합니다.\n*   **최적화:** 생성된 텍스트의 품질을 높이기 위해 최적화합니다.\n\n**4.  지속적인 학습 및 개선:**\n\n*   **학습 데이터 생성:** 쿼리 및 그래프 구조에 대한 학습 데이터를 생성합니다.\n*   **모델 업데이트:** 생성된 데이터를 기반으로 모델을 업데이트하여 성능을 향상시킵니다.\n\n**요약하자면, 생성기는 쿼리에서 추출된 정보를 바탕으로 그래프 구조를 확장하고, 그래프 구조를 최적화하여 쿼리에 대한 답변을 생성하는 핵심적인 역할을 수행합니다.**\n\n이러한 기능들을 통해 GraphRAG는 쿼리 처리 및 답변 생성 과정에서 더욱 정확하고 풍부한 정보를 활용하여 사용자에게 유용한 답변을 제공할 수 있도록 돕습니다.",
          "43": "GraphRAG의 데이터 소스 예시는 매우 다양하며, 각 데이터 소스는 특정 목적과 활용 분야에 맞춰 설계되었습니다. 아래는 GraphRAG에서 활용될 수 있는 주요 데이터 소스 예시 세 가지입니다.\n\n1.  **지식 그래프 (Knowledge Graph):**\n    *   **설명:** 지식 그래프는 개별 엔티티(개체)와 그 관계를 연결하여 표현하는 데이터 구조입니다. GraphRAG는 다양한 지식 그래프를 활용하여 정보를 통합하고, 관계를 분석하여 답변 생성에 필요한 지식을 얻습니다.\n    *   **예시:**\n        *   **LinkedIn:** LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG를 통합했습니다. LinkedIn의 고객 데이터, 서비스 정보, 고객 관계 등을 그래프 형태로 표현하여, 고객의 문제 해결에 필요한 정보를 빠르게 제공합니다.\n        *   **Wikipedia:** Wikipedia는 다양한 주제에 대한 정보를 담고 있는 지식 그래프입니다. GraphRAG는 Wikipedia의 정보를 활용하여 질문에 대한 답변을 생성하고, 사용자에게 유용한 정보를 제공합니다.\n        *   **구글 지식 기반:** 구글은 지식 기반 검색 엔진인 Google Knowledge Graph를 활용하여 다양한 주제에 대한 정보를 제공합니다. GraphRAG는 Google Knowledge Graph의 정보를 활용하여 질문에 대한 답변을 생성하고, 사용자에게 유용한 정보를 제공합니다.\n\n2.  **문서 그래프 (Document Graph):**\n    *   **설명:** 문서 그래프는 문서(텍스트, 이미지, PDF 등)를 연결하여 표현하는 데이터 구조입니다. GraphRAG는 문서 내의 내용을 분석하고, 관련 정보를 추출하여 답변 생성에 활용합니다.\n    *   **예시:**\n        *   **법률 문서:** 법률 문서의 내용을 분석하여 법률 관련 질문에 답변하거나, 법률 해석을 지원합니다.\n        *   **뉴스 기사:** 뉴스 기사의 내용을 분석하여 특정 사건에 대한 정보를 제공하거나, 관련 사건의 배경을 설명합니다.\n        *   **연구 논문:** 연구 논문의 내용을 분석하여 연구 결과를 요약하거나, 연구의 핵심 내용을 설명합니다.\n\n3.  **과학 그래프 (Scientific Graph):**\n    *   **설명:** 과학 그래프는 과학 연구 결과를 그래프 형태로 표현하는 데이터 구조입니다. GraphRAG는 과학 연구 데이터(논문, 데이터, 결과 등)를 활용하여 연구 결과를 분석하고, 새로운 연구 아이디어를 도출합니다.\n    *   **예시:**\n        *   **유전체 데이터:** 유전체 데이터의 내용을 분석하여 유전자 간의 관계를 파악하고, 질병의 원인을 찾습니다.\n        *   **의료 데이터:** 환자의 의료 데이터를 분석하여 질병의 위험을 예측하고, 치료 방법을 제안합니다.\n        *   **기후 데이터:** 기후 데이터의 내용을 분석하여 기후 변화의 원인을 파악하고, 기후 변화에 대한 대응 방안을 제시합니다.\n\n4.  **분자 구조 그래프 (Molecular Structure Graph):**\n    *   **설명:** 분자 구조 그래프는 분자들의 연결 관계를 그래프 형태로 표현하는 데이터 구조입니다. GraphRAG는 분자 구조 데이터를 활용하여 약물 개발, 신약 후보 물질 탐색 등에 활용합니다.\n    *   **예시:**\n        *   **약물 후보 물질:** 약물 후보 물질의 구조를 분석하여 약효를 예측하고, 약물 개발을 지원합니다.\n        *   **생명 공학:** 생명 공학 연구에서 분자 구조를 분석하여 새로운 생명 공학 기술을 개발합니다.\n        *   **화학 반응:** 화학 반응의 경로를 분석하여 반응 조건을 최적화합니다.\n\n5.  **장면 그래프 (Scene Graph):**\n    *   **설명:** 장면 그래프는 장면(scene)을 그래프 형태로 표현하는 데이터 구조입니다. GraphRAG는 장면 데이터를 활용하여 사용자에게 맞춤형 콘텐츠를 제공하고, 사용자 경험을 향상시킵니다.\n    *   **예시:**\n        *   **여행 계획:** 여행 계획을 생성하고, 여행 경로를 추천합니다.\n        *   **게임:** 게임의 배경, 캐릭터, 스토리 등을 그래프 형태로 표현하여 사용자에게 제공합니다.\n        *   **AR/VR:** 현실 세계에 가상 객체를 렌더링하고, 사용자에게 보여줍니다.\n\n이 외에도 다양한 데이터 소스를 활용하여 GraphRAG의 성능과 활용 범위를 확장할 수 있습니다. 각 데이터 소스의 특성을 고려하여 적절한 데이터 소스를 선택하고, GraphRAG의 데이터 소스 관리 전략을 수립하는 것이 중요합니다.",
          "44": "Modular RAG에서 'Scheduling' Operator는 다음과 같은 핵심적인 역할을 수행합니다.\n\n**1. 실행 경로 최적화 및 워크플로우 관리:**\n\n* **실행 순서 결정:** Operator는 에이전트가 수행해야 할 작업들을 순서대로 결정하고, 각 작업의 실행 시점을 관리합니다.\n* **실행 단계 분할:** 에이전트가 수행해야 할 작업을 여러 단계로 나누어 각 단계별로 실행 순서를 설정합니다.\n* **실행 시간 분배:** 작업의 중요도나 복잡도에 따라 실행 시간을 분배하여 효율적인 작업 흐름을 유지합니다.\n* **실행 중단 및 재시작 제어:** 에이전트가 작업 중단되거나 재시작될 때, Operator는 적절한 시점에 실행을 중단하고 다시 시작하도록 제어합니다.\n\n**2. 동적 의사결정 지원:**\n\n* **실행 상황 모니터링:** 에이전트가 수행하는 작업의 진행 상황을 지속적으로 모니터링합니다.\n* **실행 경로 변경 제안:** 작업 진행 상황에 따라 실행 경로를 변경할 필요가 있는 경우, Operator는 새로운 경로를 제안합니다.\n* **실행 중단 및 재시작 자동화:** 에이전트가 예상치 못한 상황 발생 시, Operator는 자동으로 실행을 중단하고 재시작하도록 자동화합니다.\n\n**3. 다양한 도구 및 작업의 효율적인 활용:**\n\n* **도구 호출 및 실행:** Operator는 특정 도구를 호출하고 실행하는 작업을 관리합니다.\n* **도구 간 연동:** 여러 도구를 함께 사용하여 작업을 수행하도록 연결합니다.\n* **도구 사용 권한 관리:** 에이전트가 특정 도구를 사용할 수 있도록 권한을 관리합니다.\n\n**요약하자면, 'Scheduling' Operator는 Modular RAG의 전체적인 워크플로우를 효율적으로 관리하고, 에이전트가 목표를 달성하기 위해 최적의 실행 경로를 선택하도록 돕는 핵심적인 역할을 수행합니다.**\n\n더 자세한 내용은 Modular RAG 문서 및 관련 자료를 참고하시면 도움이 될 것입니다.",
          "45": "Modular RAG에서 'Fusion' Operator는 LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion) 등의 다양한 기법을 결합하여, 각 모듈의 결과를 통합하고 최종적인 응답 품질을 향상시키는 역할을 합니다. 좀 더 자세히 설명하면 다음과 같습니다.\n\n**Fusion Operator의 주요 역할:**\n\n* **결과 통합:** 여러 모듈의 결과를 하나의 최종 결과로 결합합니다. 예를 들어, 검색 결과, 질의 응답, 그리고 생성된 텍스트를 통합하여 사용자에게 제공합니다.\n* **상호 보완적인 정보 활용:** 각 모듈은 서로 다른 정보나 관점을 제공합니다. Fusion Operator는 이러한 정보를 효과적으로 결합하여, 더 풍부하고 정확한 응답을 생성합니다.\n* **개별 모듈의 강점 활용:** 각 모듈은 특정 유형의 정보나 작업에 특화되어 있습니다. Fusion Operator는 각 모듈의 강점을 활용하여, 전체적인 응답의 품질을 높입니다.\n* **예시:**\n    * **검색 결과와 질의 응답의 통합:** 검색 결과에서 얻은 정보를 질의에 대한 답변으로 변환하고, 이를 최종적으로 사용자에게 제공합니다.\n    * **생성된 텍스트와 검색 결과의 통합:** 생성된 텍스트를 검색 결과와 비교하여, 더 정확하고 관련성 높은 정보를 제공합니다.\n\n**Fusion Operator의 종류:**\n\n* **모듈 내부의 Fusion:** 각 모듈 내에서 직접적인 연산을 수행하여 결과를 통합합니다.\n* **모듈 간의 Fusion:** 모듈 간의 결과를 결합하여 최종적인 결과를 생성합니다.\n* **RRF (Reciprocal Rank Fusion):**  검색 결과의 순위를 기반으로 결과를 결합하여, 더 정확한 결과를 생성합니다.\n\n**요약:** Fusion Operator는 Modular RAG 시스템의 핵심적인 역할을 수행하며, 각 모듈의 결과를 효과적으로 통합하여 사용자에게 더 나은 결과를 제공하는 데 기여합니다.\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "46": "Advanced RAG의 쿼리 재작성에 사용되는 기법 'HyDE'는 **Hybridized Entity Decoding**의 약자입니다.",
          "47": "RAG에서 'BM25'는 검색 결과의 순위를 결정하는 데 사용되는 검색 방식의 일종입니다. 좀 더 자세히 설명하면 다음과 같습니다.\n\n**BM25 (Best Matching 25)**는 텍스트 데이터의 유사성을 기반으로 검색 결과를 정렬하는 방법입니다. 텍스트 데이터의 길이와 키워드의 빈도수를 고려하여, 가장 유사한 텍스트를 먼저 보여주는 방식입니다.\n\n**BM25의 특징:**\n\n*   **유사성 기반:** 텍스트 데이터의 의미적 유사성을 측정하여 검색 결과를 정렬합니다.\n*   **키워드 빈도:** 텍스트 데이터에 포함된 키워드의 빈도를 기반으로 유사도를 계산합니다.\n*   **순위 결정:** 키워드 빈도에 따라 순위를 매겨 검색 결과를 제시합니다.\n\n**RAG에서 BM25의 역할:**\n\n*   **검색 성능 향상:** BM25는 RAG 시스템의 검색 성능을 향상시키는 데 중요한 역할을 합니다. 특히, 텍스트 데이터의 길이와 키워드 빈도에 따라 검색 결과를 정렬함으로써, 관련성이 높은 텍스트를 먼저 보여주어 사용자에게 더 유용한 결과를 제공합니다.\n*   **단순한 유사도 검색:** BM25는 비교적 간단한 유사도 계산을 통해 검색 결과를 정렬하므로, RAG 시스템의 복잡성을 줄이는 데 도움이 됩니다.\n\n**요약:**\n\nBM25는 텍스트 데이터의 유사성을 기반으로 검색 결과를 정렬하는 검색 방식이며, RAG 시스템에서 검색 성능을 향상시키고 관련성 높은 텍스트를 먼저 보여주기 위해 사용됩니다.\n\n더 궁금한 점이 있으시면 언제든지 질문해주세요.",
          "48": "Modular RAG의 'Componentized Architecture' 장점 중 하나는 **독립적인 관리 및 확장성**입니다.\n\n이러한 아키텍처는 다음과 같은 이점을 제공합니다.\n\n*   **모듈화된 구조:** 각 컴포넌트(검색, 증강, 생성 등)는 독립적으로 개발, 테스트, 배포될 수 있습니다.\n*   **확장성:** 새로운 컴포넌트나 기능을 추가하거나 기존 컴포넌트를 수정하는 것이 용이하여 시스템을 쉽게 확장할 수 있습니다.\n*   **유연성:** 특정 작업에 최적화된 컴포넌트를 쉽게 변경하거나 대체할 수 있습니다.\n*   **유지보수 용이성:** 각 컴포넌트가 독립적으로 관리되므로, 문제 발생 시 특정 컴포넌트만 수정하는 것보다 전체 시스템에 미치는 영향이 적습니다.\n\n이러한 독립적인 관리 및 확장성은 Modular RAG의 유연성과 적응성을 높여, 다양한 요구사항에 맞춰 시스템을 쉽게 조정하고 발전시킬 수 있도록 합니다.",
          "49": "LinkedIn GraphRAG에서는 검색 시 다음과 같은 거리 측정 방법을 사용합니다.\n\n*   **Hybrid Search (밀도 기반 임베딩 검색 + 희소 키워드 검색):** 이 방법은 기존 벡터 검색(Vector RAG)에 기반하며, 쿼리(Query)의 밀도(Density)를 기반으로 검색 결과를 필터링합니다. 즉, 쿼리 문장에 자주 등장하는 단어(희소 키워드)를 중심으로 검색을 진행하여 정확도를 높입니다.\n*   **Iterative/Recursive Retrieval (반복적/재귀적 검색):**  이 방법은 쿼리 문장을 여러 단계로 나누어 검색하고, 각 단계에서 검색 결과를 재검색하여 정확도를 높입니다.\n\n**핵심은, 기존 벡터 검색의 '단순 검색' 방식에서 벗어나, 쿼리 문장의 의미를 파악하고, 관련성을 높이는 방식으로 검색을 진행하는 것입니다.**\n\n이러한 거리 측정 방법들은 LinkedIn GraphRAG가 쿼리 문장의 의미를 파악하고, 관련성 높은 정보를 우선적으로 제공하도록 설계되었습니다.\n\n더 자세한 내용은 LinkedIn GraphRAG의 공식 문서 및 관련 논문을 참고하시면 더 많은 정보를 얻으실 수 있습니다."
        },
        "reference": {
          "0": "Retrieval-Augmented Generation",
          "1": "색인(Indexing), 검색(Retrieval), 생성(Generation)",
          "2": "색인, 검색, 생성",
          "3": "문서를 청크로 분할 후 임베딩으로 벡터 변환하여 저장하고, 쿼리를 임베딩하여 유사한 청크를 검색 후 LLM에 입력하여 응답 생성",
          "4": "얕은 질의 이해",
          "5": "쿼리 재작성(Query Rewriting), 쿼리 확장(Query Expansion)",
          "6": "재정렬(Re-ranking), 압축(Compression)",
          "7": "독립적인 모듈과 특수 연산자로 구성된 유연하고 확장 가능한 프레임워크",
          "8": "모듈(Module), 하위 모듈(Submodule), 연산자(Operator)",
          "9": "Module: RAG 핵심 단계를 처리; Submodule: 모듈 내 세부 기능; Operator: 특정 기능 구현 단위",
          "10": "라우팅, 스케줄링, 융합 등을 통해 워크플로우 제어",
          "11": "조건부 패턴, 분기 패턴, 루프 패턴",
          "12": "BM25와 벡터 검색",
          "13": "Query Expansion, Query Transformation",
          "14": "Retriever Selection",
          "15": "Rerank, Compression",
          "16": "Generator Fine-tuning, Verification",
          "17": "핵심 기능을 개별 모듈로 분리해 독립적으로 관리 가능",
          "18": "모듈 기반으로 다양한 데이터 소스를 유연하게 조합할 수 있기 때문",
          "19": "조건부 라우팅, 병렬 처리, 순환 흐름 등 동적 워크플로우 구성",
          "20": "쿼리 프로세서, 검색기(Retriever), 구성기(Organizer), 생성기(Generator), 그래프 데이터 소스",
          "21": "관계형 지식 활용을 통한 다단계 추론 및 장기 계획 지원",
          "22": "고객 서비스 이슈 티켓 간 관계 보존으로 검색 정확도 향상",
          "23": "28.6%",
          "24": "간단한 FAQ, 문서 검색",
          "25": "법률, 금융, 의료",
          "26": "복잡한 도메인 지식이 필요한 분야",
          "27": "Naive RAG → Advanced RAG → Modular RAG",
          "28": "LLM이 사실 근거 없이 잘못된 정보를 생성하는 현상",
          "29": "반복, 재귀, 적응형 검색을 통한 상호 의존적 처리",
          "30": "다양한 조건에 따른 파이프라인 선택",
          "31": "병렬 실행을 통해 결과 다양성 증가",
          "32": "검색기와 생성기의 미세 조정을 통해 시스템 성능 최적화",
          "33": "검색된 문서 출처를 명시하는 'Citation' 기능",
          "34": "여러 개의 검색된 문서를 정리하여 최종 후보 선정",
          "35": "검색된 문서에서 핵심 내용 요약",
          "36": "자연스럽고 다양한 표현으로 변환",
          "37": "Text-to-SQL, Sentiment Analysis, Weighted Fusion",
          "38": "다양한 증상 표현을 포괄하여 검색 정확도 향상",
          "39": "질문 유형에 따라 적절한 검색 방식을 결정",
          "40": "Rewrite → Retrieve → Read",
          "41": "그래프 가지치기 및 외부 지식 보강",
          "42": "그래프 정보를 LLM에 공급하여 응답 생성",
          "43": "지식 그래프, 문서 그래프, 과학 그래프",
          "44": "Rule-based 또는 LLM 기반 의사결정 수행",
          "45": "LLM Fusion, Weighted Ensemble, RRF 등을 통해 결과 융합",
          "46": "Hypothetical Document Embeddings",
          "47": "Sparse Retrieval",
          "48": "유지보수가 용이",
          "49": "코사인 유사도"
        },
        "answer_relevancy": {
          "0": 0.8592823124745976,
          "1": 0.8891179193802666,
          "2": 0.8933957235482873,
          "3": 0.8885173143845938,
          "4": 0.8763906877029752,
          "5": 0.8831981494451068,
          "6": 0.8925370755655259,
          "7": 0.893030819932234,
          "8": 0.8807035090851034,
          "9": 0.8540590296627104,
          "10": 0.8681437657184942,
          "11": 0.8971589215012713,
          "12": 0.9171523467451773,
          "13": 0.9003070817317752,
          "14": 0.7772575223002695,
          "15": 0.8879493001809591,
          "16": 0.8565268091236118,
          "17": 0.9097423782383429,
          "18": 0.8863783995516515,
          "19": 0.8388743510693878,
          "20": 0.8812839671246112,
          "21": 0.9030926442426059,
          "22": 0.8778436600347456,
          "23": 0.8717506131465568,
          "24": 0.873861753606192,
          "25": 0.9044949002117925,
          "26": 0.0,
          "27": 0.8557364045772257,
          "28": 0.8914328189283095,
          "29": 0.8626660662810721,
          "30": 0.8570201962085654,
          "31": 0.7901178472062443,
          "32": 0.8523328528102342,
          "33": 0.8691570025935454,
          "34": 0.9065668431245194,
          "35": 0.9131181134787688,
          "36": 0.9049669534020377,
          "37": 0.8588408435255838,
          "38": 0.8919664522018088,
          "39": 0.8728840128633634,
          "40": 0.8758801370030252,
          "41": 0.8816754646933972,
          "42": 0.8675548559944163,
          "43": 0.865964357730601,
          "44": 0.9259910756102187,
          "45": 0.9206440204234495,
          "46": 0.8686979918253369,
          "47": 0.8822012451331188,
          "48": 0.9111842083893255,
          "49": 0.8800750870567096
        },
        "faithfulness": {
          "0": 1.0,
          "1": 1.0,
          "2": 0.8333333333333334,
          "3": 0.7333333333333333,
          "4": 0.75,
          "5": 0.3333333333333333,
          "6": 0.5333333333333333,
          "7": 0.8666666666666667,
          "8": 1.0,
          "9": 0.8387096774193549,
          "10": 0.9705882352941176,
          "11": 0.4,
          "12": 0.6,
          "13": 0.18181818181818182,
          "14": 0.11764705882352941,
          "15": 1.0,
          "16": 0.2222222222222222,
          "17": 1.0,
          "18": 1.0,
          "19": 1.0,
          "20": 1.0,
          "21": 1.0,
          "22": 1.0,
          "23": 1.0,
          "24": 0.14285714285714285,
          "25": 0.6666666666666666,
          "26": 0.6666666666666666,
          "27": 0.46153846153846156,
          "28": 1.0,
          "29": 0.16666666666666666,
          "30": 0.6666666666666666,
          "31": 0.4782608695652174,
          "32": 0.7368421052631579,
          "33": 1.0,
          "34": 0.7692307692307693,
          "35": 0.0,
          "36": 0.0,
          "37": 0.5666666666666667,
          "38": 1.0,
          "39": 0.875,
          "40": 0.45454545454545453,
          "41": 0.4,
          "42": 0.7368421052631579,
          "43": 0.48148148148148145,
          "44": 0.6666666666666666,
          "45": 0.6666666666666666,
          "46": 0.0,
          "47": 0.25,
          "48": 1.0,
          "49": 0.46153846153846156
        },
        "context_recall": {
          "0": 1.0,
          "1": 1.0,
          "2": 1.0,
          "3": 1.0,
          "4": 1.0,
          "5": 1.0,
          "6": 1.0,
          "7": 1.0,
          "8": 1.0,
          "9": 1.0,
          "10": 1.0,
          "11": 1.0,
          "12": 1.0,
          "13": 1.0,
          "14": 1.0,
          "15": 1.0,
          "16": 1.0,
          "17": 1.0,
          "18": 1.0,
          "19": 1.0,
          "20": 1.0,
          "21": 1.0,
          "22": 1.0,
          "23": 1.0,
          "24": 1.0,
          "25": 1.0,
          "26": 0.0,
          "27": 1.0,
          "28": 1.0,
          "29": 1.0,
          "30": 1.0,
          "31": 0.0,
          "32": 1.0,
          "33": 1.0,
          "34": 1.0,
          "35": 1.0,
          "36": 0.0,
          "37": 0.0,
          "38": 1.0,
          "39": 1.0,
          "40": 1.0,
          "41": 1.0,
          "42": 1.0,
          "43": 1.0,
          "44": 1.0,
          "45": 1.0,
          "46": 0.0,
          "47": 1.0,
          "48": 1.0,
          "49": 0.0
        },
        "context_precision": {
          "0": 0.99999999998,
          "1": 0.99999999998,
          "2": 0.7499999999625,
          "3": 0.6999999999766667,
          "4": 0.8666666666377778,
          "5": 0.99999999998,
          "6": 0.8041666666465626,
          "7": 0.99999999998,
          "8": 0.999999999975,
          "9": 0.99999999998,
          "10": 0.99999999998,
          "11": 0.49999999995,
          "12": 0.9999999999666667,
          "13": 0.99999999995,
          "14": 0.3333333333,
          "15": 0.7555555555303703,
          "16": 0.3333333333,
          "17": 0.99999999998,
          "18": 0.99999999998,
          "19": 0.8874999999778125,
          "20": 0.94999999997625,
          "21": 0.999999999975,
          "22": 0.5333333333155555,
          "23": 0.8055555555287036,
          "24": 0.8874999999778125,
          "25": 0.6999999999766667,
          "26": 0.8041666666465626,
          "27": 0.99999999998,
          "28": 0.4499999999775,
          "29": 0.99999999998,
          "30": 0.99999999995,
          "31": 0.8055555555287036,
          "32": 0.999999999975,
          "33": 0.99999999998,
          "34": 0.7555555555303703,
          "35": 0.499999999975,
          "36": 0.0,
          "37": 0.49999999995,
          "38": 0.99999999998,
          "39": 0.8666666666377778,
          "40": 0.99999999995,
          "41": 0.9999999999,
          "42": 0.99999999998,
          "43": 0.99999999995,
          "44": 0.999999999975,
          "45": 0.699999999965,
          "46": 0.0,
          "47": 0.9999999999,
          "48": 0.8333333332916666,
          "49": 0.7555555555303703
        }
      },
      "average_scores": {
        "answer_relevancy": 0.8613745161353944,
        "faithfulness": 0.6539157778705474,
        "context_recall": 0.88,
        "context_precision": 0.815555555525926
      }
    },
    "Modular RAG": {
      "detailed_scores": {
        "user_input": {
          "0": "RAG의 약자는 무엇인가?",
          "1": "RAG의 세 가지 핵심 요소는?",
          "2": "Naive RAG의 핵심 구성 요소는 무엇인가?",
          "3": "Naive RAG의 작동 방식은?",
          "4": "Naive RAG의 한계 중 하나인 'Shallow Query Understanding'을 한국어로 무엇이라 하는가?",
          "5": "Advanced RAG에서 도입된 사전 검색 처리 기법 두 가지는?",
          "6": "Advanced RAG의 사후 검색 처리 기법 예시 두 가지는?",
          "7": "Modular RAG의 핵심 개념은?",
          "8": "Modular RAG의 3단계 구조를 쓰시오.",
          "9": "Module, Submodule, Operator 각각의 역할을 간략히 설명하시오.",
          "10": "Modular RAG의 '오케스트레이션 모듈'의 기능은?",
          "11": "Modular RAG의 동적 워크플로우 예시 패턴 세 가지는?",
          "12": "Modular RAG에서 'Hybrid Search'는 어떤 검색 기법을 결합하는가?",
          "13": "Modular RAG의 'Pre-retrieval' 모듈의 Operator 예시를 두 가지 쓰시오.",
          "14": "Retrieval 모듈의 Operator 중 하나를 쓰시오.",
          "15": "Post-Retrieval 모듈의 Operator 중 두 가지는?",
          "16": "Generation 모듈에서 사용되는 Operator 예시 두 가지는?",
          "17": "Modular RAG의 장점으로 'Componentized Architecture'가 의미하는 바는?",
          "18": "Modular RAG의 다중 데이터 소스 통합이 가능한 이유는?",
          "19": "LangGraph를 활용한 오케스트레이션이 제공하는 기능은?",
          "20": "GraphRAG의 핵심 구성 요소 다섯 가지를 쓰시오.",
          "21": "GraphRAG가 기존 RAG 대비 강화하는 주요 이점은?",
          "22": "LinkedIn이 GraphRAG를 도입한 목적은?",
          "23": "LinkedIn GraphRAG 시스템이 이슈 해결 시간을 얼마나 단축했는가?",
          "24": "Naive RAG를 적용하기 적합한 분야는?",
          "25": "Advanced RAG를 주로 활용하는 도메인은?",
          "26": "Modular RAG가 특히 강력한 성능을 발휘하는 분야는?",
          "27": "RAG의 발전 순서를 나열하시오.",
          "28": "RAG의 주요 문제점 중 하나인 'Hallucination'은 무엇을 의미하는가?",
          "29": "Modular RAG의 '루프 패턴'은 어떤 처리 방식을 말하는가?",
          "30": "조건부 패턴에서 사용되는 주요 기능은?",
          "31": "분기 패턴이 제공하는 이점은?",
          "32": "Tuning Pattern의 역할은?",
          "33": "RAG의 한계 중 '출처 불명확성'을 개선하기 위한 기법은?",
          "34": "Modular RAG에서 'Reducer' 연산자의 역할은?",
          "35": "Modular RAG의 'Summarizer' Operator는 무슨 역할을 하는가?",
          "36": "Modular RAG의 'Paraphraser' Operator 기능은?",
          "37": "금융 도메인에서 활용되는 RAG 패턴은?",
          "38": "의료 도메인에서 Query Expansion이 필요한 이유는?",
          "39": "법률 도메인에서 Judge 모듈의 역할은?",
          "40": "전자상거래 도메인에서 RRR 패턴의 구성 단계는?",
          "41": "GraphRAG에서 '구성기(Organizer)'의 역할은?",
          "42": "GraphRAG를 구성하는 '생성기(Generator)'의 주요 기능은?",
          "43": "GraphRAG의 데이터 소스 예시 세가지를 쓰시오.",
          "44": "Modular RAG에서 'Scheduling' Operator의 역할은?",
          "45": "Modular RAG에서 'Fusion' Operator는 어떤 역할을 하는가?",
          "46": "Advanced RAG의 쿼리 재작성에 사용되는 기법 'HyDE'는 무엇의 약자인가?",
          "47": "RAG에서 'BM25'는 어떤 검색 방식의 일종인가?",
          "48": "Modular RAG의 'Componentized Architecture' 장점 중 하나를 쓰시오.",
          "49": "LinkedIn GraphRAG에서는 검색 시 어떤 거리 측정 방법을 사용했는가?"
        },
        "retrieved_contexts": {
          "0": [
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이"
          ],
          "1": [],
          "2": [
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "Reference ※ 각 파트별 참조한 자료가 있다면 아래 출처 작성 부탁드립니다. ※ 작성 양식 : 문서/페이지명 (링크)  1번파트 - From complex to atomic: Enhancing Augmented Generation via Knowledge-aware Dual Rewriting and Reasoning (https://openreview.net/pdf/eece737929522d36939d3b6cf5da4e8c7921f2ee.pdf) - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/html/2312.10997v5  - Context window overflow: Breaking the barrier https://aws.amazon.com/jp/blogs/security/context-window-overflow-breaking-the-barrier/  - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/html/2407.21059v1  - How does Modular RAG improve upon naive RAG? https://adasci.org/how-does-modular-rag-improve-upon-naive-rag/  - Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "Reference ※ 각 파트별 참조한 자료가 있다면 아래 출처 작성 부탁드립니다. ※ 작성 양식 : 문서/페이지명 (링크)  1번파트 - From complex to atomic: Enhancing Augmented Generation via Knowledge-aware Dual Rewriting and Reasoning (https://openreview.net/pdf/eece737929522d36939d3b6cf5da4e8c7921f2ee.pdf) - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/html/2312.10997v5  - Context window overflow: Breaking the barrier https://aws.amazon.com/jp/blogs/security/context-window-overflow-breaking-the-barrier/  - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/html/2407.21059v1  - How does Modular RAG improve upon naive RAG? https://adasci.org/how-does-modular-rag-improve-upon-naive-rag/  - Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures"
          ],
          "3": [],
          "4": [
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "Reference ※ 각 파트별 참조한 자료가 있다면 아래 출처 작성 부탁드립니다. ※ 작성 양식 : 문서/페이지명 (링크)  1번파트 - From complex to atomic: Enhancing Augmented Generation via Knowledge-aware Dual Rewriting and Reasoning (https://openreview.net/pdf/eece737929522d36939d3b6cf5da4e8c7921f2ee.pdf) - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/html/2312.10997v5  - Context window overflow: Breaking the barrier https://aws.amazon.com/jp/blogs/security/context-window-overflow-breaking-the-barrier/  - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/html/2407.21059v1  - How does Modular RAG improve upon naive RAG? https://adasci.org/how-does-modular-rag-improve-upon-naive-rag/  - Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "Reference ※ 각 파트별 참조한 자료가 있다면 아래 출처 작성 부탁드립니다. ※ 작성 양식 : 문서/페이지명 (링크)  1번파트 - From complex to atomic: Enhancing Augmented Generation via Knowledge-aware Dual Rewriting and Reasoning (https://openreview.net/pdf/eece737929522d36939d3b6cf5da4e8c7921f2ee.pdf) - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/html/2312.10997v5  - Context window overflow: Breaking the barrier https://aws.amazon.com/jp/blogs/security/context-window-overflow-breaking-the-barrier/  - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/html/2407.21059v1  - How does Modular RAG improve upon naive RAG? https://adasci.org/how-does-modular-rag-improve-upon-naive-rag/  - Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이"
          ],
          "5": [
            "2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다. \n주요 전략 사전 검색 처리 (Pre-retrieval processing): ● 쿼리 재작성(query rewriting): 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. ● 쿼리 확장(query expansion): 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다. ● 쿼리 변환(query transformation): 원래 쿼리 대신 변환된 쿼리를 기반으로 검색 및 생성을 수행합니다.\n사후 검색 처리 (Post-retrieval processing): ● 검색 결과 재정렬(reranking): 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다. ● 압축(compression): 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다. ● 선택(selection): 관련 없는 덩어리를 직접 제거하여 LLM의 추론 효율성을 향상시킵니다.  \n특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다. \n주요 전략 사전 검색 처리 (Pre-retrieval processing): ● 쿼리 재작성(query rewriting): 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. ● 쿼리 확장(query expansion): 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다. ● 쿼리 변환(query transformation): 원래 쿼리 대신 변환된 쿼리를 기반으로 검색 및 생성을 수행합니다.\n사후 검색 처리 (Post-retrieval processing): ● 검색 결과 재정렬(reranking): 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다. ● 압축(compression): 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다. ● 선택(selection): 관련 없는 덩어리를 직접 제거하여 LLM의 추론 효율성을 향상시킵니다.  \n특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담"
          ],
          "6": [
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다. \n주요 전략 사전 검색 처리 (Pre-retrieval processing): ● 쿼리 재작성(query rewriting): 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. ● 쿼리 확장(query expansion): 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다. ● 쿼리 변환(query transformation): 원래 쿼리 대신 변환된 쿼리를 기반으로 검색 및 생성을 수행합니다.\n사후 검색 처리 (Post-retrieval processing): ● 검색 결과 재정렬(reranking): 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다. ● 압축(compression): 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다. ● 선택(selection): 관련 없는 덩어리를 직접 제거하여 LLM의 추론 효율성을 향상시킵니다.  \n특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 향상된 검색 기법: 질의 처리 후 하이브리드 검색(밀도 기반 임베딩 검색 + 희소 키워드 검색)을 활용해 더 풍부한 결과를 얻습니다 ibm.com . 복잡한 질문의 경우 계층적 인덱싱이나 다단계 검색(예: iterative/recursive retrieval)으로 한층 심화된 검색을 수행하여 정확도를 높입니다 arxiv.org  arxiv.org . \n• 다중 모듈 검색: 질의 종류와 목적에 따라 여러 검색 모듈을 조합합니다. 예를 들어, 임베딩 기반 벡터 검색에 더해 지식 그래프 질의나 API 호출 등 이기종 데이터 검색을 병행할 수 있습니다. 또한 복잡한 문제에 대해 반복적 검색이나 분기 검색 흐름을 구현하여 필요한 정보를 순차적으로 수집할 수 있습니다 arxiv.org . 이러한 유연한 검색 설계로 질의의 의도에 맞게 다양한 소스에서 정보를 획득합니다. 모델 아키텍처 (Model Architecture) • 선형 파이프라인 구조: 인덱싱 → 검색 → 생성의 직렬 단계로 구성된 가장 단순한 형태입니다 arxiv.org . 별도의 최적화 모듈이나 피드백 루프 없이, 검색기와 한 번의 생성기로 답변을 생성합니다. 전체 구조가 단순하여 추가 구성요소가 없습니다. \n• 개선된 단일 흐름 구조: 기본 RAG 파이프라인에 전처리/후처리 모듈을 추가한 구조입니다. 예를 들어, 질의 재작성 모듈로 입력 질문을 명확히 하고 arxiv.org , 재검색 및 재정렬 모듈로 검색 결과를 필터링한 후 LLM에 전달합니다. 응답 생성 후에는 사용자 클릭이나 피드백 등을 활용한 피드백 루프를 도입해 검색기와 생성기를 지속적으로 개선하기도 합니다 \n• 모듈식 아키텍처: 여러 독립 모듈을 레고 블록처럼 연결하여 구성한 프레임워크입니다 arxiv.org . 질의 처리, 검색, 필터링, 생성, 검증 등의 기능이 분리된 모듈로 구현되고, 이들을 제어하는 라우팅/스케줄링 컴포넌트가 존재합니다 arxiv.org . 덕분에 비선형적 흐름도 가능하며 (예: 조건분기나",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다. \n주요 전략 사전 검색 처리 (Pre-retrieval processing): ● 쿼리 재작성(query rewriting): 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. ● 쿼리 확장(query expansion): 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다. ● 쿼리 변환(query transformation): 원래 쿼리 대신 변환된 쿼리를 기반으로 검색 및 생성을 수행합니다.\n사후 검색 처리 (Post-retrieval processing): ● 검색 결과 재정렬(reranking): 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다. ● 압축(compression): 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다. ● 선택(selection): 관련 없는 덩어리를 직접 제거하여 LLM의 추론 효율성을 향상시킵니다.  \n특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 향상된 검색 기법: 질의 처리 후 하이브리드 검색(밀도 기반 임베딩 검색 + 희소 키워드 검색)을 활용해 더 풍부한 결과를 얻습니다 ibm.com . 복잡한 질문의 경우 계층적 인덱싱이나 다단계 검색(예: iterative/recursive retrieval)으로 한층 심화된 검색을 수행하여 정확도를 높입니다 arxiv.org  arxiv.org . \n• 다중 모듈 검색: 질의 종류와 목적에 따라 여러 검색 모듈을 조합합니다. 예를 들어, 임베딩 기반 벡터 검색에 더해 지식 그래프 질의나 API 호출 등 이기종 데이터 검색을 병행할 수 있습니다. 또한 복잡한 문제에 대해 반복적 검색이나 분기 검색 흐름을 구현하여 필요한 정보를 순차적으로 수집할 수 있습니다 arxiv.org . 이러한 유연한 검색 설계로 질의의 의도에 맞게 다양한 소스에서 정보를 획득합니다. 모델 아키텍처 (Model Architecture) • 선형 파이프라인 구조: 인덱싱 → 검색 → 생성의 직렬 단계로 구성된 가장 단순한 형태입니다 arxiv.org . 별도의 최적화 모듈이나 피드백 루프 없이, 검색기와 한 번의 생성기로 답변을 생성합니다. 전체 구조가 단순하여 추가 구성요소가 없습니다. \n• 개선된 단일 흐름 구조: 기본 RAG 파이프라인에 전처리/후처리 모듈을 추가한 구조입니다. 예를 들어, 질의 재작성 모듈로 입력 질문을 명확히 하고 arxiv.org , 재검색 및 재정렬 모듈로 검색 결과를 필터링한 후 LLM에 전달합니다. 응답 생성 후에는 사용자 클릭이나 피드백 등을 활용한 피드백 루프를 도입해 검색기와 생성기를 지속적으로 개선하기도 합니다 \n• 모듈식 아키텍처: 여러 독립 모듈을 레고 블록처럼 연결하여 구성한 프레임워크입니다 arxiv.org . 질의 처리, 검색, 필터링, 생성, 검증 등의 기능이 분리된 모듈로 구현되고, 이들을 제어하는 라우팅/스케줄링 컴포넌트가 존재합니다 arxiv.org . 덕분에 비선형적 흐름도 가능하며 (예: 조건분기나"
          ],
          "7": [
            "Modular RAG에서 AI Agent 아키텍처 Modular RAG(Retrieval-Augmented Generation) 기반 AI 시스템은 정보 검색(Retrieval)과 생성(Generation)을 기능을 모듈화하여 구성된 구조로, 여러 독립적인 모듈을 조합하여 유연하고 확장 가능한 AI를 구축하는 방식입니다. 이 시스템의 핵심 구성 요소는 에이전트(Agent) 모듈(Modules)입니다. 에이전트(Agent)는 전체 워크플로우를 조율하여, 전체시스템의 흐름과 전략적 제어를 담당하는 핵심 역할을 합니다. 기존의 LLM(대규모 언어 모델)이 주로 사전 학습된 지식과 인컨텍스트 학습에 의존하는 것과 달리, 에이전트는 외부 도구(예: 웹 검색, API, 구조화된 데이터베이스)와 동적으로 상호작용하여 그 능력을 확장합니다. 에이전트는 주어진 작업에 따라 어떤 도구를 호출할지 자율적으로 결정하며, 이를 통해 더 정확하고 상황에 맞는 응답을 생성할 수 있습니다. 또한, 에이전트는 고급 라우팅 메커니즘을 활용하여 사용자 쿼리를 분석하고 가장 적합한 데이터 소스나 처리 경로로 안내합니다. 예를 들어, 특정 데이터베이스에서 정보를 검색해야 하는지, 웹 검색을 수행해야 하는지, 또는 도메인 특화 지식을 활용해야 하는지를 스스로 판단할 수 있습니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "Modular RAG에서 AI Agent 아키텍처 Modular RAG(Retrieval-Augmented Generation) 기반 AI 시스템은 정보 검색(Retrieval)과 생성(Generation)을 기능을 모듈화하여 구성된 구조로, 여러 독립적인 모듈을 조합하여 유연하고 확장 가능한 AI를 구축하는 방식입니다. 이 시스템의 핵심 구성 요소는 에이전트(Agent) 모듈(Modules)입니다. 에이전트(Agent)는 전체 워크플로우를 조율하여, 전체시스템의 흐름과 전략적 제어를 담당하는 핵심 역할을 합니다. 기존의 LLM(대규모 언어 모델)이 주로 사전 학습된 지식과 인컨텍스트 학습에 의존하는 것과 달리, 에이전트는 외부 도구(예: 웹 검색, API, 구조화된 데이터베이스)와 동적으로 상호작용하여 그 능력을 확장합니다. 에이전트는 주어진 작업에 따라 어떤 도구를 호출할지 자율적으로 결정하며, 이를 통해 더 정확하고 상황에 맞는 응답을 생성할 수 있습니다. 또한, 에이전트는 고급 라우팅 메커니즘을 활용하여 사용자 쿼리를 분석하고 가장 적합한 데이터 소스나 처리 경로로 안내합니다. 예를 들어, 특정 데이터베이스에서 정보를 검색해야 하는지, 웹 검색을 수행해야 하는지, 또는 도메인 특화 지식을 활용해야 하는지를 스스로 판단할 수 있습니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담"
          ],
          "8": [
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다."
          ],
          "9": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.   \n3.3 서브모듈 하위 모듈 정의 하위 모듈은 상위 모듈의 특정 기능을 세분화하여 실행하는 단위이며, 필요에 따라 추가되거나 조합될 수도 있습니다. 부 시스템에서는 특정 하위 모듈이 여러 모듈에서 공유되거나 독립적으로 실행될 수도 있습니다   \n하위 모듈 역할 하나의 모듈 내에서 복잡한 작업을 여러 하위 단계로 분리하여, 각 단계가 담당하는 역할을 명확히 합니다. 복잡한 작업을 작은 단계로 나누어 처리함으로써 효율성을 높입니다. 상위 모듈의 성능과 유연성을 강화하기 위해 하위 모듈은 세부적인 기능 구현에 집중합니다. 각 하위 모듈은 상위 모듈의 특정 기능을 담당하며, 이를 통해 문제 발생 시 해당 부분만 집중적으로 개선하거나 수정할 수 있습니다. 즉, 하위 모듈은 상위 모듈 내에서 복잡한 작업을 여러 단계로 분리함으로써, 각 단계의 역할과 책임을 명확히 하고, 이를 통해 문제 발생 시 해당 부분만 집중적으로 개선하거나 수정할 수 있도록 지원합니다.   \n하위모듈 특징 ● 세분화 (Decomposition): 상위 모듈의 복잡한 기능을 작고 명확한 단계로 분할하여 관리합니다. ● 독립성 (Independence): 각 하위 모듈은 서로 간섭 없이 독립적으로 작동하여, 다른 부분에 미치는 영향을 최소화합니다. ● 유지보수성 (Maintainability): 문제 발생 시 개별 하위 모듈만 수정하면 되어, 전체 시스템의 유지보수가 용이합니다. ● 재사용성 (Reusability): 잘 정의된 하위 모듈은 다른 모듈이나 프로젝트에서도 쉽게 재사용할 수 있습니다.",
            "3.2 모듈  모듈 정의 모듈은 Modular RAG 시스템의 핵심 구성 블록으로 시스템의 주요 기능이나 임무(예: 정보 검색, 요약, 텍스트 생성 등)를 독립적으로 수행하는 단위입니다. 각 모듈은 특정 작업을 독립적으로 수행하도록 설계되며, 다른 모듈과 별개로 동작할 수 있습니다.  \n모듈의 역할 모듈은 사용자의 요청에 따른 특정 기능을 직접 수행합니다. 모듈은 특정 기능이나 작업을 독립적으로 수행하는 구성 요소입니다. 각 모듈은 전문화된 기능을 담당하며, 에이전트의 지시에 따라 협력하여 최종 목표를 달성합니다.  예를 들어, 검색 모듈은 외부 데이터 소스에서 관련 정보를 검색하고, 생성 모듈은 최종 응답을 생성하는 역할, 데이터 전처리, 텍스트 생성 등의 개별 기능을 담당할 수 있습니다.   \n모듈의 특징 ● 독립성 및 모듈화: 모듈은 독립적인 단위로 설계되어 다른 모듈과 별개로 작동할 수 있으며, 모듈화된 구조를 유지합니다. ● 전문화: 각 모듈은 특정 작업이나 기능에 집중하여 해당 분야에서 최적화되고 전문성을 갖출 수 있습니다. ● 재사용성 및 유연성: 모듈은 시스템 내에서 재사용할 수 있으며, 필요에 따라 쉽게 수정, 교체, 확장할 수 있습니다. 또한, 다른 프로젝트에서도 활용할 수 있습니다. ● 확장성: 새로운 기능이나 서비스가 필요할 경우, 기존 모듈을 확장하거나 새로운 모듈을 추가하여 시스템을 발전시킬 수 있습니다. ● 조합성: 여러 모듈을 결합하여 복잡한 작업을 처리하거나 새로운 기능을 추가할 수 있습니다.\n모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다."
          ],
          "10": [
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "3.2 모듈  모듈 정의 모듈은 Modular RAG 시스템의 핵심 구성 블록으로 시스템의 주요 기능이나 임무(예: 정보 검색, 요약, 텍스트 생성 등)를 독립적으로 수행하는 단위입니다. 각 모듈은 특정 작업을 독립적으로 수행하도록 설계되며, 다른 모듈과 별개로 동작할 수 있습니다.  \n모듈의 역할 모듈은 사용자의 요청에 따른 특정 기능을 직접 수행합니다. 모듈은 특정 기능이나 작업을 독립적으로 수행하는 구성 요소입니다. 각 모듈은 전문화된 기능을 담당하며, 에이전트의 지시에 따라 협력하여 최종 목표를 달성합니다.  예를 들어, 검색 모듈은 외부 데이터 소스에서 관련 정보를 검색하고, 생성 모듈은 최종 응답을 생성하는 역할, 데이터 전처리, 텍스트 생성 등의 개별 기능을 담당할 수 있습니다.   \n모듈의 특징 ● 독립성 및 모듈화: 모듈은 독립적인 단위로 설계되어 다른 모듈과 별개로 작동할 수 있으며, 모듈화된 구조를 유지합니다. ● 전문화: 각 모듈은 특정 작업이나 기능에 집중하여 해당 분야에서 최적화되고 전문성을 갖출 수 있습니다. ● 재사용성 및 유연성: 모듈은 시스템 내에서 재사용할 수 있으며, 필요에 따라 쉽게 수정, 교체, 확장할 수 있습니다. 또한, 다른 프로젝트에서도 활용할 수 있습니다. ● 확장성: 새로운 기능이나 서비스가 필요할 경우, 기존 모듈을 확장하거나 새로운 모듈을 추가하여 시스템을 발전시킬 수 있습니다. ● 조합성: 여러 모듈을 결합하여 복잡한 작업을 처리하거나 새로운 기능을 추가할 수 있습니다.\n모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로"
          ],
          "11": [
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담 \n이 표를 통해 각 RAG 방법론의 특징을 비교하고, 프로젝트 목적과 요구사항에 맞는 최적의 방식을 선택하는 데 도움이 될 수 있습니다. Modular RAG는 높은 유연성과 확장성을 제공하여, 특히 복잡한 도메인 지식이 필요한 분야에서 강력한 성능을 발휘할 수 있습니다.\n3. Modular RAG의 주요 구성 요소 Modular RAG에서 계층구조의 구성 요소와 역할과 세부 내용을 알아봅니다. Agent Workflow Module 주요 프로세스(검색, 증강, 생성 등)를 담당 Submodule 모듈 내부에서 세부적인 작업 단계를 처리 Operator 데이터 처리 및 변환과 같은 기본적인 작업 단위를 수행 \n3.1 Agent 기반의 아키텍처 Modular RAG의 핵심 요소 중 하나는 Agent 기반 아키텍처입니다. 기존 AI 에이전트와 비교했을 때, Modular RAG의 에이전트는 다중 모듈을 조율하고 특정 작업을 수행하는 방식으로 설계됩니다. 이를 통해 보다 유연하고 확장 가능한 AI 시스템을 구축할 수 있습니다. \nAI Agent 아키텍처 AI 에이전트는 특정 목표를 달성하기 위해 환경에서 데이터를 감지하고, 해석하며, 행동하는 시스템입니다. AI 에이전트 아키텍처는 인공지능 시스템이 환경을 인식하고, 분석하며, 행동하는 방식을 정의하는 구조적 설계입니다. 이는 AI 에이전트가 자율적으로 작동하고 목표를 달성할 수 있도록 하는 핵심 요소를 포함하며, 다양한 구성 요소와 설계 패턴으로 이루어집니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담 \n이 표를 통해 각 RAG 방법론의 특징을 비교하고, 프로젝트 목적과 요구사항에 맞는 최적의 방식을 선택하는 데 도움이 될 수 있습니다. Modular RAG는 높은 유연성과 확장성을 제공하여, 특히 복잡한 도메인 지식이 필요한 분야에서 강력한 성능을 발휘할 수 있습니다.\n3. Modular RAG의 주요 구성 요소 Modular RAG에서 계층구조의 구성 요소와 역할과 세부 내용을 알아봅니다. Agent Workflow Module 주요 프로세스(검색, 증강, 생성 등)를 담당 Submodule 모듈 내부에서 세부적인 작업 단계를 처리 Operator 데이터 처리 및 변환과 같은 기본적인 작업 단위를 수행 \n3.1 Agent 기반의 아키텍처 Modular RAG의 핵심 요소 중 하나는 Agent 기반 아키텍처입니다. 기존 AI 에이전트와 비교했을 때, Modular RAG의 에이전트는 다중 모듈을 조율하고 특정 작업을 수행하는 방식으로 설계됩니다. 이를 통해 보다 유연하고 확장 가능한 AI 시스템을 구축할 수 있습니다. \nAI Agent 아키텍처 AI 에이전트는 특정 목표를 달성하기 위해 환경에서 데이터를 감지하고, 해석하며, 행동하는 시스템입니다. AI 에이전트 아키텍처는 인공지능 시스템이 환경을 인식하고, 분석하며, 행동하는 방식을 정의하는 구조적 설계입니다. 이는 AI 에이전트가 자율적으로 작동하고 목표를 달성할 수 있도록 하는 핵심 요소를 포함하며, 다양한 구성 요소와 설계 패턴으로 이루어집니다."
          ],
          "12": [
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다."
          ],
          "13": [
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "※ 참고: 이 예시에서는 코드 내에 Operator와 Sub-module이 직접적으로 드러나지는 않지만, 각 모듈 내부에서 해당 역할을 추상화하여 수행하고 있음을 유념하시기 바랍니다. Building a PDF-Based Retriever Chain from rag.pdf import PDFRetrievalChain  pdf = PDFRetrievalChain([\"data/Newwhitepaper_Agents2.pdf\"]).create_chain()  pdf_retriever = pdf.retriever  pdf_chain = pdf.chain   Query router  chain from typing import Literal  from langchain_core.prompts import ChatPromptTemplate from pydantic import BaseModel, Field from langchain_openai import ChatOpenAI   # 1. Define a Pydantic model for data routing class RouteQuery(BaseModel):     \"\"\"Route a user query to the most relevant datasource.\"\"\"      datasource: Literal[\"vectorstore\", \"web_search\"] = Field(         ...,         description=\"Given a user question choose to route it to web search or a vectorstore.\",",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "※ 참고: 이 예시에서는 코드 내에 Operator와 Sub-module이 직접적으로 드러나지는 않지만, 각 모듈 내부에서 해당 역할을 추상화하여 수행하고 있음을 유념하시기 바랍니다. Building a PDF-Based Retriever Chain from rag.pdf import PDFRetrievalChain  pdf = PDFRetrievalChain([\"data/Newwhitepaper_Agents2.pdf\"]).create_chain()  pdf_retriever = pdf.retriever  pdf_chain = pdf.chain   Query router  chain from typing import Literal  from langchain_core.prompts import ChatPromptTemplate from pydantic import BaseModel, Field from langchain_openai import ChatOpenAI   # 1. Define a Pydantic model for data routing class RouteQuery(BaseModel):     \"\"\"Route a user query to the most relevant datasource.\"\"\"      datasource: Literal[\"vectorstore\", \"web_search\"] = Field(         ...,         description=\"Given a user question choose to route it to web search or a vectorstore.\",",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다."
          ],
          "14": [
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다.",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "※ 참고: 이 예시에서는 코드 내에 Operator와 Sub-module이 직접적으로 드러나지는 않지만, 각 모듈 내부에서 해당 역할을 추상화하여 수행하고 있음을 유념하시기 바랍니다. Building a PDF-Based Retriever Chain from rag.pdf import PDFRetrievalChain  pdf = PDFRetrievalChain([\"data/Newwhitepaper_Agents2.pdf\"]).create_chain()  pdf_retriever = pdf.retriever  pdf_chain = pdf.chain   Query router  chain from typing import Literal  from langchain_core.prompts import ChatPromptTemplate from pydantic import BaseModel, Field from langchain_openai import ChatOpenAI   # 1. Define a Pydantic model for data routing class RouteQuery(BaseModel):     \"\"\"Route a user query to the most relevant datasource.\"\"\"      datasource: Literal[\"vectorstore\", \"web_search\"] = Field(         ...,         description=\"Given a user question choose to route it to web search or a vectorstore.\",",
            "·         청크 최적화(Chunk Optimization): 청크 크기 조정, 겹침 조정, 메타데이터 추가. ·         구조 조직(Structural Organization): 계층적 인덱싱 및 지식 그래프(KG) 기반 인덱싱. Operator는 청크 분할 및 구조화 작업으로 데이터 처리와 관련된 역할을 합니다. 2.     Pre-Retrieval: ·         모듈: 원본 질의를 개선하여 검색 성능을 최적화하는 과정. ·         Operator: ·         Query Expansion (질의 확장): Multi-Query, Sub-Query. ·         Query Transformation (질의 변환): Rewrite, HyDE, Step-back Prompting. ·         Query Construction (질의 구성): Text-to-SQL, Text-to-Cypher. Operator는 질의를 변환하고 확장하는 작업은 데이터 변환 및 분석에 해당합니다. 3.     Retrieval: ·         모듈: 사용자 질의를 기반으로 관련 문서를 검색. ·         Operator: ·         Retriever Selection (검색기 선택): Sparse, Dense, Hybrid Retriever. ·         Retriever Fine-tuning (검색기 미세 조정): Supervised Fine-Tuning(SFT), Adapter. Operator는 검색기 선택과 미세 조정은 검색 효율성을 높이는 핵심 작업을 합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context,",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징"
          ],
          "15": [
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다.",
            "·         청크 최적화(Chunk Optimization): 청크 크기 조정, 겹침 조정, 메타데이터 추가. ·         구조 조직(Structural Organization): 계층적 인덱싱 및 지식 그래프(KG) 기반 인덱싱. Operator는 청크 분할 및 구조화 작업으로 데이터 처리와 관련된 역할을 합니다. 2.     Pre-Retrieval: ·         모듈: 원본 질의를 개선하여 검색 성능을 최적화하는 과정. ·         Operator: ·         Query Expansion (질의 확장): Multi-Query, Sub-Query. ·         Query Transformation (질의 변환): Rewrite, HyDE, Step-back Prompting. ·         Query Construction (질의 구성): Text-to-SQL, Text-to-Cypher. Operator는 질의를 변환하고 확장하는 작업은 데이터 변환 및 분석에 해당합니다. 3.     Retrieval: ·         모듈: 사용자 질의를 기반으로 관련 문서를 검색. ·         Operator: ·         Retriever Selection (검색기 선택): Sparse, Dense, Hybrid Retriever. ·         Retriever Fine-tuning (검색기 미세 조정): Supervised Fine-Tuning(SFT), Adapter. Operator는 검색기 선택과 미세 조정은 검색 효율성을 높이는 핵심 작업을 합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context,",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "※ 참고: 이 예시에서는 코드 내에 Operator와 Sub-module이 직접적으로 드러나지는 않지만, 각 모듈 내부에서 해당 역할을 추상화하여 수행하고 있음을 유념하시기 바랍니다. Building a PDF-Based Retriever Chain from rag.pdf import PDFRetrievalChain  pdf = PDFRetrievalChain([\"data/Newwhitepaper_Agents2.pdf\"]).create_chain()  pdf_retriever = pdf.retriever  pdf_chain = pdf.chain   Query router  chain from typing import Literal  from langchain_core.prompts import ChatPromptTemplate from pydantic import BaseModel, Field from langchain_openai import ChatOpenAI   # 1. Define a Pydantic model for data routing class RouteQuery(BaseModel):     \"\"\"Route a user query to the most relevant datasource.\"\"\"      datasource: Literal[\"vectorstore\", \"web_search\"] = Field(         ...,         description=\"Given a user question choose to route it to web search or a vectorstore.\","
          ],
          "16": [
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "※ 참고: 이 예시에서는 코드 내에 Operator와 Sub-module이 직접적으로 드러나지는 않지만, 각 모듈 내부에서 해당 역할을 추상화하여 수행하고 있음을 유념하시기 바랍니다. Building a PDF-Based Retriever Chain from rag.pdf import PDFRetrievalChain  pdf = PDFRetrievalChain([\"data/Newwhitepaper_Agents2.pdf\"]).create_chain()  pdf_retriever = pdf.retriever  pdf_chain = pdf.chain   Query router  chain from typing import Literal  from langchain_core.prompts import ChatPromptTemplate from pydantic import BaseModel, Field from langchain_openai import ChatOpenAI   # 1. Define a Pydantic model for data routing class RouteQuery(BaseModel):     \"\"\"Route a user query to the most relevant datasource.\"\"\"      datasource: Literal[\"vectorstore\", \"web_search\"] = Field(         ...,         description=\"Given a user question choose to route it to web search or a vectorstore.\",",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723"
          ],
          "17": [
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다."
          ],
          "18": [
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다."
          ],
          "19": [
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "설계 방법 LinkedIn은 시스템은 과거 고객 서비스 문제 티켓에서 Knowledge Graph를 구축하고, 질문 응답 단계에서 소비자 쿼리를 파싱하여 관련 하위 그래프를 식별하고 답변을 생성합니다. 주요 사용 방법은 다음과 같습니다.\n● 지식 그래프 구축 (Knowledge Graph Construction) ○ Intra-ticket 트리 파싱: 텍스트 기반 티켓을 트리 구조로 변환합니다. 규칙 기반 추출과 LLM 파싱을 함께 사용하여 티켓 섹션을 식별하고 계층적으로 연결합니다. ○ Inter-ticket 연결: 개별 트리를 통합하여 포괄적인 그래프를 형성합니다. 티켓에 명시된 명시적 연결과 텍스트 의미 유사성을 기반으로 한 암시적 연결을 모두 활용합니다. ○ 임베딩 생성: BERT, E5와 같은 텍스트 임베딩 모델을 사용하여 그래프 노드 값에 대한 임베딩을 생성하고, 벡터 데이터베이스에 저장하여 검색을 용이하게 합니다. ● 검색 및 질문 응답 (Retrieval and Question Answering) ○ 쿼리 엔터티 식별 및 의도 감지: 사용자 쿼리에서 명명된 엔터티와 쿼리 의도를 추출합니다. LLM을 사용하여 쿼리를 파싱하고, 그래프 템플릿에 따라 키-값 쌍을 추출합니다.\n○ 하위 그래프의 임베딩 기반 검색: 사용자 쿼리에서 파생된 엔터티를 사용하여 관련 하위 그래프를 검색합니다. 코사인 유사도를 사용하여 티켓 수준 점수를 집계하고 상위 K개 티켓을 선택합니다. ○ 답변 생성: 검색된 데이터를 초기 쿼리와 연결하여 답변을 합성합니다. LLM은 검색된 정보를 기반으로 응답을 생성하는 디코더 역할을 합니다. 쿼리 실행에 문제가 발생하면 텍스트 기반 검색 방법으로 대체합니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다."
          ],
          "20": [
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ],
          "21": [
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "6. Conclusion 이 리포트에서는 RAG(Retrieval-Augmented Generation)의 발전 방향을 분석하기 위해, 최근 주목받고 있는 Modular RAG를 중심으로 기존 RAG 패러다임(Naive RAG, Advanced RAG)과 비교하고, 새롭게 등장한 GraphRAG까지 다루었습니다. RAG는 LLM의 한계를 보완하며, 보다 신뢰할 수 있는 검색과 응답 생성을 목표로 발전해왔습니다. 기존 Naive RAG는 단순 검색 기반이었으며, Advanced RAG는 검색 최적화를 추가하여 성능을 향상시켰습니다. 이후 Modular RAG는 검색, 생성, 색인 기능을 독립적인 모듈로 분리하여 유연성과 확장성을 극대화하는 구조로 발전했습니다.  그러나 여전히 검색된 정보의 신뢰성과 정확성을 높이는 것이 중요한 과제로 남아 있으며, 이를 해결하기 위해 GraphRAG가 도입되었습니다. GraphRAG는 기존 벡터 검색의 한계를 보완하기 위해 지식 그래프(Knowledge Graph)를 활용한 검색 방식을 도입하여, 문서 간의 관계를 반영한 보다 정밀한 정보를 제공합니다. LinkedIn 사례에서는 GraphRAG 도입 후 검색 정확도 77.6% 향상, BLEU 점수 0.32 증가, 고객 서비스 해결 시간이 28.6% 단축되는 성과를 거두었습니다. 기존 RAG는 벡터 검색(Vector RAG)에 의존했지만, 최근 GraphRAG, Adaptive Retrieval, Multi-Agent RAG 등의 개념이 등장하며 검색 정확도, 신뢰성, 실시간성, 맥락 최적화가 더욱 강화되고 있습니다. 현재까지의 발전 흐름을 보면, 앞으로는 검색 전략을 스스로 최적화하는 자율적 검색 시스템까지 발전될 수 있는 가능성이 있습니다."
          ],
          "22": [
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "개선사항 구조를 무시하여 발생하는 검색 정확도 저하를 개선 이슈 추적 문서(예: Jira)는 고유한 구조를 가지고 있으며, \"이슈 A는 이슈 B와 관련됨/복사됨/원인이 됨\"과 같은 참조로 상호 연결됩니다. 문서를 텍스트 덩어리로 압축하는 기존 방식은 중요한 정보의 손실을 초래할 수 있습니다. LinkedIn의 접근 방식은 이슈 티켓을 트리로 파싱하고 개별 이슈 티켓을 연결하여 상호 연결된 그래프를 형성함으로써 엔터티 간의 내재적 관계를 유지하여 높은 검색 성능을 달성합니다. \n세분화로 인한 답변 품질 저하를 개선 임베딩 모델의 컨텍스트 길이 제약을 수용하기 위해 광범위한 이슈 티켓을 고정 길이 세그먼트로 분할하면 관련 콘텐츠가 단절되어 불완전한 답변이 발생할 수 있습니다. 예를 들어, 이슈 티켓이 시작 부분에 이슈를 설명하고 끝 부분에 솔루션을 설명하는 경우 텍스트 세분화 프로세스 중에 분할되어 솔루션의 중요한 부분이 생략될 수 있습니다. LinkedIn의 그래프 기반 파싱 방법은 티켓 섹션의 논리적 일관성을 유지하여 완전하고 고품질의 응답을 제공함으로써 이 문제를 극복합니다.  \n결과 LinkedIn의 고객 서비스 팀 내에서 이 방법론을 사용한 결과, 이슈당 중간 해결 시간이 28.6% 감소했습니다. 이는 기존의 수동 방법에 비해 상당한 개선입니다. 구체적으로, Knowledge Graph를 사용하지 않은 그룹의 평균 이슈 해결 시간은 40시간인데 반해, Knowledge Graph를 사용한 그룹은 15시간으로 단축되었습니다. 이는 RAG와 지식 그래프의 통합이 고객 서비스 효율성을 향상시킬 수 있음을 보여줍니다",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "설계 방법 LinkedIn은 시스템은 과거 고객 서비스 문제 티켓에서 Knowledge Graph를 구축하고, 질문 응답 단계에서 소비자 쿼리를 파싱하여 관련 하위 그래프를 식별하고 답변을 생성합니다. 주요 사용 방법은 다음과 같습니다.\n● 지식 그래프 구축 (Knowledge Graph Construction) ○ Intra-ticket 트리 파싱: 텍스트 기반 티켓을 트리 구조로 변환합니다. 규칙 기반 추출과 LLM 파싱을 함께 사용하여 티켓 섹션을 식별하고 계층적으로 연결합니다. ○ Inter-ticket 연결: 개별 트리를 통합하여 포괄적인 그래프를 형성합니다. 티켓에 명시된 명시적 연결과 텍스트 의미 유사성을 기반으로 한 암시적 연결을 모두 활용합니다. ○ 임베딩 생성: BERT, E5와 같은 텍스트 임베딩 모델을 사용하여 그래프 노드 값에 대한 임베딩을 생성하고, 벡터 데이터베이스에 저장하여 검색을 용이하게 합니다. ● 검색 및 질문 응답 (Retrieval and Question Answering) ○ 쿼리 엔터티 식별 및 의도 감지: 사용자 쿼리에서 명명된 엔터티와 쿼리 의도를 추출합니다. LLM을 사용하여 쿼리를 파싱하고, 그래프 템플릿에 따라 키-값 쌍을 추출합니다.\n○ 하위 그래프의 임베딩 기반 검색: 사용자 쿼리에서 파생된 엔터티를 사용하여 관련 하위 그래프를 검색합니다. 코사인 유사도를 사용하여 티켓 수준 점수를 집계하고 상위 K개 티켓을 선택합니다. ○ 답변 생성: 검색된 데이터를 초기 쿼리와 연결하여 답변을 합성합니다. LLM은 검색된 정보를 기반으로 응답을 생성하는 디코더 역할을 합니다. 쿼리 실행에 문제가 발생하면 텍스트 기반 검색 방법으로 대체합니다."
          ],
          "23": [
            "개선사항 구조를 무시하여 발생하는 검색 정확도 저하를 개선 이슈 추적 문서(예: Jira)는 고유한 구조를 가지고 있으며, \"이슈 A는 이슈 B와 관련됨/복사됨/원인이 됨\"과 같은 참조로 상호 연결됩니다. 문서를 텍스트 덩어리로 압축하는 기존 방식은 중요한 정보의 손실을 초래할 수 있습니다. LinkedIn의 접근 방식은 이슈 티켓을 트리로 파싱하고 개별 이슈 티켓을 연결하여 상호 연결된 그래프를 형성함으로써 엔터티 간의 내재적 관계를 유지하여 높은 검색 성능을 달성합니다. \n세분화로 인한 답변 품질 저하를 개선 임베딩 모델의 컨텍스트 길이 제약을 수용하기 위해 광범위한 이슈 티켓을 고정 길이 세그먼트로 분할하면 관련 콘텐츠가 단절되어 불완전한 답변이 발생할 수 있습니다. 예를 들어, 이슈 티켓이 시작 부분에 이슈를 설명하고 끝 부분에 솔루션을 설명하는 경우 텍스트 세분화 프로세스 중에 분할되어 솔루션의 중요한 부분이 생략될 수 있습니다. LinkedIn의 그래프 기반 파싱 방법은 티켓 섹션의 논리적 일관성을 유지하여 완전하고 고품질의 응답을 제공함으로써 이 문제를 극복합니다.  \n결과 LinkedIn의 고객 서비스 팀 내에서 이 방법론을 사용한 결과, 이슈당 중간 해결 시간이 28.6% 감소했습니다. 이는 기존의 수동 방법에 비해 상당한 개선입니다. 구체적으로, Knowledge Graph를 사용하지 않은 그룹의 평균 이슈 해결 시간은 40시간인데 반해, Knowledge Graph를 사용한 그룹은 15시간으로 단축되었습니다. 이는 RAG와 지식 그래프의 통합이 고객 서비스 효율성을 향상시킬 수 있음을 보여줍니다",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "설계 방법 LinkedIn은 시스템은 과거 고객 서비스 문제 티켓에서 Knowledge Graph를 구축하고, 질문 응답 단계에서 소비자 쿼리를 파싱하여 관련 하위 그래프를 식별하고 답변을 생성합니다. 주요 사용 방법은 다음과 같습니다.\n● 지식 그래프 구축 (Knowledge Graph Construction) ○ Intra-ticket 트리 파싱: 텍스트 기반 티켓을 트리 구조로 변환합니다. 규칙 기반 추출과 LLM 파싱을 함께 사용하여 티켓 섹션을 식별하고 계층적으로 연결합니다. ○ Inter-ticket 연결: 개별 트리를 통합하여 포괄적인 그래프를 형성합니다. 티켓에 명시된 명시적 연결과 텍스트 의미 유사성을 기반으로 한 암시적 연결을 모두 활용합니다. ○ 임베딩 생성: BERT, E5와 같은 텍스트 임베딩 모델을 사용하여 그래프 노드 값에 대한 임베딩을 생성하고, 벡터 데이터베이스에 저장하여 검색을 용이하게 합니다. ● 검색 및 질문 응답 (Retrieval and Question Answering) ○ 쿼리 엔터티 식별 및 의도 감지: 사용자 쿼리에서 명명된 엔터티와 쿼리 의도를 추출합니다. LLM을 사용하여 쿼리를 파싱하고, 그래프 템플릿에 따라 키-값 쌍을 추출합니다.\n○ 하위 그래프의 임베딩 기반 검색: 사용자 쿼리에서 파생된 엔터티를 사용하여 관련 하위 그래프를 검색합니다. 코사인 유사도를 사용하여 티켓 수준 점수를 집계하고 상위 K개 티켓을 선택합니다. ○ 답변 생성: 검색된 데이터를 초기 쿼리와 연결하여 답변을 합성합니다. LLM은 검색된 정보를 기반으로 응답을 생성하는 디코더 역할을 합니다. 쿼리 실행에 문제가 발생하면 텍스트 기반 검색 방법으로 대체합니다.",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com"
          ],
          "24": [
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723"
          ],
          "25": [
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트"
          ],
          "26": [
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로"
          ],
          "27": [],
          "28": [
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다."
          ],
          "29": [
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다."
          ],
          "30": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "합니다. 4.     Post-Retrieval: ·         모듈: 검색된 문서를 후처리하여 LLM 입력에 최적화. ·         Operator: ·         Rerank (재정렬): Rule-based Rerank, Model-based Rerank. ·         Compression (압축): Selective Context, LLM-Critique. Operator는 후처리 작업에서 데이터를 정렬하고 압축하여 효율성을 높이는 역할을 합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다."
          ],
          "31": [],
          "32": [
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "핵심 모듈 조합 ● 질문 재작성(Query Rewrite): 모델 기반 접근 방식을 사용하여 사용자 질의를 변환해 보다 정밀한 추천 제공 ● 검색(Retrieve): 희소 인코딩(BM25)을 활용한 키워드 검색과 밀집 임베딩을 통한 의미적 검색을 결합한 하이브리드 검색 방식 적용\n● 생성(Generate): API 기반 또는 온프레미스 LLM을 활용하여 최적의 추천 결과를 생성하고 사용자 맞춤형 설명 제공 ● LLM 보상 강화 학습(LLM Reward Reinforcement Learning): 클릭 및 구매 데이터를 학습하여 질문 재작성 및 검색 프로세스를 지속적으로 최적화 \n설계 흐름 \n 1. 질문 재작성(Query Rewrite) ● 사용자의 검색 질의를 분석하고 최적화하여 추천 정확도를 향상 ● 예시: \"여름 샌들 추천\" → \"2024년 여름 인기 샌들 + 편안한 착용감 + 최신 할인 정보 포함\" 2. 검색(Retrieve) ● 하이브리드 검색 방식을 활용: ○ BM25 (희소 인코딩): 제품 설명, 고객 리뷰, 트렌드 데이터를 직접 키워드 매칭을 통해 검색 ○ 밀집 임베딩(Dense Embeddings): 제품과 사용자 선호도 간의 의미적 관계를 분석하여 맞춤형 추천 제공 ○ 하이브리드 점수 계산: 희소 및 밀집 검색 결과를 결합하여 정밀도와 재현율을 최적화 ● 예시: \"무선 청소기를 최근 검색한 사용자\" → \"무선 청소기 액세서리 + 베스트셀러 청소기 추천\" 3. 생성(Generate) ● API 기반 또는 온프레미스 LLM을 활용하여 개인 맞춤형 추천을 제공하며 설명까지 포함 ● 예시: \"이 제품은 최근 검색한 무선 청소기와 호환되며, 높은 사용자 평점을 받은 제품입니다.\" 4. LLM 보상 강화 학습(LLM Reward Reinforcement Learning) ● 사용자 상호작용(클릭 및 구매 데이터)을 학습하여 질문 재작성 및 검색 프로세스를 최적화 ● 보상 기반 강화 학습을 통해 실시간으로 추천 품질을 조정",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "핵심 모듈 조합 ● 질문 재작성(Query Rewrite): 모델 기반 접근 방식을 사용하여 사용자 질의를 변환해 보다 정밀한 추천 제공 ● 검색(Retrieve): 희소 인코딩(BM25)을 활용한 키워드 검색과 밀집 임베딩을 통한 의미적 검색을 결합한 하이브리드 검색 방식 적용\n● 생성(Generate): API 기반 또는 온프레미스 LLM을 활용하여 최적의 추천 결과를 생성하고 사용자 맞춤형 설명 제공 ● LLM 보상 강화 학습(LLM Reward Reinforcement Learning): 클릭 및 구매 데이터를 학습하여 질문 재작성 및 검색 프로세스를 지속적으로 최적화 \n설계 흐름 \n 1. 질문 재작성(Query Rewrite) ● 사용자의 검색 질의를 분석하고 최적화하여 추천 정확도를 향상 ● 예시: \"여름 샌들 추천\" → \"2024년 여름 인기 샌들 + 편안한 착용감 + 최신 할인 정보 포함\" 2. 검색(Retrieve) ● 하이브리드 검색 방식을 활용: ○ BM25 (희소 인코딩): 제품 설명, 고객 리뷰, 트렌드 데이터를 직접 키워드 매칭을 통해 검색 ○ 밀집 임베딩(Dense Embeddings): 제품과 사용자 선호도 간의 의미적 관계를 분석하여 맞춤형 추천 제공 ○ 하이브리드 점수 계산: 희소 및 밀집 검색 결과를 결합하여 정밀도와 재현율을 최적화 ● 예시: \"무선 청소기를 최근 검색한 사용자\" → \"무선 청소기 액세서리 + 베스트셀러 청소기 추천\" 3. 생성(Generate) ● API 기반 또는 온프레미스 LLM을 활용하여 개인 맞춤형 추천을 제공하며 설명까지 포함 ● 예시: \"이 제품은 최근 검색한 무선 청소기와 호환되며, 높은 사용자 평점을 받은 제품입니다.\" 4. LLM 보상 강화 학습(LLM Reward Reinforcement Learning) ● 사용자 상호작용(클릭 및 구매 데이터)을 학습하여 질문 재작성 및 검색 프로세스를 최적화 ● 보상 기반 강화 학습을 통해 실시간으로 추천 품질을 조정",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징"
          ],
          "33": [
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "Reference ※ 각 파트별 참조한 자료가 있다면 아래 출처 작성 부탁드립니다. ※ 작성 양식 : 문서/페이지명 (링크)  1번파트 - From complex to atomic: Enhancing Augmented Generation via Knowledge-aware Dual Rewriting and Reasoning (https://openreview.net/pdf/eece737929522d36939d3b6cf5da4e8c7921f2ee.pdf) - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/html/2312.10997v5  - Context window overflow: Breaking the barrier https://aws.amazon.com/jp/blogs/security/context-window-overflow-breaking-the-barrier/  - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/html/2407.21059v1  - How does Modular RAG improve upon naive RAG? https://adasci.org/how-does-modular-rag-improve-upon-naive-rag/  - Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "Reference ※ 각 파트별 참조한 자료가 있다면 아래 출처 작성 부탁드립니다. ※ 작성 양식 : 문서/페이지명 (링크)  1번파트 - From complex to atomic: Enhancing Augmented Generation via Knowledge-aware Dual Rewriting and Reasoning (https://openreview.net/pdf/eece737929522d36939d3b6cf5da4e8c7921f2ee.pdf) - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/html/2312.10997v5  - Context window overflow: Breaking the barrier https://aws.amazon.com/jp/blogs/security/context-window-overflow-breaking-the-barrier/  - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/html/2407.21059v1  - How does Modular RAG improve upon naive RAG? https://adasci.org/how-does-modular-rag-improve-upon-naive-rag/  - Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담"
          ],
          "34": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자"
          ],
          "35": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다."
          ],
          "36": [
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다."
          ],
          "37": [
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환 \n 모듈 및 연산자: ● 색인(Indexing) 모듈: 문서 분할, 청크 최적화, 구조화된 인덱싱 등을 담당합니다. ● 사전 검색(Pre-retrieval) 모듈: 쿼리 확장, 쿼리 변환, 쿼리 생성 등을 수행합니다. ● 검색(Retrieval) 모듈: 스파스 검색, 밀집 검색, 하이브리드 검색, 검색 미세 조정 등을 수행합니다. ● 사후 검색(Post-retrieval) 모듈: 재정렬, 압축, 선택 등을 통해 검색된 청크를 처리합니다. ● 생성(Generation) 모듈: LLM을 사용하여 답변을 생성하고, 생성기 미세 조정, 검증 등을 수행합니다. ● 오케스트레이션(Orchestration) 모듈: 라우팅, 스케줄링, 융합 등을 통해 RAG 프로세스를 제어합니다. RAG 흐름 패턴 ● 선형 패턴(Linear Pattern): 모듈이 고정된 순서로 순차적으로 처리됩니다. ● 조건부 패턴(Conditional Pattern): 조건에 따라 다른 RAG 파이프라인을 선택합니다. ● 분기 패턴(Branching Pattern): 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다. ● 루프 패턴(Loop Pattern): 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다. ● 튜닝 패턴(Tuning Pattern): 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n특징"
          ],
          "38": [
            "● 환자 병력 통합(Patient Medical History): 환자의 병력 및 유전적 요인을 반영하여 최적의 치료법 결정 ● 생성(Generation): 최종적으로 융합된 데이터를 바탕으로 최적의 답변 생성 \n설계 흐름 \n 1. 질문 확장(Query Expansion) ● 사용자의 입력을 분석하여 다중 관련 질의 생성 ● 예시: “3일 이상 38도 이상의 발열과 기침\" → \"발열을 유발하는 감염 질환\", \"발열과 기침이 동반되는 질환\" 2. 하이브리드 검색(Hybrid Retrieval) ● Dense Retrieval: 유사 증상을 기반으로 의료 문헌 검색 ● Knowledge Graph: 증상과 질병 간 관계 매핑 3. 생성(Generation, Optional) ● 검색된 정보가 부족할 경우, LLM을 활용하여 초안 생성 4. 융합(Fusion) ● 연구 논문과 임상 가이드를 통합하여 종합적인 답변 도출 ● 신뢰성을 높이기 위해 출처 명확히 명시 5. 환자 병력 통합(Patient Medical History) ● 환자의 병력 및 유전적 요인을 반영하여 맞춤형 치료를 적용 ● 예시: \"당뇨 가족력이 있는 환자를 위한 최적의 독감 치료 옵션\" 6. 생성(Generation) ● 최종 융합된 정보를 바탕으로 사용자 친화적인 의료 조언 제공  \n개선점 ● 단순한 학술 논문 검색을 넘어 임상 데이터와 의료 가이드를 통합하여 더 정밀한 추천 제공 ● 환자 병력 기반 맞춤형 검색을 구현하여 진단의 정확도 향상",
            "4.3 의료 도메인 - AI 기반 진단 및 치료 추천 목표 전통적인 의료 검색 시스템은 주로 학술 논문을 기반으로 하지만, 환자의 증상 및 임상 데이터를 통합하면 더 정밀한 의료 정보를 제공할 수 있습니다. 모듈형 RAG 프레임워크를 활용하여 다수의 의료 데이터 소스를 결합함으로써 신뢰도 높은 검색 결과를 도출하고, 환자의 병력 및 유전적 요인을 반영하여 맞춤형 의료 추천을 제공합니다. \n핵심 모듈 조합 ● 질문 확장(Query Expansion): 사용자의 질의를 세분화하여 관련된 다중 질의 생성 ● 하이브리드 검색(Dense + Knowledge Graph): 증상 기반으로 의료 논문과 임상 가이드를 검색 ● 생성(Generation, Optional): 필요 시 검색된 정보를 기반으로 초기 답변 생성 ● 융합(Fusion): 연구 논문과 임상 가이드를 결합하여 최적의 답변 도출\n● 환자 병력 통합(Patient Medical History): 환자의 병력 및 유전적 요인을 반영하여 최적의 치료법 결정 ● 생성(Generation): 최종적으로 융합된 데이터를 바탕으로 최적의 답변 생성 \n설계 흐름",
            "4.1 도메인별 최적화 전략 각 도메인에 따라 검색 및 생성 패턴을 차별화하여 적용하면, 보다 신뢰도 높은 질의응답 시스템을 구축할 수 있습니다. ● 의료: 신뢰성과 정확성이 중요하므로 하이브리드 검색(Dense + Knowledge Graph) 과 환자 병력 반영을 적용해 맞춤형 치료를 추천합니다. ● 법률: 법적 근거와 판례 분석이 핵심이므로 판단 모듈(Judge) 과 LLM 비판적 평가(Critique) 를 활용해 신뢰성을 높입니다. ● 금융: 실시간 시장 변동 반영이 필수이므로 Text-to-SQL 과 감성 분석(Sentiment Analysis) 을 사용해 투자 인사이트를 강화합니다. ● 전자상거래: 개인화된 추천이 필요하므로 RRR(Rewrite-Retrieve-Read) 패턴 과 강화 학습(LLM Reward RL) 을 활용해 사용자 맞춤 추천을 제공합니다.\n4.2 핵심 개념 정리 \n ● Dense vs. Sparse Retrieval: ○ Dense Retrieval: 의미적 유사도를 기반으로 벡터 검색을 수행하여 가장 관련성이 높은 정보를 검색 ○ Sparse Retrieval (BM25 등): 키워드 기반 검색 방식으로 문서 내 키워드의 빈도 및 위치를 고려해 검색 정확도 향상 ● Query Expansion / Transformation: 사용자의 질의를 보다 풍부하고 정확하게 변형하여 검색 결과 품질 개선 ● Knowledge Graph: 개념 간의 관계를 그래프 구조로 저장하여, 검색 질의와 관련 정보 간 연관성을 강화",
            "• 다단계 데이터 처리 파이프라인: 각 모듈이 전문적인 데이터 처리를 수행합니다. 예를 들어 질의처리 모듈에서 질의를 파싱/정정하고, 필터링 모듈에서 검색된 문서를 메타데이터(날짜 등)나 점수 기준으로 걸러낸 뒤 재정렬합니다 ibm.com . 이어서 컨텍스트 확장 모듈이 지식 그래프나 데이터베이스에서 추가 정보를 보강하고, 필요하다면 retrieved context를 요약/압축하여 최적의 컨텍스트를 준비합니다 ibm.com . 응답 생성 후에도 사실 검증 및 포맷팅 등 후처리 모듈을 통해 출력의 정확성과 일관성을 높이고, 인용 처리까지 수행할 수 있습니다 ibm.com . 이러한 복잡한 처리 절차를 모듈 단위로 나눠 병렬 최적화합니다.\n장점 (Advantages) • 구현 간단 & 속도 빠름: 구조가 단순해 모델 통합과 배포가 용이하고 응답 지연이 적습니다. 별도 최적화 없이도 동작하므로 초기 프로토타입 개발이나 FAQ 수준의 단순 질의응답 등에 빠르게 적용하기 좋습니다 ibm.com  \n• 향상된 정확도 & 적응성: 고급 기법으로 검색 정확도와 문맥 활용도가 높아 보다 정확하고 근거 있는 답변을 제공합니다. 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영해 응답 품질을 지속 개선할 수 있습니다 ibm.com . 그 결과 복잡한 질의나 실무 환경에서도 Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다 ibm.com",
            "개선점 ● 단순한 학술 논문 검색을 넘어 임상 데이터와 의료 가이드를 통합하여 더 정밀한 추천 제공 ● 환자 병력 기반 맞춤형 검색을 구현하여 진단의 정확도 향상\n● 최신 의료 연구 데이터를 실시간 반영하여 최신 치료 방법을 신속하게 제공  4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 목표 전통적인 법률 검색 시스템은 주로 법률 조항을 검색하는 데 초점을 맞추고 있습니다. 하지만 판례, 전문가 의견, 계약 데이터를 통합하여 보다 정밀한 법률 해석을 제공할 수 있다면 어떨까요? 모듈형 RAG 프레임워크를 적용함으로써 법률 문서를 종합적으로 분석하고, 특정 사건과 관할권에 맞는 법률 해석을 추천할 수 있습니다. \n핵심 모듈 조합 ● 판단 모듈(Judge): 사용자의 법률 질의를 분석하여 적절한 검색 방식 결정 ● 검색(Retrieve): 법률 문서, 판례, 계약서 데이터베이스에서 관련 정보 검색 ● 생성(Generate): 검색된 정보를 기반으로 초기 법률 해석 제공 ● 질문 변환(Query Transformation, Optional): 필요 시 사용자의 질문을 법률적 용어로 변환하여 추가 검색 수행 ● LLM 비판적 평가(LLM Critique): 검색된 법률 자료의 신뢰성을 평가하고 불필요한 정보를 필터링 ● 적응형 검색 및 생성(Adaptive Retrieval & Generation): 부족한 법률 자료가 발견되면 추가 검색 수행 ● 반복 RAG 흐름 제어(Loop RAG Flow Orchestration): 법률 질문 유형에 따라 검색 및 생성 프로세스 동적 조정 \n설계 흐름 \n 1. 판단(Judge)"
          ],
          "39": [
            "개선점 ● 단순한 학술 논문 검색을 넘어 임상 데이터와 의료 가이드를 통합하여 더 정밀한 추천 제공 ● 환자 병력 기반 맞춤형 검색을 구현하여 진단의 정확도 향상\n● 최신 의료 연구 데이터를 실시간 반영하여 최신 치료 방법을 신속하게 제공  4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 목표 전통적인 법률 검색 시스템은 주로 법률 조항을 검색하는 데 초점을 맞추고 있습니다. 하지만 판례, 전문가 의견, 계약 데이터를 통합하여 보다 정밀한 법률 해석을 제공할 수 있다면 어떨까요? 모듈형 RAG 프레임워크를 적용함으로써 법률 문서를 종합적으로 분석하고, 특정 사건과 관할권에 맞는 법률 해석을 추천할 수 있습니다. \n핵심 모듈 조합 ● 판단 모듈(Judge): 사용자의 법률 질의를 분석하여 적절한 검색 방식 결정 ● 검색(Retrieve): 법률 문서, 판례, 계약서 데이터베이스에서 관련 정보 검색 ● 생성(Generate): 검색된 정보를 기반으로 초기 법률 해석 제공 ● 질문 변환(Query Transformation, Optional): 필요 시 사용자의 질문을 법률적 용어로 변환하여 추가 검색 수행 ● LLM 비판적 평가(LLM Critique): 검색된 법률 자료의 신뢰성을 평가하고 불필요한 정보를 필터링 ● 적응형 검색 및 생성(Adaptive Retrieval & Generation): 부족한 법률 자료가 발견되면 추가 검색 수행 ● 반복 RAG 흐름 제어(Loop RAG Flow Orchestration): 법률 질문 유형에 따라 검색 및 생성 프로세스 동적 조정 \n설계 흐름 \n 1. 판단(Judge)",
            "설계 흐름 \n 1. 판단(Judge)\n● 사용자의 질문을 평가하여 검색이 필요한지 직접 생성이 필요한지 결정 ● 예시: \"근무 시간 변경 요청을 거부할 수 있는가?\" → \"근로 계약서에 명시되지 않은 근무 시간 변경 거부 가능 여부\" 2. 검색(Retrieve) ● 판례 검색(Case Law): 관련 과거 판결 사례 검색 ● 법률 조항 검색(Legislation): 관련 법 조항 검색 ● 계약서 데이터베이스 검색(Contracts DB): 표준 계약 조항 확인 3. 생성(Generate) ● 검색된 정보를 바탕으로 법률 해석을 제공 4. LLM 비판적 평가(LLM Critique) ● 검색된 법률 자료의 신뢰성과 관련성을 평가하여 불필요한 정보를 필터링 5. 적응형 검색 및 생성(Adaptive Retrieval & Generation) ● 추가적인 법률 참고 자료가 필요하면 자동으로 추가 검색 수행 ● 전문가 의견을 반영하여 법률 해석 강화 6. 반복 RAG 흐름 제어(Loop RAG Flow Orchestration) ● 계약 관련 질의 → 계약 조항 + 판례 검색 ● 형사법 관련 질의 → 법률 조항 + 형사 판례 검색 ● 행정법 관련 질의 → 정부 가이드라인 검색  \n개선점 ● 단순한 법률 조항 검색을 넘어 판례, 계약, 전문가 의견을 통합하여 실용적인 법률 상담 시스템 구축 ● 최신 법률 개정 사항을 자동 반영하여 신뢰도를 높이고, 지역별 법률 차이를 반영 ● 사용자 의도를 분석하여 보다 정밀한 법률 추천 제공  \n4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 목표 투자 정보를 검색할 때 단순한 데이터 검색만으로는 충분하지 않습니다. 금융 재무제표, 경제 뉴스, 애널리스트 보고서를 통합하여 보다 포괄적인 분석을 제공할 수 있다면 어떨까요? 모듈형 RAG을 활용하여 다양한 데이터 소스를 결합함으로써 보다 정밀한 투자 인사이트를 제공하고 실시간 시장 변동에 적응하는 검색 시스템을 구축할 수 있습니다.",
            "3.2 모듈  모듈 정의 모듈은 Modular RAG 시스템의 핵심 구성 블록으로 시스템의 주요 기능이나 임무(예: 정보 검색, 요약, 텍스트 생성 등)를 독립적으로 수행하는 단위입니다. 각 모듈은 특정 작업을 독립적으로 수행하도록 설계되며, 다른 모듈과 별개로 동작할 수 있습니다.  \n모듈의 역할 모듈은 사용자의 요청에 따른 특정 기능을 직접 수행합니다. 모듈은 특정 기능이나 작업을 독립적으로 수행하는 구성 요소입니다. 각 모듈은 전문화된 기능을 담당하며, 에이전트의 지시에 따라 협력하여 최종 목표를 달성합니다.  예를 들어, 검색 모듈은 외부 데이터 소스에서 관련 정보를 검색하고, 생성 모듈은 최종 응답을 생성하는 역할, 데이터 전처리, 텍스트 생성 등의 개별 기능을 담당할 수 있습니다.   \n모듈의 특징 ● 독립성 및 모듈화: 모듈은 독립적인 단위로 설계되어 다른 모듈과 별개로 작동할 수 있으며, 모듈화된 구조를 유지합니다. ● 전문화: 각 모듈은 특정 작업이나 기능에 집중하여 해당 분야에서 최적화되고 전문성을 갖출 수 있습니다. ● 재사용성 및 유연성: 모듈은 시스템 내에서 재사용할 수 있으며, 필요에 따라 쉽게 수정, 교체, 확장할 수 있습니다. 또한, 다른 프로젝트에서도 활용할 수 있습니다. ● 확장성: 새로운 기능이나 서비스가 필요할 경우, 기존 모듈을 확장하거나 새로운 모듈을 추가하여 시스템을 발전시킬 수 있습니다. ● 조합성: 여러 모듈을 결합하여 복잡한 작업을 처리하거나 새로운 기능을 추가할 수 있습니다.\n모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다."
          ],
          "40": [
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "● Fusion & Re-rank: 다중 검색 결과를 조합하고 가중치를 조정하여 최적의 답변을 생성 ● Text-to-SQL: 자연어 질의를 SQL 쿼리로 변환하여 구조화된 데이터에서 정밀 검색 수행 ● RRR (Rewrite-Retrieve-Read): 검색 질의를 효과적으로 변형(Rewrite) → 검색(Retrieve) 수행 → 검색된 정보를 해석(Read)하여 최적의 답변 생성 ● LLM Reward RL (LLM 보상 강화 학습): AI 모델이 사용자 상호작용 데이터를 학습하여 검색 및 추천 시스템을 지속적으로 개선 ● Adaptive Retrieval & Generation (적응형 검색 및 생성): 초기 검색 결과가 부족할 경우 추가 검색을 수행하고, 생성 모델이 정보를 보강하여 최적의 답변 제공 ● LLM Critique (LLM 비판적 평가): 생성된 응답의 신뢰도를 평가하고 오류를 수정하여 정확성을 보장 ● Hybrid Search (하이브리드 검색): Sparse 검색(BM25)과 Dense 검색(임베딩 검색)을 결합하여 검색 성능 최적화 RAG 기반 검색 시스템을 도메인별 특성에 맞춰 최적화하면, 의료, 법률, 금융, 전자상거래 등 다양한 분야에서 정확성, 신뢰성, 개인화, 실시간성을 극대화할 수 있습니다. 이 과정에서 Agent가 적절한 Module과 Operator를 조합하여 실행하는 방식이 중요한 역할을 하며, 이를 통해 복잡한 질의응답 프로세스를 효과적으로 처리할 수 있습니다. 이제부터는 각 도메인별로 최적화된 검색 및 생성 패턴이 어떻게 적용되는지 구체적인 사례를 살펴보겠습니다.",
            "5. 순위 조정(Re-rank) ● 검색된 데이터를 신뢰도 및 관련성에 따라 재정렬 6. 감성 분석(Sentiment Analysis) ● 뉴스 및 소셜 미디어의 감성 분석을 통해 투자 심리 평가 ● 예시: \"테슬라 주가가 최근 하락했지만 소셜 미디어에서 긍정적인 분위기가 나타나 단기 회복 가능성이 있음\" 7. 가중 융합(Weighted Fusion) ● 각 데이터 출처의 신뢰도를 기반으로 가중치를 부여하여 최적의 투자 보고서 생성 ● 예시: SEC 공식 공시 > 애널리스트 보고서 > 뉴스 > 소셜 미디어 (신뢰도 높은 순서) 8. 생성(Generation) ● AI 기반 투자 조언 및 시장 분석 제공 ● 예시: \"테슬라의 최근 분기 실적이 예상보다 높았지만 원자재 가격 상승이 향후 이익률에 압박을 가할 수 있음\" \n개선점 ● 자연어 질의를 SQL로 변환(Text-to-SQL)하여 사용자가 특정 금융 지표를 직접 검색할 수 있도록 지원 ● 애널리스트 보고서, 경제 뉴스, 소셜 미디어 감성 분석을 통합하여 투자 판단의 신뢰도 향상 ● 실시간 시장 반응을 분석하여 최신 경제 데이터를 자동 반영하는 적응형 검색 기능 구현  \n4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 목표 기존 전자상거래 추천 시스템은 주로 협업 필터링에 의존하지만, 개별 사용자의 취향과 실시간 검색 의도를 정확하게 반영하는 데 어려움이 있습니다. 이를 해결하기 위해 RRR(Rewrite-Retrieve-Read) 패턴 기반의 RAG 추천 시스템을 적용할 수 있습니다. 이 시스템은 사용자 질의를 최적화하고, 다양한 소스에서 관련 데이터를 검색하며, 실시간으로 개인화된 추천을 제공합니다. 또한, 강화 학습을 활용하여 추천 품질을 지속적으로 개선할 수 있습니다.",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "● Fusion & Re-rank: 다중 검색 결과를 조합하고 가중치를 조정하여 최적의 답변을 생성 ● Text-to-SQL: 자연어 질의를 SQL 쿼리로 변환하여 구조화된 데이터에서 정밀 검색 수행 ● RRR (Rewrite-Retrieve-Read): 검색 질의를 효과적으로 변형(Rewrite) → 검색(Retrieve) 수행 → 검색된 정보를 해석(Read)하여 최적의 답변 생성 ● LLM Reward RL (LLM 보상 강화 학습): AI 모델이 사용자 상호작용 데이터를 학습하여 검색 및 추천 시스템을 지속적으로 개선 ● Adaptive Retrieval & Generation (적응형 검색 및 생성): 초기 검색 결과가 부족할 경우 추가 검색을 수행하고, 생성 모델이 정보를 보강하여 최적의 답변 제공 ● LLM Critique (LLM 비판적 평가): 생성된 응답의 신뢰도를 평가하고 오류를 수정하여 정확성을 보장 ● Hybrid Search (하이브리드 검색): Sparse 검색(BM25)과 Dense 검색(임베딩 검색)을 결합하여 검색 성능 최적화 RAG 기반 검색 시스템을 도메인별 특성에 맞춰 최적화하면, 의료, 법률, 금융, 전자상거래 등 다양한 분야에서 정확성, 신뢰성, 개인화, 실시간성을 극대화할 수 있습니다. 이 과정에서 Agent가 적절한 Module과 Operator를 조합하여 실행하는 방식이 중요한 역할을 하며, 이를 통해 복잡한 질의응답 프로세스를 효과적으로 처리할 수 있습니다. 이제부터는 각 도메인별로 최적화된 검색 및 생성 패턴이 어떻게 적용되는지 구체적인 사례를 살펴보겠습니다.",
            "5. 순위 조정(Re-rank) ● 검색된 데이터를 신뢰도 및 관련성에 따라 재정렬 6. 감성 분석(Sentiment Analysis) ● 뉴스 및 소셜 미디어의 감성 분석을 통해 투자 심리 평가 ● 예시: \"테슬라 주가가 최근 하락했지만 소셜 미디어에서 긍정적인 분위기가 나타나 단기 회복 가능성이 있음\" 7. 가중 융합(Weighted Fusion) ● 각 데이터 출처의 신뢰도를 기반으로 가중치를 부여하여 최적의 투자 보고서 생성 ● 예시: SEC 공식 공시 > 애널리스트 보고서 > 뉴스 > 소셜 미디어 (신뢰도 높은 순서) 8. 생성(Generation) ● AI 기반 투자 조언 및 시장 분석 제공 ● 예시: \"테슬라의 최근 분기 실적이 예상보다 높았지만 원자재 가격 상승이 향후 이익률에 압박을 가할 수 있음\" \n개선점 ● 자연어 질의를 SQL로 변환(Text-to-SQL)하여 사용자가 특정 금융 지표를 직접 검색할 수 있도록 지원 ● 애널리스트 보고서, 경제 뉴스, 소셜 미디어 감성 분석을 통합하여 투자 판단의 신뢰도 향상 ● 실시간 시장 반응을 분석하여 최신 경제 데이터를 자동 반영하는 적응형 검색 기능 구현  \n4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 목표 기존 전자상거래 추천 시스템은 주로 협업 필터링에 의존하지만, 개별 사용자의 취향과 실시간 검색 의도를 정확하게 반영하는 데 어려움이 있습니다. 이를 해결하기 위해 RRR(Rewrite-Retrieve-Read) 패턴 기반의 RAG 추천 시스템을 적용할 수 있습니다. 이 시스템은 사용자 질의를 최적화하고, 다양한 소스에서 관련 데이터를 검색하며, 실시간으로 개인화된 추천을 제공합니다. 또한, 강화 학습을 활용하여 추천 품질을 지속적으로 개선할 수 있습니다."
          ],
          "41": [
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ],
          "42": [
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ],
          "43": [
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ],
          "44": [
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여 적절한 모듈을 호출하고 실행 순서를 조정하며, 필요할 경우 실행 도중 워크플로우를 변경할 수도 있습니다. AI 에이전트는 자율적으로 환경과 상호작용하며 특정 목표를 달성하기 위해 설계된 독립적인 시스템입니다. 에이전트는 데이터를 감지하고, 분석하며, 의사결정을 내리고, 행동을 수행하는 능력을 갖추고 있습니다. Tools는 Agent가 직접 호출할 수도 있고, 특정 모듈 내부에서 독립적인 기능을 수행할 수도 있습니다. 예를 들어, API 호출 기능을 수행하는 Tools는 모듈에서 직접 호출될 수 있으며, 경우에 따라 Agent가 직접 Tools를 실행하여 특정 기능을 수행할 수도 있습니다.",
            "Modular RAG에서 AI Agent 특징: ● 동적 워크플로우 관리: 상황에 따라 필요한 모듈들을 선택하고 연결하여 유연한 작업 흐름을 구성합니다. ● 라우팅(Routing) : 복잡한 문제 해결이나 전략 수립이 필요할 때, 어떤 작업을 먼저 수행할지 판단하고 전체 프로세스를 관리합니다. ● 모듈 간 인터페이스 관리: 각 모듈과 하위 모듈 간의 데이터 교환, 호출 순서, 의존성 등을 조율하여 시스템의 일관성을 유지합니다. 각 에이전트는 특정 역할(예: 검색, 생성, 데이터 처리 등)을 담당하며, 독립적으로 실행됩니다. 다중 에이전트 시스템(Multi-Agent System)에서 각 에이전트는 서로 다른 모듈과 연결되어 작업을 분담합니다. 에이전트 간 메시지 전달 및 협업을 통해 복잡한 작업을 수행합니다. ● 유연성과 확장성: 새로운 기능을 추가하려면 해당 기능을 수행하는 새로운 에이전트를 추가하면 됩니다. ● 병렬 처리: 여러 에이전트가 동시에 작업하여 효율성을 향상됩니다.   AI Agent 상호작용 Agent는 LLM과 Tools, Prompt를 활용하여 전체 워크플로우를 조율하고 작업을 수행합니다. Tools는 특정 기능(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 경우에 따라 이를 하나의 모듈로 간주할 수 있습니다. 또한, Tools 내부에서 세부적인 작업(예: API 호출 또는 데이터 필터링)을 하위 모듈로 정의할 수 있습니다. 일부 시스템에서는 LLM이 독립적인 모듈로 동작할 수도 있으며, 특정 Tools는 Agent 없이도 직접 실행될 수 있습니다. 예시 ● 검색 에이전트: 외부 데이터베이스에서 정보를 검색(tavily search, web-scrapper). ● 문서작성 에이전트: 검색된 데이터를 바탕으로 문서 작성합니다. ● 그래프 작성 에이전트: 검색된 데이터를 바탕으로 필요에 따라서 그래프 작성(python repl)합니다. ● 감독 에이전트: 여러 에이전트를 조율하여 최적의 결과를 도출합니다."
          ],
          "45": [
            "5.     Generation: ·         모듈: 검색된 정보를 바탕으로 답변 생성. ·         Operator: ·         Generator Fine-tuning: Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning. ·         Verification: Knowledge-based Verification, Model-based Verification. Operator는 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다. 6.     Orchestration: ·         모듈: RAG 시스템의 전체 흐름 제어 및 동적 의사결정 수행. ·         Operator: ·         Routing (라우팅): Hybrid Routing. ·         Scheduling (스케줄링): Rule-based Judge, LLM-based Judge, Knowledge-guided Scheduling. ·         Fusion (융합): LLM Fusion, Weighted Ensemble, RRF(Reciprocal Rank Fusion). Operator는 라우팅 및 스케줄링은 동적 의사결정을 지원하는 역할을 합니다.",
            "● 확장성 (Scalability): 새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다. \n 3.4 연산자 연산자 정의 \nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.  \n모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다. \n연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.  \n모듈별 Operator 예시 인덱싱 (Indexing): ·         모듈: 문서를 청크로 나누고 최적화하는 역할. ·         Operator:",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여 적절한 모듈을 호출하고 실행 순서를 조정하며, 필요할 경우 실행 도중 워크플로우를 변경할 수도 있습니다. AI 에이전트는 자율적으로 환경과 상호작용하며 특정 목표를 달성하기 위해 설계된 독립적인 시스템입니다. 에이전트는 데이터를 감지하고, 분석하며, 의사결정을 내리고, 행동을 수행하는 능력을 갖추고 있습니다. Tools는 Agent가 직접 호출할 수도 있고, 특정 모듈 내부에서 독립적인 기능을 수행할 수도 있습니다. 예를 들어, API 호출 기능을 수행하는 Tools는 모듈에서 직접 호출될 수 있으며, 경우에 따라 Agent가 직접 Tools를 실행하여 특정 기능을 수행할 수도 있습니다."
          ],
          "46": [
            "2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다. \n주요 전략 사전 검색 처리 (Pre-retrieval processing): ● 쿼리 재작성(query rewriting): 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. ● 쿼리 확장(query expansion): 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다. ● 쿼리 변환(query transformation): 원래 쿼리 대신 변환된 쿼리를 기반으로 검색 및 생성을 수행합니다.\n사후 검색 처리 (Post-retrieval processing): ● 검색 결과 재정렬(reranking): 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다. ● 압축(compression): 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다. ● 선택(selection): 관련 없는 덩어리를 직접 제거하여 LLM의 추론 효율성을 향상시킵니다.  \n특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다.",
            "2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다. \n주요 전략 사전 검색 처리 (Pre-retrieval processing): ● 쿼리 재작성(query rewriting): 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다. ● 쿼리 확장(query expansion): 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다. ● 쿼리 변환(query transformation): 원래 쿼리 대신 변환된 쿼리를 기반으로 검색 및 생성을 수행합니다.\n사후 검색 처리 (Post-retrieval processing): ● 검색 결과 재정렬(reranking): 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다. ● 압축(compression): 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다. ● 선택(selection): 관련 없는 덩어리를 직접 제거하여 LLM의 추론 효율성을 향상시킵니다.  \n특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다."
          ],
          "47": [
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "● Fusion & Re-rank: 다중 검색 결과를 조합하고 가중치를 조정하여 최적의 답변을 생성 ● Text-to-SQL: 자연어 질의를 SQL 쿼리로 변환하여 구조화된 데이터에서 정밀 검색 수행 ● RRR (Rewrite-Retrieve-Read): 검색 질의를 효과적으로 변형(Rewrite) → 검색(Retrieve) 수행 → 검색된 정보를 해석(Read)하여 최적의 답변 생성 ● LLM Reward RL (LLM 보상 강화 학습): AI 모델이 사용자 상호작용 데이터를 학습하여 검색 및 추천 시스템을 지속적으로 개선 ● Adaptive Retrieval & Generation (적응형 검색 및 생성): 초기 검색 결과가 부족할 경우 추가 검색을 수행하고, 생성 모델이 정보를 보강하여 최적의 답변 제공 ● LLM Critique (LLM 비판적 평가): 생성된 응답의 신뢰도를 평가하고 오류를 수정하여 정확성을 보장 ● Hybrid Search (하이브리드 검색): Sparse 검색(BM25)과 Dense 검색(임베딩 검색)을 결합하여 검색 성능 최적화 RAG 기반 검색 시스템을 도메인별 특성에 맞춰 최적화하면, 의료, 법률, 금융, 전자상거래 등 다양한 분야에서 정확성, 신뢰성, 개인화, 실시간성을 극대화할 수 있습니다. 이 과정에서 Agent가 적절한 Module과 Operator를 조합하여 실행하는 방식이 중요한 역할을 하며, 이를 통해 복잡한 질의응답 프로세스를 효과적으로 처리할 수 있습니다. 이제부터는 각 도메인별로 최적화된 검색 및 생성 패턴이 어떻게 적용되는지 구체적인 사례를 살펴보겠습니다.",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "● Fusion & Re-rank: 다중 검색 결과를 조합하고 가중치를 조정하여 최적의 답변을 생성 ● Text-to-SQL: 자연어 질의를 SQL 쿼리로 변환하여 구조화된 데이터에서 정밀 검색 수행 ● RRR (Rewrite-Retrieve-Read): 검색 질의를 효과적으로 변형(Rewrite) → 검색(Retrieve) 수행 → 검색된 정보를 해석(Read)하여 최적의 답변 생성 ● LLM Reward RL (LLM 보상 강화 학습): AI 모델이 사용자 상호작용 데이터를 학습하여 검색 및 추천 시스템을 지속적으로 개선 ● Adaptive Retrieval & Generation (적응형 검색 및 생성): 초기 검색 결과가 부족할 경우 추가 검색을 수행하고, 생성 모델이 정보를 보강하여 최적의 답변 제공 ● LLM Critique (LLM 비판적 평가): 생성된 응답의 신뢰도를 평가하고 오류를 수정하여 정확성을 보장 ● Hybrid Search (하이브리드 검색): Sparse 검색(BM25)과 Dense 검색(임베딩 검색)을 결합하여 검색 성능 최적화 RAG 기반 검색 시스템을 도메인별 특성에 맞춰 최적화하면, 의료, 법률, 금융, 전자상거래 등 다양한 분야에서 정확성, 신뢰성, 개인화, 실시간성을 극대화할 수 있습니다. 이 과정에서 Agent가 적절한 Module과 Operator를 조합하여 실행하는 방식이 중요한 역할을 하며, 이를 통해 복잡한 질의응답 프로세스를 효과적으로 처리할 수 있습니다. 이제부터는 각 도메인별로 최적화된 검색 및 생성 패턴이 어떻게 적용되는지 구체적인 사례를 살펴보겠습니다.",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담"
          ],
          "48": [
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "3.6 UseCase: Accuracy Improvement This case demonstrates how Modular RAG can enhance accuracy. 앞서 설명한 구성요소들이 실제 코드 구현에서 어떻게 반영되는지 확인합니다.. 아래의 실습 코드는 PDF 기반 리트리버 체인, Query Router, Hallucination Checker 등 다양한 체인을 통해 Modular RAG의 구성요소들이 검색, 증강, 생성 과정을 조율하며 정확도를 향상시키는 사례를 보여줍니다.",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "풍부한 문맥을 제공할 수도 있습니다. 이처럼 Modular RAG는 다양한 데이터 소스를 유연하게 조합하여 보다 정확하고 문맥적으로 풍부한 응답을 생성할 수 있도록 설계됩니다. ● LangGraph를 활용한 오케스트레이션 (Orchestration with LangGraph):  LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화할 수 있습니다. 이를 통해 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.  LangGraph는 RAG 시스템에서 유연하고 동적인 워크플로우를 구성할 수 있도록 도와주는 프레임워크로, 다양한 모듈 간의 흐름을 효율적으로 조정할 수 있습니다. 이를 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅(Conditional Routing), 병렬 처리(Fan-out/Fan-in), 순환 흐름(Cyclic Workflow) 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다. 또한, 단기 및 장기 메모리(Short & Long-Term Memory)를 적용하여 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공할 수 있으며, 유연한 동적 워크플로우(Dynamic Workflow)를 지원함으로써 다양한 데이터 소스(SQL, API, Web Search 등)와의 연계를 강화하고 실행 중 동적으로 경로를 변경할 수 있습니다."
          ],
          "49": [
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "개선사항 구조를 무시하여 발생하는 검색 정확도 저하를 개선 이슈 추적 문서(예: Jira)는 고유한 구조를 가지고 있으며, \"이슈 A는 이슈 B와 관련됨/복사됨/원인이 됨\"과 같은 참조로 상호 연결됩니다. 문서를 텍스트 덩어리로 압축하는 기존 방식은 중요한 정보의 손실을 초래할 수 있습니다. LinkedIn의 접근 방식은 이슈 티켓을 트리로 파싱하고 개별 이슈 티켓을 연결하여 상호 연결된 그래프를 형성함으로써 엔터티 간의 내재적 관계를 유지하여 높은 검색 성능을 달성합니다. \n세분화로 인한 답변 품질 저하를 개선 임베딩 모델의 컨텍스트 길이 제약을 수용하기 위해 광범위한 이슈 티켓을 고정 길이 세그먼트로 분할하면 관련 콘텐츠가 단절되어 불완전한 답변이 발생할 수 있습니다. 예를 들어, 이슈 티켓이 시작 부분에 이슈를 설명하고 끝 부분에 솔루션을 설명하는 경우 텍스트 세분화 프로세스 중에 분할되어 솔루션의 중요한 부분이 생략될 수 있습니다. LinkedIn의 그래프 기반 파싱 방법은 티켓 섹션의 논리적 일관성을 유지하여 완전하고 고품질의 응답을 제공함으로써 이 문제를 극복합니다.  \n결과 LinkedIn의 고객 서비스 팀 내에서 이 방법론을 사용한 결과, 이슈당 중간 해결 시간이 28.6% 감소했습니다. 이는 기존의 수동 방법에 비해 상당한 개선입니다. 구체적으로, Knowledge Graph를 사용하지 않은 그룹의 평균 이슈 해결 시간은 40시간인데 반해, Knowledge Graph를 사용한 그룹은 15시간으로 단축되었습니다. 이는 RAG와 지식 그래프의 통합이 고객 서비스 효율성을 향상시킬 수 있음을 보여줍니다",
            "설계 방법 LinkedIn은 시스템은 과거 고객 서비스 문제 티켓에서 Knowledge Graph를 구축하고, 질문 응답 단계에서 소비자 쿼리를 파싱하여 관련 하위 그래프를 식별하고 답변을 생성합니다. 주요 사용 방법은 다음과 같습니다.\n● 지식 그래프 구축 (Knowledge Graph Construction) ○ Intra-ticket 트리 파싱: 텍스트 기반 티켓을 트리 구조로 변환합니다. 규칙 기반 추출과 LLM 파싱을 함께 사용하여 티켓 섹션을 식별하고 계층적으로 연결합니다. ○ Inter-ticket 연결: 개별 트리를 통합하여 포괄적인 그래프를 형성합니다. 티켓에 명시된 명시적 연결과 텍스트 의미 유사성을 기반으로 한 암시적 연결을 모두 활용합니다. ○ 임베딩 생성: BERT, E5와 같은 텍스트 임베딩 모델을 사용하여 그래프 노드 값에 대한 임베딩을 생성하고, 벡터 데이터베이스에 저장하여 검색을 용이하게 합니다. ● 검색 및 질문 응답 (Retrieval and Question Answering) ○ 쿼리 엔터티 식별 및 의도 감지: 사용자 쿼리에서 명명된 엔터티와 쿼리 의도를 추출합니다. LLM을 사용하여 쿼리를 파싱하고, 그래프 템플릿에 따라 키-값 쌍을 추출합니다.\n○ 하위 그래프의 임베딩 기반 검색: 사용자 쿼리에서 파생된 엔터티를 사용하여 관련 하위 그래프를 검색합니다. 코사인 유사도를 사용하여 티켓 수준 점수를 집계하고 상위 K개 티켓을 선택합니다. ○ 답변 생성: 검색된 데이터를 초기 쿼리와 연결하여 답변을 합성합니다. LLM은 검색된 정보를 기반으로 응답을 생성하는 디코더 역할을 합니다. 쿼리 실행에 문제가 발생하면 텍스트 기반 검색 방법으로 대체합니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다."
          ]
        },
        "response": {
          "0": "RAG",
          "1": "1.  **Retrieval:** 데이터 검색 및 쿼리\n2.  **Reasoning:** 정보 처리 및 추론\n3.  **Generation:** 결과 생성 및 응답",
          "2": "Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다.\n",
          "3": "Naïve RAG는 사용자 프롬프트를 직접적으로 처리하고, 그 프롬프트에 따라 답변을 생성하는 방식입니다.",
          "4": "Shallow Query Understanding",
          "5": "Advanced RAG에서 도입된 사전 검색 처리 기법은 다음과 같습니다.\n\n1.  **쿼리 재작성 (Query Rewriting)**: 쿼리를 더 명확하고 구체적으로 만들어 검색 정확도를 높입니다.\n2.  **쿼리 확장 (Query Expansion)**: 단일 쿼리를 여러 쿼리로 확장하여 쿼리 내용을 풍부하게 하고, 특정 뉘앙스의 부족을 해결합니다.",
          "6": "Advanced RAG의 사후 검색 처리 기법 예시 두 가지는 다음과 같습니다.\n\n1.  **검색 결과 재정렬 (Reranking):** 검색된 덩어리의 내용이나 길이를 변경하지 않고, 더 중요한 문서 덩어리의 가시성을 높입니다.\n2.  **압축 (Compression):** 검색된 내용에서 불필요한 부분을 제거하여 LLM이 핵심 정보를 더 잘 인식하도록 돕습니다.",
          "7": "Modular RAG의 핵심 개념은 다음과 같습니다.\n\n1.  **독립적인 모듈과 특수 연산자:** Modular RAG는 검색, 생성, 라우팅 등 각 기능을 독립적인 모듈로 구성하고, 각 모듈은 특수 연산자로 연결되어 있습니다.\n2.  **유연하고 확장 가능한 구조:** 모듈을 통해 시스템을 수정 없이 쉽게 개선하고 확장할 수 있습니다.\n3.  **라우팅 및 도구 사용:** 쿼리를 분석하고 가장 적합한 데이터 소스나 처리 경로로 안내하는 라우팅 메커니즘을 활용하여 효율적인 쿼리 처리와 상황에 맞는 응답을 보장합니다.\n4.  **추론 및 라우팅 프레임워크:** ReAct 프로세스와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다.\n5.  **다중 데이터 소스 통합:** 다양한 데이터 소스를 활용하여 지식을 보강하고, 실시간 API를 통해 동적으로 정보를 가져올 수 있습니다.\n6.  **고정된 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합:** 기존 RAG의 고정된 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하여 전체 시스템의 효율성을 극대화합니다.\n\n요약하자면, Modular RAG는 **모듈화된 구조와 유연한 워크플로우를 통해 정보 검색, 생성, 라우팅 등 각 기능을 독립적으로 관리하고 확장할 수 있도록 설계된 프레임워크**입니다.",
          "8": "Modular RAG의 3단계 구조는 다음과 같습니다.\n\n1.  **모듈 (Module):** 독립적인 단계를 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다.\n2.  **하위 모듈 (Sub-module):** 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다.\n3.  **연산자 (Operator):** 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.\n\n이러한 구조를 통해 시스템의 복잡성을 관리하고, 각 구성 요소의 역할을 명확하게 분담하여 효율적인 시스템 구축이 가능합니다.\n",
          "9": "다음은 질문에 대한 답변입니다.\n\n*   **Module:** 시스템의 주요 기능이나 임무를 수행하는 독립적인 단위입니다. 특정 작업을 수행하도록 설계되며, 다른 모듈과 별개로 동작할 수 있습니다.\n*   **Submodule:** Module의 특정 기능을 세분화하여 실행하는 단위입니다. 각 Submodule은 특정 작업을 수행하도록 설계되며, 상위 모듈의 특정 기능을 담당합니다.\n*   **Operator:** 모듈 내에서 특정 작업을 수행하는 최소 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다.",
          "10": "Modular RAG의 '오케스트레이션 모듈'은 시스템의 주요 기능인 검색, 랭킹, 필터링, 생성 등 다양한 작업을 독립적으로 수행하는 단위입니다. 즉, **검색, 랭킹, 필터링, 생성** 등의 작업을 최적화하고 관리하는 역할을 담당합니다.  이를 통해 시스템의 전체적인 성능을 향상시키고, 사용자에게 더 정확하고 유용한 결과를 제공할 수 있도록 지원합니다.\n",
          "11": "Modular RAG의 동적 워크플로우 예시 패턴 세 가지는 다음과 같습니다.\n\n1.  **조건부 라우팅 (Conditional Routing):** 검색된 문서의 순위를 재조정하고, 특정 조건에 따라 다른 검색 방식을 선택합니다.\n2.  **병렬 처리 (Fan-out/Fan-in):** 검색된 문서를 여러 개의 하위 모듈에 분산하여 처리합니다.\n3.  **순환 흐름 (Cyclic Workflow):** 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공합니다.\n\n이러한 패턴들을 통해 Modular RAG는 복잡한 데이터 처리 과정을 효율적으로 관리하고, 사용자 요구에 따라 유연하게 대응할 수 있습니다.",
          "12": "Modular RAG에서 'Hybrid Search'는 단순 벡터 검색 하이브리드 검색(키워드+시맨틱)을 결합합니다.\n",
          "13": "Modular RAG의 'Pre-retrieval' 모듈의 Operator 예시는 다음과 같습니다.\n\n1.  **Web Scraper Operator:** 웹 스크래퍼는 PDF 파일에서 필요한 데이터를 추출하여 검색 엔진에 제공하는 역할을 수행합니다. 예를 들어, PDF 파일의 내용을 파싱하여 특정 키워드나 문서를 찾을 수 있도록 합니다.\n2.  **API Call Operator:** API 호출은 외부 데이터 소스에 접근하여 데이터를 가져오는 중요한 기능입니다.  `Tavily API`와 같은 API를 호출하여 데이터를 가져오고, 필요한 정보를 추출하여 검색 엔진에 제공합니다.\n\n이 두 Operator는 'Pre-retrieval' 모듈의 핵심적인 역할을 수행하며, 데이터 추출 및 외부 데이터 소스 연동을 통해 검색 정확도를 향상시키는 데 기여합니다.\n",
          "14": "Retrieval 모듈의 Operator는 **Retriever Selection (검색기 선택)** 입니다.\n\n**설명:**\n\nRetrieval 모듈은 다양한 검색기(Sparse, Dense, Hybrid 등)를 선택하고, 각 검색기마다 다른 방식으로 검색된 문서를 처리합니다.  \"Sparse, Dense, Hybrid Retriever\"는 검색기 선택의 핵심적인 역할을 나타냅니다.  이러한 선택은 검색 효율성을 높이고, 검색 결과의 품질을 향상시키는 데 중요한 역할을 합니다.\n",
          "15": "## 컨텍스트 분석 및 종합 답변\n\n이 컨텍스트는 검색 엔진 및 자연어 처리(NLP) 시스템의 개발 및 운영에 대한 내용을 담고 있습니다. 핵심은 **Retrieval-Augmented Generation (RAG)** 시스템 구축에 초점을 맞추고 있으며, 각 모듈의 역할과 연관성을 명확하게 설명하고 있습니다.  다음은 컨텍스트를 바탕으로 종합적으로 답변입니다.\n\n**1. 핵심 개념 및 목표:**\n\n* **RAG (Retrieval-Augmented Generation):**  기존의 전통적인 검색 엔진 방식과는 달리, 검색된 문서를 LLM(Large Language Model)에 입력하여 답변 생성 과정을 돕는 방식입니다.  이 컨텍스트는 RAG 시스템의 핵심적인 특징을 강조하고 있습니다.\n* **모듈화된 접근 방식:**  RAG 시스템은 여러 개의 모듈로 구성되어 있으며, 각 모듈은 특정 역할을 수행합니다.  이러한 모듈화는 시스템의 확장성, 유지보수성, 재사용성을 높이는 데 기여합니다.\n* **Operator의 역할:**  각 모듈은 특정 작업을 수행하는 'Operator'를 통해 작동합니다.  Operator는 모듈 내에서 실행 단위로 정의되며, 독립적으로 작동합니다.\n\n**2. 주요 모듈 및 역할:**\n\n* **Post-Retrieval:** 검색된 문서를 후처리하여 LLM 입력에 최적화합니다.  이 단계는 검색된 정보의 품질을 높이고, LLM의 성능을 향상시키는 데 중요한 역할을 합니다.\n* **Chunk Optimization:** 청크 크기 조정, 겹침 조정, 메타데이터 추가 등 데이터 처리 과정을 최적화합니다.  데이터의 효율적인 관리 및 분석을 돕습니다.\n* **구조 조직 (Structural Organization):** 계층적 인덱싱 및 지식 그래프(KG) 기반 인덱싱을 통해 데이터 구조를 체계적으로 관리하고, 지식 검색을 용이하게 합니다.\n* **Pre-Retrieval:** 원본 질의를 개선하여 검색 성능을 최적화하는 과정입니다.\n* **Query Expansion (질의 확장):** Multi-Query, Sub-Query 등 질의를 확장하여 검색 범위를 넓히고, 다양한 질문에 대한 답변을 제공합니다.\n* **Query Transformation (질의 변환):** Rewrite, HyDE, Step-back Prompting 등 질의를 변환하여 LLM이 더 효과적으로 이해하고 답변을 생성하도록 돕습니다.\n* **Retrieval:** 사용자 질의를 기반으로 관련 문서를 검색합니다.\n* **Post-Retrieval:** 검색된 문서를 후처리하여 LLM 입력에 최적화합니다.  이 단계는 LLM의 성능을 향상시키고, 답변의 정확성과 관련성을 높이는 데 중요한 역할을 합니다.\n\n**3. 연산자 (Operator)의 역할 및 관계:**\n\n* **Operator**는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다.\n* 각 Operator는 독립적으로 작동하며, 입력과 출력을 통해 모듈 내에서 실제 실행 단위로 작동합니다.\n* Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다.\n* **Modular RAG:** 모듈과 연산자의 계층 구조를 기반으로, 각 모듈은 여러 Operator로 구성됩니다.  각 모듈은 고유한 Operator를 포함하고, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다.\n\n**4. 확장성 (Scalability) 고려 사항:**\n\n* **확장성:**  새로운 기능 추가나 변경이 필요할 때, 특정 하위 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 보장합니다.  이는 시스템의 유연성을 높이고, 변화에 대한 적응력을 향상시키는 데 중요합니다.\n\n**5.  추가적인 고려 사항:**\n\n* **RAG의 성능 개선:**  검색된 문서를 후처리하는 과정에서,  검색 정확도와 문맥 활용도를 높이기 위한 추가적인 최적화가 필요할 수 있습니다.\n* **지식 그래프(KG) 활용:** 지식 그래프를 활용하여 검색된 문서를 더욱 효과적으로 활용하고, 답변의 정확성과 관련성을 높일 수 있습니다.\n* **모델 미세 조정:**  특정 도메인이나 질문에 대한 답변을 위해 모델을 미세 조정하는 것을 고려할 수 있습니다.\n\n**결론:**\n\n이 컨텍스트는 RAG 시스템의 핵심적인 구성 요소와 역할을 명확하게 제시하고 있습니다.  모듈화된 접근 방식과 Operator의 역할, 그리고 확장성 고려 사항을 통해,  효율적이고 신뢰성 있는 자연어 처리 시스템 구축에 대한 중요한 정보를 제공합니다.  이러한 정보는 RAG 시스템 개발 및 운영에 대한 이해를 돕고, 시스템의 성능 향상에 기여할 수 있습니다.\n",
          "16": "## 3.5 전체적인 구조 예시 Modular RAG의 관점에서 답변\n\n**Agent: 검색 에이전트**\n\n**├── Module: 데이터 검색 모듈**\n\n**│   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)**\n**│   ├── Sub-module: 웹 스크래퍼 (Web Scraping)**\n**│   │   ├── Operator: 파싱 연산자**\n**│   │   ├── Operator: 데이터 필터링 연산자**\n**│   │   └── Sub-module: API 호출 (Tavily API)**\n**│   │       ├── Operator: 응답 데이터 정제 연산자**\n**│   │       └── Operator: 검색 결과 랭킹 연산자**\n\n**● 확장성 (Scalability)**\n\nModular RAG는 각 모듈을 독립적으로 확장하거나 교체할 수 있도록 설계되었습니다. 이는 시스템의 확장성을 보장합니다. 새로운 기능 추가나 변경이 필요할 때, 특정 모듈을 확장하거나 교체함으로써 전체 시스템의 확장성을 유지할 수 있습니다.\n\n**3.4 연산자 연산자 정의**\n\nOperator는 모듈 내에서 특정 작업을 수행하는 가장 작은 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.\n\n**모듈과 연산자의 관계 Modular RAG는 모듈(Module)과 연산자(Operator)의 계층 구조를 기반으로 하며, 각 모듈은 여러 Operator로 구성됩니다.각 모듈(인덱싱, Pre-Retrieval, Retrieval, Post-Retriever, Generation, Orchestration 등)이 고유한 Operator를 포함하고 있으며, 이를 통해 특정 기능을 수행하도록 설계되어 있습니다.**\n\n**연산자 역할 Operator는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다.** Operator는 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.\n\n**모듈별 Operator 예시 인덱싱 (Indexing):**\n\n*   **모듈: 문서를 청크로 나누고 최적화하는 역할.**\n*   **Operator:** 로그 기록 연산자 (모듈 레벨에서 동작)\n\n**이 예시에서는 코드 내에 Operator와 Sub-module이 직접적으로 드러나지는 않지만, 각 모듈 내부에서 해당 역할을 추상화하여 수행하고 있음을 유념하시기 바랍니다.**\n",
          "17": "Modular RAG의 장점은 다음과 같습니다.\n\n*   **유연성 및 확장성:** 모듈화된 구조로 인해 워크플로를 쉽게 조정하고, 새로운 도메인이나 데이터 소스를 추가할 수 있습니다.\n*   **고급 검색 및 생성:** 단순 벡터 검색을 넘어, 하이브리드 검색, 다중 데이터 소스 활용, 적응형 검색 등 고급 검색 기법을 도입하여 성능을 향상시킬 수 있습니다.\n*   **독립적인 관리:** 각 모듈을 독립적으로 업그레이드, 교체, 최적화하여 시스템을 수정하지 않고도 개선할 수 있습니다.\n*   **정밀한 응답:** 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅이 가능합니다.\n*   **다중 데이터 소스 통합:** 기존 RAG는 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다.\n\n요약하자면, Modular RAG의 핵심은 **유연하고 확장 가능한 아키텍처**를 통해 다양한 요구사항에 맞춰 시스템을 구축하고 개선할 수 있다는 점입니다.",
          "18": "Modular RAG의 다중 데이터 소스 통합은 다음과 같은 이유로 가능합니다.\n\n* **동적 워크플로우:** 모듈형 아키텍처를 통해 각 모듈은 특정 데이터 소스에 대한 독립적인 기능을 수행합니다.\n* **조건부 처리:**  질의의 의도에 따라 워크플로우를 조정할 수 있도록 설계되었습니다.\n* **병렬 처리:**  다양한 데이터 소스를 활용하여 검색 및 생성 과정을 병렬적으로 처리할 수 있습니다.\n* **유연한 구성:**  각 모듈을 업그레이드, 교체, 최적화하여 시스템을 쉽게 개선할 수 있습니다.\n* **도메인별 특화:** 각 모듈은 특정 도메인에 특화된 검색 및 생성 패턴을 적용할 수 있도록 설계되었습니다.\n* **에이전트:** 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다.\n* **모듈:** 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다.\n* **Operator:** 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다.\n\n이러한 요소들이 결합되어 Modular RAG는 다양한 데이터 소스를 효과적으로 활용하여 더욱 정확하고 풍부한 응답을 생성할 수 있도록 합니다.",
          "19": "LangGraph를 활용한 오케스트레이션은 다음과 같은 기능들을 제공합니다.\n\n*   **의사결정, 스케줄링, 데이터 융합:** 의사결정, 스케줄링, 데이터 융합 기법을 최적화하여 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정합니다.\n*   **동적 질의 확장:** 쿼리 확장을 통해 검색 결과의 정확도를 높입니다.\n*   **재랭킹:** 쿼리 랭킹을 개선하여 더 관련성 높은 결과를 제공합니다.\n*   **다중 회차 대화 지원:** 이전 대화 및 검색 이력을 기억하고 일관성 있는 응답을 제공합니다.\n*   **유연한 동적 워크플로우:** 조건부 라우팅, 병렬 처리, 순환 흐름 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축합니다.\n\n이러한 기능들을 통해 단순한 직렬 실행 방식이 아닌 조건부 라우팅, 병렬 처리, 순환 흐름 등의 패턴을 활용하여 최적의 데이터 처리 경로를 구축할 수 있습니다. 이를 통해 Human-in-the-Loop을 활용한 사용자 개입이 가능하며, 신뢰도가 낮은 응답에 대한 검증 및 보정을 수행할 수 있습니다.",
          "20": "GraphRAG의 핵심 구성 요소는 다음과 같습니다:\n\n1.  **쿼리 프로세서:** 쿼리를 전처리하고 분석합니다.\n2.  **검색기 (Retriever):** 그래프 구조를 기반으로 정보를 검색합니다.\n3.  **구성기 (Organizer):** 그래프를 정리하고 노이즈를 제거합니다.\n4.  **생성기 (Generator):** 그래프 정보를 LLM에 제공하여 답변을 생성합니다.\n5.  **그래프 데이터 소스:** 다양한 그래프 데이터 형태를 지원합니다.",
          "21": "GraphRAG는 기존 RAG 대비 다음과 같은 주요 이점을 강화합니다.\n\n1.  **연결성 활용:** GraphRAG는 그래프 구조를 활용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다. 이는 기존 RAG가 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 한계가 있었던 문제를 해결합니다.\n2.  **추가 정보 검색 능력:** GraphRAG는 쿼리와 관련된 정보 검색을 통해 답변 정확도를 향상시킵니다.\n3.  **개인화된 추천:** 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천을 제공합니다.\n4.  **추가적인 구성 요소:** GraphRAG는 쿼리 프로세서, 검색기, 구성기, 생성기, 그래프 데이터 소스 등 다양한 구성 요소로 구성되어 있어 시스템의 효율성, 확장성, 신뢰성을 높입니다.\n5.  **다양한 데이터 형식 처리:** GraphRAG는 텍스트, 이미지 외에도 다양한 그래프 구조 데이터를 처리할 수 있습니다.\n6.  **강화 학습:** 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현합니다.\n\n요약하자면, GraphRAG는 **연결성을 활용하고, 외부 정보 검색을 통해 답변 정확도를 높이며, 개인화된 추천을 제공하고, 시스템의 효율성과 확장성을 높이는 등 기존 RAG 대비 강화된 기능들을 제공합니다.**",
          "22": "LinkedIn은 고객 서비스 팀 내에서 이 방법론을 사용한 결과, 이슈당 중간 해결 시간이 28.6% 감소했습니다. 이는 기존의 수동 방법에 비해 상당한 개선입니다. 구체적으로, Knowledge Graph를 사용하지 않은 그룹의 평균 이슈 해결 시간은 40시간인데 반해, Knowledge Graph를 사용한 그룹은 15시간으로 단축되었습니다. 이는 RAG와 지식 그래프의 통합이 고객 서비스 효율성을 향상시킬 수 있음을 보여줍니다.\n\nLinkedIn이 GraphRAG를 도입한 목적은 **고객 서비스 문제 티켓에서 Knowledge Graph를 구축하고, 질문 응답 단계에서 소비자 쿼리를 파싱하여 관련 하위 그래프를 식별하고 답변을 생성하는 데 있습니다.**\n",
          "23": "LinkedIn의 GraphRAG 시스템은 이슈당 중간 해결 시간이 28.6% 감소했습니다.",
          "24": "Naive RAG를 적용하기 적합한 분야는 다음과 같습니다.\n\n*   **단순한 질의 응답:** FAQ, 간단한 정보 검색, 텍스트 기반 질문 등과 같이 핵심적인 정보만 필요한 질의에 적합합니다.\n*   **데이터 기반 작업:** 데이터 분석, 데이터 시각화, 데이터 기반 의사 결정 등과 같이 데이터에 대한 이해를 바탕으로 답변을 생성해야 하는 작업에 활용할 수 있습니다.\n*   **실시간 정보 처리:** 실시간 데이터에 대한 질문에 대한 답변을 빠르게 제공해야 하는 경우, Naive RAG보다 빠른 응답 속도를 제공할 수 있습니다.\n*   **구조화된 데이터 활용:** 지식 그래프나 데이터베이스와 같은 구조화된 데이터에서 정보를 추출하여 활용해야 하는 경우, Modular RAG와 같이 데이터 구조를 활용하여 검색 및 생성 과정을 최적화할 수 있습니다.\n*   **초기 프로토타입 개발 및 FAQ 수준의 질의응답:** 빠르게 테스트하고, 사용자 피드백을 반영하여 응답 품질을 개선하는 데 유용합니다.\n\n**요약:** Naive RAG는 기본적인 질의 응답에 적합하며, Advanced RAG는 검색 효율성을 높이고, 사용자 피드백을 반영하여 응답 품질을 개선하는 데 초점을 맞추고 있습니다.",
          "25": "Advanced RAG를 주로 활용하는 도메인은 **대규모 데이터 활용이 중요한 법률, 의료, 금융 분야**입니다. 특히, 다음과 같은 특징을 가지고 있습니다.\n\n*   **대규모 데이터 활용:** 법률, 의료, 금융 등 복잡한 데이터와 지식을 활용하여 정확하고 신뢰성 있는 정보를 제공해야 합니다.\n*   **지속적인 업데이트:** 법률 및 의료 지식은 끊임없이 변화하므로, 지식 업데이트를 지속적으로 수행해야 합니다.\n*   **정확성 및 신뢰성:** 법률 및 의료 정보는 정확성과 신뢰성이 매우 중요하므로, 오류를 최소화해야 합니다.\n*   **최신 정보 반영:** 법률 및 의료 지식은 빠르게 변화하므로, 최신 정보를 반영해야 합니다.\n\n이러한 특징들을 고려하여 Advanced RAG는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다양한 기능을 통해 활용됩니다.",
          "26": "Modular RAG는 특히 다음과 같은 분야에서 강력한 성능을 발휘합니다.\n\n*   **정확도 향상:** 앞서 설명한 것처럼, 단순 벡터 검색 하이브리드 검색(키워드+시맨틱)을 통해 쿼리 이해도를 높이고, 검색 후처리를 통해 정확성을 향상시킵니다.\n*   **유연한 워크플로우:** 동적 워크플로우를 통해 질의의 복잡성과 의도에 따라 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선, 병렬 처리 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다.\n*   **다양한 데이터 소스 연동:** LangGraph를 활용하여 의사결정, 스케줄링, 데이터 융합(Fusion) 기법을 최적화하여 검색 및 랭킹 모듈 간의 상호작용을 원활하게 조정하고, 동적 질의 확장(Query Expansion), 재랭킹(Re-ranking), 다중 회차 대화(Multi-turn Dialogue) 지원이 가능합니다.\n*   **도메인 특화 적용:** 특정 도메인에 맞게 구성 요소를 추가하여, 각 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다.\n\n요약하자면, Modular RAG는 **정확도 향상, 유연한 워크플로우, 다양한 데이터 소스 연동, 도메인 특화 적용** 등 다양한 측면에서 강력한 성능을 발휘합니다.",
          "27": "1.  **요구사항 정의:** 사용자 요구사항 파악\n2.  **데이터 수집:** 필요한 데이터 검색 및 추출\n3.  **데이터 정제:** 불필요한 데이터 제거 및 품질 향상\n4.  **데이터 통합:** 여러 데이터 소스 통합\n5.  **지식 추출:** 핵심 정보 추출 및 모델링\n6.  **지식 활용:** 질문에 대한 답변 생성",
          "28": "RAG의 주요 문제점 중 하나인 'Hallucination'은 검색된 결과가 사실과 다를 수 있는 현상입니다. 즉, RAG가 생성하는 정보가 실제로는 존재하지 않거나, 잘못된 정보를 제공하는 것을 의미합니다.",
          "29": "Modular RAG의 '루프 패턴'은 Agent, Module, Operator를 포함하는 시스템 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 수행하는 최소 단위의 실행 컴포넌트들을 모듈처럼 활용하고, 시스템 내에서 모듈이 호출하는 외부 리소스로 간주하는 방식입니다.",
          "30": "조건부 패턴에서 사용되는 주요 기능은 다음과 같습니다.\n\n*   **모듈:** 각 모듈은 특정 데이터 처리 작업을 수행하며, 각 모듈은 고유한 Operator를 가지고 있습니다.\n*   **Operator:** 각 모듈은 데이터 처리, 변환, 분석 등의 작업을 담당하며, Operator는 데이터 처리, 변환, 분석 등의 역할을 수행합니다.\n*   **Rerank (재정렬):** 검색된 문서를 재정렬하여 더 정확하고 근거 있는 답변을 제공합니다.\n*   **Compression (압축):** Selective Context, LLM-Critique를 통해 효율성을 높입니다.\n*   **선형 패턴:** 모듈이 고정된 순서로 처리됩니다.\n*   **조건부 패턴:** 조건에 따라 다른 RAG 파이프라인을 선택합니다.\n*   **분기 패턴:** 여러 병렬 실행 분기를 사용하여 생성된 결과의 다양성을 높입니다.\n*   **루프 패턴:** 반복, 재귀, 적응형 검색을 통해 검색 및 생성 단계를 상호 의존적으로 처리합니다.\n*   **튜닝 패턴:** 검색기, 생성기 또는 둘 다를 미세 조정하여 시스템 성능을 최적화합니다.\n\n이 외에도, 각 모듈은 특정 데이터 처리 작업을 수행하며, 서로 연관되어 작동합니다.",
          "31": "분기 패턴은 데이터 분석 및 시각화에 유용한 도구입니다.",
          "32": "## 컨텍스트 분석 및 답변\n\n컨텍스트를 바탕으로 질문 \"Tuning Pattern의 역할은?\"에 대한 답변은 다음과 같습니다.\n\n**Tuning Pattern의 역할은, 모델 기반 접근 방식을 사용하여 사용자 질의를 변환하여 보다 정밀한 추천을 제공하는 것입니다.**\n\n좀 더 자세히 설명하면 다음과 같습니다.\n\n* **사용자 질의 분석 및 최적화:** Tuning Pattern은 사용자의 검색 질의를 분석하여, 모델 기반 접근 방식을 통해 더욱 정밀한 추천을 제공하기 위해 질의를 변환합니다.\n* **추천 정확도 향상:** 이를 통해 모델 기반 접근 방식을 사용하여 보다 정확하고 근거 있는 답변을 제공합니다.\n* **실시간 정보 및 도메인 특화 지식 통합:** 실시간 정보나 도메인 특화 지식을 통합하여 최신 질문에도 대응하고, 사용자 피드백을 학습에 반영하여 응답 품질을 지속적으로 개선합니다.\n* **복잡한 질의 및 실무 환경에서의 신뢰성 확보:** Naive RAG보다 신뢰도 높은 결과를 제공하여 활용 범위가 넓습니다.\n\n요약하자면, Tuning Pattern은 모델 기반 접근 방식을 통해 사용자 질의를 분석하고, 이를 바탕으로 추천 정확도를 높이고, 사용자에게 더 유용한 정보를 제공하기 위한 핵심적인 역할을 수행합니다.\n",
          "33": "RAG의 한계 중 '출처 불명확성'을 개선하기 위한 기법은 다음과 같습니다.\n\n*   **개인 정보 보호 기술:** 민감한 데이터 보호를 위한 개인 정보 보호 기술을 적용하여 시스템에 대한 신뢰도를 높입니다.\n*   **설명 가능성:** 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도를 향상시킵니다.\n*   **새로운 응용 분야:** 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략을 개발합니다.\n\n이러한 개선을 통해 RAG의 신뢰성을 높이고, 사용자가 시스템을 더 쉽게 이해하고 사용할 수 있도록 돕습니다.",
          "34": "Modular RAG에서 'Reducer' 연산자는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. 특히, 데이터 정제, 필터링, 분석 등의 역할을 수행합니다.\n\n**좀 더 자세히 설명하면:**\n\n'Reducer' 연산자는 데이터 처리, 변환, 분석 등의 작업을 담당하며, 모듈 내에서 실제 실행 단위로 작동합니다. 데이터 처리(예: 청크 최적화), 변환(예: 질의 변환), 분석(예: Rerank) 등의 역할을 수행합니다.\n\n**구체적인 예시:**\n\n*   **Dense vs Sparse Retrieval 방식:** 검색 모듈에서 'Reducer' 연산자를 사용하여 검색 결과를 정렬하고 최적화합니다.\n*   **Fusion & Re-rank:** 검색 결과를 정렬하고 최적화하는 연산자를 포함한 모듈로 구현됩니다.\n*   **LLM Critique:** 생성된 응답을 평가하는 과정에서 'Reducer' 연산자를 사용하여 품질을 개선합니다.\n\n따라서 'Reducer' 연산자는 데이터 처리 및 분석을 수행하는 핵심적인 역할을 담당하며, Modular RAG의 전체적인 시스템을 효율적으로 운영하는 데 기여합니다.\n",
          "35": "Summarizer Operator는 검색된 정보를 바탕으로 답변 생성에 필요한 핵심적인 역할을 수행합니다. 구체적으로, Generator Fine-tuning, Verification, Routing 등의 Operator를 통해 생성된 답변의 품질을 향상시키는 데 기여합니다. 즉, 검색된 정보를 바탕으로 답변의 핵심 내용을 요약하고, 정확성을 높이며, 답변의 흐름을 개선하는 데 도움을 줍니다.\n",
          "36": "Modular RAG의 'Paraphraser' Operator는 검색된 문서를 기반으로 자연어 응답을 생성하는 데 사용됩니다. 텍스트를 다른 표현으로 변환하여 문장의 의미를 유지하면서 다른 뉘앙스를 전달하는 역할을 합니다.\n\n**핵심 내용:**\n\n*   **역할:** 검색된 문서를 기반으로 자연어 응답을 생성하는 데 사용됩니다.\n*   **기능:** 텍스트를 더 자연스럽고 다양한 표현으로 변환합니다.\n*   **예시:** LinkedIn에서 사용한 Graph RAG를 통해 40시간에서 15시간으로 Ticket Resolution Time를 단축하는 데 사용되었습니다.",
          "37": "## 금융 도메인에서 활용되는 RAG 패턴\n\n금융 도메인에서 RAG는 다음과 같은 패턴을 활용하여 활용되고 있습니다.\n\n**1. 법률 및 금융 데이터 통합:**\n\n* **규정 준수 및 문서 검색:** 금융 규정 및 법률 문서의 핵심 내용을 빠르게 검색하여 관련 정보를 추출하고 분석합니다. 예를 들어, 특정 금융 상품의 규제 변경 사항을 검색하거나, 특정 거래에 대한 법적 의무를 확인하는 데 활용됩니다.\n* **계약 및 문서 분석:** 계약서, 법률 문서, 보고서 등 금융 관련 문서를 분석하여 중요한 조항, 위험 요소, 의무 사항 등을 파악합니다.\n* **사례 연구 및 법률 검토:** 과거 판례, 법률 검토 자료 등을 검색하여 법률 문제 해결에 필요한 정보를 제공합니다.\n\n**2. 투자 및 시장 분석:**\n\n* **시장 동향 분석:** 실시간 시장 데이터, 뉴스, 분석 보고서 등을 검색하여 투자 결정을 위한 정보 제공\n* **리스크 관리:** 특정 기업 또는 자산에 대한 리스크를 분석하고, 위험 요소를 식별하여 관리 전략 수립에 활용\n* **투자 포트폴리오 최적화:** 투자 포트폴리오의 성과를 분석하고, 최적의 투자 전략을 제안합니다.\n\n**3. 고객 서비스 및 상담:**\n\n* **고객 문의 응답:** 고객 문의에 대한 답변을 빠르게 제공하고, 문제 해결을 돕습니다.\n* **자산 관리:** 고객의 자산 정보를 검색하고, 자산 관련 질문에 답변합니다.\n* **맞춤형 금융 상품 추천:** 고객의 금융 상황과 목표에 맞는 상품을 추천합니다.\n\n**4. 데이터 분석 및 보고:**\n\n* **데이터 시각화:** 금융 데이터를 시각화하여 분석 결과를 쉽게 이해할 수 있도록 합니다.\n* **보고서 생성:** 금융 관련 보고서를 자동으로 생성합니다.\n\n**5. 특정 금융 상품 (예: 신용 평가, 대출 심사 등)에 특화된 RAG:**\n\n* **신용 평가 모델 개선:** 신용 평가 모델의 정확도를 높이기 위해 특정 신용 데이터와 분석 결과를 검색하고 활용합니다.\n* **대출 심사 자동화:** 대출 심사 과정을 자동화하고, 심사 결과에 대한 검토를 수행합니다.\n\n**핵심:** 금융 도메인에서 RAG는 **신뢰성 있는 정보 검색 및 분석**을 통해 **의사 결정**을 지원하고, **규제 준수 및 위험 관리**를 강화하는 데 중요한 역할을 합니다.  특히, **데이터의 정확성과 최신성을 유지**하는 것이 중요하며, 이를 위해 **지속적인 데이터 업데이트 및 검증**이 필요합니다.\n",
          "38": "질문: 의료 도메인에서 Query Expansion이 필요한 이유는?\n\n답변: 의료 도메인에서 Query Expansion은 사용자의 질문을 보다 풍부하고 정확하게 변형하여 검색 결과 품질을 개선하는 과정입니다. 따라서, 질문의 의도를 명확히 하고, 관련된 다양한 정보를 더 효과적으로 검색하고, 검색 결과의 정확도를 높이기 위해 Query Expansion이 필수적입니다. \n\n좀 더 구체적으로, 의료 도메인에서 Query Expansion은 다음과 같은 이유로 필요합니다.\n\n*   **복잡한 의학 용어 및 전문 용어 처리:** 의료 분야는 전문 용어가 많고, 의학 용어가 복잡하게 얽혀 있어, 사용자가 질문을 이해하기 어렵거나, 검색 결과에서 관련 정보를 제대로 찾지 못할 수 있습니다. Query Expansion은 이러한 복잡한 의학 용어와 전문 용어를 더 쉽게 이해할 수 있도록 변환하여 검색 정확도를 높입니다.\n*   **질의의 맥락 이해:** 질문의 의도를 정확하게 파악하는 것이 중요합니다. Query Expansion은 질문의 맥락을 이해하고, 질문의 의도를 반영하여 검색 결과의 관련성을 높입니다.\n*   **다양한 정보 검색:** 의료 분야는 다양한 정보가 섞여 있습니다. Query Expansion은 사용자가 원하는 정보를 더 넓게 검색할 수 있도록 도와줍니다.\n*   **최신 정보 반영:** 의료 분야는 끊임없이 변화합니다. Query Expansion은 최신 의료 정보를 반영하여 검색 결과를 최신 상태로 유지합니다.\n\n요약하자면, Query Expansion은 의료 도메인에서 검색 정확도를 높이고, 사용자가 원하는 정보를 더 쉽게 찾을 수 있도록 돕는 중요한 과정입니다.",
          "39": "법률 도메인에서 Judge 모듈은 사용자의 법률 질의를 평가하여 검색이 필요한지 직접 생성이 필요한지 결정하는 역할을 합니다. 즉, 사용자가 어떤 법률적 질문을 내놓았는지에 따라 적절한 검색 방식을 결정하고, 필요한 경우 직접 법률 해석을 제공합니다.\n\n**핵심:** Judge 모듈은 사용자의 질문을 분석하여 검색이 필요한지 직접 생성이 필요한지 결정하는 핵심적인 역할을 수행합니다.\n",
          "40": "전자상거래 도메인에서 RRR 패턴의 구성 단계는 다음과 같습니다.\n\n1.  **검색 질의를 효과적으로 변형 (Rewrite):** 초기 검색 결과가 부족할 경우 추가 검색을 수행합니다.\n2.  **검색된 정보를 해석 (Read):** 검색된 정보를 분석하여 최적의 답변을 생성합니다.\n3.  **최적의 답변 생성:** LLM Reward RL를 활용하여 AI 모델이 사용자 상호작용 데이터를 학습하여 검색 및 추천 시스템을 지속적으로 개선합니다.\n4.  **Hybrid Search (하이브리드 검색):** Sparse 검색(BM25)과 Dense 검색(임베딩 검색)을 결합하여 검색 성능을 최적화합니다.\n5.  **적응형 검색 및 생성 (Adaptive Retrieval & Generation):** 초기 검색 결과가 부족할 경우 추가 검색을 수행하고, 생성 모델이 정보를 보강하여 최적의 답변을 제공합니다.\n6.  **감성 분석 (Sentiment Analysis):** 뉴스 및 소셜 미디어의 감성 분석을 통해 투자 심리 평가를 수행합니다.\n7.  **뉴스 및 소셜 미디어의 감성 분석을 통해 투자 심리 평가:** 예시: \"테슬라 주가가 최근 하락했지만 소셜 미디어에서 긍정적인 분위기가 나타나 단기 회복 가능성이 있음\"\n\n이러한 단계들을 통해 RAG 기반 검색 시스템을 도메인별 특성에 맞춰 최적화하여 정확성, 신뢰성, 개인화, 실시간성을 극대화할 수 있습니다.\n",
          "41": "GraphRAG의 구성기(Organizer)는 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강하는 역할을 합니다. 즉, 그래프 데이터의 불필요한 정보를 제거하고, 데이터의 품질을 높이는 데 기여합니다.\n\n**답변:** 구성기(Organizer)는 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다.",
          "42": "GraphRAG의 생성기는 쿼리 프로세서로부터 받은 정보를 바탕으로 답변을 생성하는 핵심적인 역할을 수행합니다. 구체적으로 다음과 같은 주요 기능들을 가지고 있습니다.\n\n*   **답변 생성:** 모듈: 검색된 정보를 바탕으로 답변을 생성합니다.\n*   **Operator:** 생성 품질 향상을 위한 미세 조정 및 검증을 통해 데이터 분석 및 최적화 작업을 합니다.\n*   **Generator Fine-tuning:** Instruct-Tuning, Reinforcement Learning, Dual Fine-tuning 등의 방법을 통해 데이터 분석 및 최적화 작업을 수행합니다.\n*   **Verification:** Knowledge-based Verification, Model-based Verification를 통해 데이터 분석 및 최적화 작업을 수행합니다.\n\n요약하자면, 생성기는 쿼리 처리된 정보를 바탕으로 실제 답변을 생성하는 역할을 수행하며, 이는 답변의 품질을 높이는 데 중요한 역할을 합니다.",
          "43": "GraphRAG는 다양한 도메인에 적용 가능한 쿼리 프로세서, 검색기, 구성기, 생성기, 그래프 데이터 소스 다섯 가지 주요 구성 요소로 구성됩니다. GraphRAG는 텍스트, 이미지, 그래프 데이터 등 다양한 형태의 데이터를 활용하여 관계형 지식을 효과적으로 활용합니다.\n\n다음은 GraphRAG의 데이터 소스 예시 세 가지입니다.\n\n1.  **지식 그래프:** 지식 그래프는 엔터티 간의 관계를 기반으로 구축되며, GraphRAG의 핵심 데이터 소스입니다. 예를 들어, 특정 제품에 대한 정보를 담고 있는 지식 그래프는 제품의 특징, 사용 방법, 관련 서비스 등을 포함할 수 있습니다.\n2.  **문서 그래프:** 문서 그래프는 문서 간의 관계를 기반으로 구축되며, GraphRAG의 쿼리 데이터 소스입니다. 예를 들어, 뉴스 기사, 블로그 게시물, 제품 설명서 등 다양한 문서 데이터를 활용하여 질문에 대한 답변을 찾을 수 있습니다.\n3.  **과학 그래프:** 과학 그래프는 과학 연구 분야에서 사용되는 그래프로, 연구 데이터, 실험 결과, 논문 등을 포함할 수 있습니다. GraphRAG는 과학 연구 분야의 데이터를 활용하여 새로운 연구 아이디어를 도출하거나, 연구 결과를 분석하는 데 도움을 받을 수 있습니다.\n\n이러한 데이터 소스들을 활용하여 GraphRAG는 더욱 풍부하고 정확한 정보를 제공하고, 사용자에게 더 유용한 서비스를 제공할 수 있습니다.",
          "44": "Modular RAG에서 'Scheduling' Operator는 RAG 시스템의 전체 흐름을 제어하고 동적으로 의사결정을 내리는 역할을 합니다. 즉, RAG 시스템의 실행 순서를 결정하고, 각 모듈(예: 라우팅, 스케줄링)이 어떤 작업을 수행할지 판단하여 전체 워크플로우를 관리합니다.  규칙 기반의 Judge, LLM 기반의 Judge, Knowledge-guided Scheduling 등의 역할을 수행하며, 이를 통해 시스템의 효율성과 유연성을 높입니다.\n",
          "45": "Fusion Operator는 검색, 생성, 평가 등의 주요 기능을 담당하며, 모듈 내에서 특정 작업을 수행하는 최소 실행 단위입니다. 각 Operator는 독립적으로 작동하며, 입력과 출력만을 노출하여 모듈화와 재사용성을 보장합니다. 제공된 내용에서 각 모듈의 연산자(Operator)들이 특정 작업(예: 청크 최적화, 질의 확장, 검색기 선택 등)을 수행하며, 독립적으로 정의됩니다.\n",
          "46": "Advanced RAG의 쿼리 재작성에 사용되는 기법 'HyDE'는 'Hybrid Enhancement De-fragment'의 약자입니다.",
          "47": "BM25는 검색된 문서의 순위를 재조정하는 검색 방식의 일종입니다.",
          "48": "Modular RAG의 'Componentized Architecture'의 가장 큰 장점은 **유연성 및 유지보수 용이성**입니다. 각 모듈을 독립적으로 관리하고 업그레이드할 수 있기 때문에, 시스템 전체를 수정하지 않고도 쉽게 개선하거나 새로운 기능 추가가 가능합니다. 이는 시스템의 유지보수를 용이하게 하고, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용할 수 있도록 합니다.\n",
          "49": "LinkedIn의 GraphRAG는 쿼리 엔터티 식별 및 의도 감지 단계에서 BERT, E5와 같은 텍스트 임베딩 모델을 사용하여 그래프 노드 값에 대한 임베딩을 생성하고, 벡터 데이터베이스에 저장하여 검색을 용이하게 합니다.\n"
        },
        "reference": {
          "0": "Retrieval-Augmented Generation",
          "1": "색인(Indexing), 검색(Retrieval), 생성(Generation)",
          "2": "색인, 검색, 생성",
          "3": "문서를 청크로 분할 후 임베딩으로 벡터 변환하여 저장하고, 쿼리를 임베딩하여 유사한 청크를 검색 후 LLM에 입력하여 응답 생성",
          "4": "얕은 질의 이해",
          "5": "쿼리 재작성(Query Rewriting), 쿼리 확장(Query Expansion)",
          "6": "재정렬(Re-ranking), 압축(Compression)",
          "7": "독립적인 모듈과 특수 연산자로 구성된 유연하고 확장 가능한 프레임워크",
          "8": "모듈(Module), 하위 모듈(Submodule), 연산자(Operator)",
          "9": "Module: RAG 핵심 단계를 처리; Submodule: 모듈 내 세부 기능; Operator: 특정 기능 구현 단위",
          "10": "라우팅, 스케줄링, 융합 등을 통해 워크플로우 제어",
          "11": "조건부 패턴, 분기 패턴, 루프 패턴",
          "12": "BM25와 벡터 검색",
          "13": "Query Expansion, Query Transformation",
          "14": "Retriever Selection",
          "15": "Rerank, Compression",
          "16": "Generator Fine-tuning, Verification",
          "17": "핵심 기능을 개별 모듈로 분리해 독립적으로 관리 가능",
          "18": "모듈 기반으로 다양한 데이터 소스를 유연하게 조합할 수 있기 때문",
          "19": "조건부 라우팅, 병렬 처리, 순환 흐름 등 동적 워크플로우 구성",
          "20": "쿼리 프로세서, 검색기(Retriever), 구성기(Organizer), 생성기(Generator), 그래프 데이터 소스",
          "21": "관계형 지식 활용을 통한 다단계 추론 및 장기 계획 지원",
          "22": "고객 서비스 이슈 티켓 간 관계 보존으로 검색 정확도 향상",
          "23": "28.6%",
          "24": "간단한 FAQ, 문서 검색",
          "25": "법률, 금융, 의료",
          "26": "복잡한 도메인 지식이 필요한 분야",
          "27": "Naive RAG → Advanced RAG → Modular RAG",
          "28": "LLM이 사실 근거 없이 잘못된 정보를 생성하는 현상",
          "29": "반복, 재귀, 적응형 검색을 통한 상호 의존적 처리",
          "30": "다양한 조건에 따른 파이프라인 선택",
          "31": "병렬 실행을 통해 결과 다양성 증가",
          "32": "검색기와 생성기의 미세 조정을 통해 시스템 성능 최적화",
          "33": "검색된 문서 출처를 명시하는 'Citation' 기능",
          "34": "여러 개의 검색된 문서를 정리하여 최종 후보 선정",
          "35": "검색된 문서에서 핵심 내용 요약",
          "36": "자연스럽고 다양한 표현으로 변환",
          "37": "Text-to-SQL, Sentiment Analysis, Weighted Fusion",
          "38": "다양한 증상 표현을 포괄하여 검색 정확도 향상",
          "39": "질문 유형에 따라 적절한 검색 방식을 결정",
          "40": "Rewrite → Retrieve → Read",
          "41": "그래프 가지치기 및 외부 지식 보강",
          "42": "그래프 정보를 LLM에 공급하여 응답 생성",
          "43": "지식 그래프, 문서 그래프, 과학 그래프",
          "44": "Rule-based 또는 LLM 기반 의사결정 수행",
          "45": "LLM Fusion, Weighted Ensemble, RRF 등을 통해 결과 융합",
          "46": "Hypothetical Document Embeddings",
          "47": "Sparse Retrieval",
          "48": "유지보수가 용이",
          "49": "코사인 유사도"
        },
        "answer_relevancy": {
          "0": 0.8592823124745976,
          "1": 0.732725483415034,
          "2": 0.8846121417951444,
          "3": 0.8361657777825555,
          "4": 0.8081826989530363,
          "5": 0.8831981494451068,
          "6": 0.8986976007949495,
          "7": 0.893030819932234,
          "8": 0.8897524665841843,
          "9": 0.879534492012151,
          "10": 0.8673427835331262,
          "11": 0.8971589215012713,
          "12": 0.9194807563211568,
          "13": 0.9002762822924518,
          "14": 0.8515323059206347,
          "15": 0.7828554449064152,
          "16": 0.7777500762961819,
          "17": 0.8687339156285289,
          "18": 0.9008737479034377,
          "19": 0.8371972348236091,
          "20": 0.8651164608544165,
          "21": 0.9021157448109381,
          "22": 0.7639573519583763,
          "23": 0.8726129681920035,
          "24": 0.8739318231285482,
          "25": 0.9002486138967645,
          "26": 0.9888317900985767,
          "27": 0.7129853776550327,
          "28": 0.9021949201966589,
          "29": 0.8836302616830439,
          "30": 0.8570102564076114,
          "31": 0.7908066106739494,
          "32": 0.9118994199377481,
          "33": 0.8667700079000333,
          "34": 0.9065621212526064,
          "35": 0.8538046064914656,
          "36": 0.8891190048491273,
          "37": 0.8792636334582732,
          "38": 0.8919664522018088,
          "39": 0.8779130857723599,
          "40": 0.8750181624078325,
          "41": 0.8926507208850434,
          "42": 0.8758199994449386,
          "43": 0.8371562305824943,
          "44": 0.9239044509903498,
          "45": 0.84018635584771,
          "46": 0.8584877137065673,
          "47": 0.846360354287439,
          "48": 0.9041755465996489,
          "49": 0.8053072353184941
        },
        "faithfulness": {
          "0": 1.0,
          "1": 0.0,
          "2": 1.0,
          "3": 0.0,
          "4": 1.0,
          "5": 0.5,
          "6": 0.8,
          "7": 0.9473684210526315,
          "8": 0.625,
          "9": 1.0,
          "10": 0.0,
          "11": 0.5,
          "12": 0.5,
          "13": 0.2857142857142857,
          "14": 0.5714285714285714,
          "15": 0.9411764705882353,
          "16": 0.9259259259259259,
          "17": 1.0,
          "18": 1.0,
          "19": 0.7777777777777778,
          "20": 1.0,
          "21": 1.0,
          "22": 1.0,
          "23": 1.0,
          "24": 0.5384615384615384,
          "25": 1.0,
          "26": 1.0,
          "27": 0.0,
          "28": 1.0,
          "29": 1.0,
          "30": 0.8461538461538461,
          "31": 0.0,
          "32": 0.0,
          "33": 0.625,
          "34": 0.0,
          "35": 0.0,
          "36": 0.3333333333333333,
          "37": 1.0,
          "38": 0.9333333333333333,
          "39": 0.8,
          "40": 0.5789473684210527,
          "41": 0.75,
          "42": 0.875,
          "43": 0.4444444444444444,
          "44": 0.8571428571428571,
          "45": 0.5714285714285714,
          "46": 0.0,
          "47": 0.0,
          "48": 0.8571428571428571,
          "49": 0.75
        },
        "context_recall": {
          "0": 1.0,
          "1": 0.0,
          "2": 1.0,
          "3": 0.0,
          "4": 1.0,
          "5": 1.0,
          "6": 1.0,
          "7": 1.0,
          "8": 1.0,
          "9": 1.0,
          "10": 1.0,
          "11": 1.0,
          "12": 0.0,
          "13": 1.0,
          "14": 1.0,
          "15": 1.0,
          "16": 1.0,
          "17": 1.0,
          "18": 1.0,
          "19": 1.0,
          "20": 1.0,
          "21": 1.0,
          "22": 1.0,
          "23": 1.0,
          "24": 1.0,
          "25": 1.0,
          "26": 1.0,
          "27": 0.0,
          "28": 1.0,
          "29": 1.0,
          "30": 1.0,
          "31": 0.0,
          "32": 1.0,
          "33": 1.0,
          "34": 0.0,
          "35": 1.0,
          "36": 1.0,
          "37": 0.0,
          "38": 1.0,
          "39": 1.0,
          "40": 1.0,
          "41": 1.0,
          "42": 1.0,
          "43": 1.0,
          "44": 1.0,
          "45": 1.0,
          "46": 0.0,
          "47": 0.0,
          "48": 1.0,
          "49": 1.0
        },
        "context_precision": {
          "0": 0.99999999999,
          "1": 0.0,
          "2": 0.5238095237964285,
          "3": 0.0,
          "4": 0.5544973544881129,
          "5": 0.7634920634793386,
          "6": 0.7634920634793386,
          "7": 0.99999999999,
          "8": 0.8083900226641885,
          "9": 0.99999999998,
          "10": 0.99999999998,
          "11": 0.23611111109930555,
          "12": 0.6111111110958334,
          "13": 0.7291666666545139,
          "14": 0.249999999975,
          "15": 0.9166666666361111,
          "16": 0.9999999999,
          "17": 0.99999999999,
          "18": 0.99999999998,
          "19": 0.8041666666465626,
          "20": 0.8522817460210924,
          "21": 0.99999999998,
          "22": 0.7555555555303703,
          "23": 0.99999999995,
          "24": 0.9467813051041186,
          "25": 0.8055555555287036,
          "26": 0.99999999998,
          "27": 0.0,
          "28": 0.9999999999,
          "29": 0.7555555555303703,
          "30": 0.5317460317283068,
          "31": 0.0,
          "32": 0.8956845237983276,
          "33": 0.8522817460210924,
          "34": 0.37708333332390626,
          "35": 0.499999999975,
          "36": 0.7499999999625,
          "37": 0.0,
          "38": 0.99999999998,
          "39": 0.9166666666361111,
          "40": 0.3458333333246875,
          "41": 0.9999999999,
          "42": 0.8874999999778125,
          "43": 0.8874999999778125,
          "44": 0.6388888888675925,
          "45": 0.8333333332916666,
          "46": 0.0,
          "47": 0.2916666666520833,
          "48": 0.999999999975,
          "49": 0.36666666664833336
        }
      },
      "average_scores": {
        "answer_relevancy": 0.8643638138761134,
        "faithfulness": 0.6426955920469853,
        "context_recall": 0.82,
        "context_precision": 0.6830296831477924
      }
    }
  }
}