{
  "timestamp": "2025-07-05T07:34:45.377917",
  "evaluation_metrics": [
    "answer_relevancy",
    "faithfulness",
    "context_recall",
    "context_precision"
  ],
  "results": {
    "Naive RAG": {
      "detailed_scores": {
        "user_input": {
          "0": "Modular RAG가 제공하는 주요 특징 두 가지를 쓰시오.",
          "1": "RAG(Retrieval-Augmented Generation)의 세 가지 주요 발전 단계는 무엇인가?",
          "2": "Naive RAG의 한계점 중 “얕은 질의 이해” “검색 노이즈” “고정된 선형 워크플로우”가 의미하는 바를 각각 간단히 설명하시오.",
          "3": "Modular RAG의 3단계 구조를 구성하는 요소는 무엇인가?",
          "4": "GraphRAG(Graph Retrieval-Augmented Generation)의 핵심 구성 요소 다섯 가지를 나열하시오."
        },
        "retrieved_contexts": {
          "0": [
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다."
          ],
          "1": [
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "6. Conclusion 이 리포트에서는 RAG(Retrieval-Augmented Generation)의 발전 방향을 분석하기 위해, 최근 주목받고 있는 Modular RAG를 중심으로 기존 RAG 패러다임(Naive RAG, Advanced RAG)과 비교하고, 새롭게 등장한 GraphRAG까지 다루었습니다. RAG는 LLM의 한계를 보완하며, 보다 신뢰할 수 있는 검색과 응답 생성을 목표로 발전해왔습니다. 기존 Naive RAG는 단순 검색 기반이었으며, Advanced RAG는 검색 최적화를 추가하여 성능을 향상시켰습니다. 이후 Modular RAG는 검색, 생성, 색인 기능을 독립적인 모듈로 분리하여 유연성과 확장성을 극대화하는 구조로 발전했습니다.  그러나 여전히 검색된 정보의 신뢰성과 정확성을 높이는 것이 중요한 과제로 남아 있으며, 이를 해결하기 위해 GraphRAG가 도입되었습니다. GraphRAG는 기존 벡터 검색의 한계를 보완하기 위해 지식 그래프(Knowledge Graph)를 활용한 검색 방식을 도입하여, 문서 간의 관계를 반영한 보다 정밀한 정보를 제공합니다. LinkedIn 사례에서는 GraphRAG 도입 후 검색 정확도 77.6% 향상, BLEU 점수 0.32 증가, 고객 서비스 해결 시간이 28.6% 단축되는 성과를 거두었습니다. 기존 RAG는 벡터 검색(Vector RAG)에 의존했지만, 최근 GraphRAG, Adaptive Retrieval, Multi-Agent RAG 등의 개념이 등장하며 검색 정확도, 신뢰성, 실시간성, 맥락 최적화가 더욱 강화되고 있습니다. 현재까지의 발전 흐름을 보면, 앞으로는 검색 전략을 스스로 최적화하는 자율적 검색 시스템까지 발전될 수 있는 가능성이 있습니다.",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723"
          ],
          "2": [
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담"
          ],
          "3": [
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "3.2 모듈  모듈 정의 모듈은 Modular RAG 시스템의 핵심 구성 블록으로 시스템의 주요 기능이나 임무(예: 정보 검색, 요약, 텍스트 생성 등)를 독립적으로 수행하는 단위입니다. 각 모듈은 특정 작업을 독립적으로 수행하도록 설계되며, 다른 모듈과 별개로 동작할 수 있습니다.  \n모듈의 역할 모듈은 사용자의 요청에 따른 특정 기능을 직접 수행합니다. 모듈은 특정 기능이나 작업을 독립적으로 수행하는 구성 요소입니다. 각 모듈은 전문화된 기능을 담당하며, 에이전트의 지시에 따라 협력하여 최종 목표를 달성합니다.  예를 들어, 검색 모듈은 외부 데이터 소스에서 관련 정보를 검색하고, 생성 모듈은 최종 응답을 생성하는 역할, 데이터 전처리, 텍스트 생성 등의 개별 기능을 담당할 수 있습니다.   \n모듈의 특징 ● 독립성 및 모듈화: 모듈은 독립적인 단위로 설계되어 다른 모듈과 별개로 작동할 수 있으며, 모듈화된 구조를 유지합니다. ● 전문화: 각 모듈은 특정 작업이나 기능에 집중하여 해당 분야에서 최적화되고 전문성을 갖출 수 있습니다. ● 재사용성 및 유연성: 모듈은 시스템 내에서 재사용할 수 있으며, 필요에 따라 쉽게 수정, 교체, 확장할 수 있습니다. 또한, 다른 프로젝트에서도 활용할 수 있습니다. ● 확장성: 새로운 기능이나 서비스가 필요할 경우, 기존 모듈을 확장하거나 새로운 모듈을 추가하여 시스템을 발전시킬 수 있습니다. ● 조합성: 여러 모듈을 결합하여 복잡한 작업을 처리하거나 새로운 기능을 추가할 수 있습니다.\n모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.",
            "Modular RAG에서 AI Agent 아키텍처 Modular RAG(Retrieval-Augmented Generation) 기반 AI 시스템은 정보 검색(Retrieval)과 생성(Generation)을 기능을 모듈화하여 구성된 구조로, 여러 독립적인 모듈을 조합하여 유연하고 확장 가능한 AI를 구축하는 방식입니다. 이 시스템의 핵심 구성 요소는 에이전트(Agent) 모듈(Modules)입니다. 에이전트(Agent)는 전체 워크플로우를 조율하여, 전체시스템의 흐름과 전략적 제어를 담당하는 핵심 역할을 합니다. 기존의 LLM(대규모 언어 모델)이 주로 사전 학습된 지식과 인컨텍스트 학습에 의존하는 것과 달리, 에이전트는 외부 도구(예: 웹 검색, API, 구조화된 데이터베이스)와 동적으로 상호작용하여 그 능력을 확장합니다. 에이전트는 주어진 작업에 따라 어떤 도구를 호출할지 자율적으로 결정하며, 이를 통해 더 정확하고 상황에 맞는 응답을 생성할 수 있습니다. 또한, 에이전트는 고급 라우팅 메커니즘을 활용하여 사용자 쿼리를 분석하고 가장 적합한 데이터 소스나 처리 경로로 안내합니다. 예를 들어, 특정 데이터베이스에서 정보를 검색해야 하는지, 웹 검색을 수행해야 하는지, 또는 도메인 특화 지식을 활용해야 하는지를 스스로 판단할 수 있습니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트"
          ],
          "4": [
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다."
          ]
        },
        "response": {
          "0": "Modular RAG의 주요 특징 두 가지는 다음과 같습니다.\n\n1. **동적 워크플로우:** 질의의 복잡성과 의도에 따라 워크플로우를 동적으로 조정할 수 있습니다. 조건부 실행, 반복적 개선, 병렬 처리 등을 지원하여 정확성과 응답 품질을 높입니다.\n2. **향상된 제어 및 사용자 맞춤 설정:** 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 세밀하게 조정할 수 있으며, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅이 가능합니다.\n</end_of_turn>",
          "1": "RAG(Retrieval-Augmented Generation)의 세 가지 주요 발전 단계는 다음과 같습니다:\n\n1. **Naive RAG:** 가장 기본적인 프레임워크로, 색인, 검색, 생성의 세 가지 핵심 요소로 구성됩니다. 단순한 유사도 계산에 기반한 검색 방식을 사용합니다.\n2. **Advanced RAG:** Naive RAG의 한계를 극복하기 위해 검색 최적화를 추가하여 성능을 향상시킨 단계입니다.\n3. **Modular RAG:** 검색, 생성, 색인 기능을 독립적인 모듈로 분리하여 유연성과 확장성을 극대화하는 구조로 발전했습니다. 이 단계에서는 검색, 생성, 색인 기능을 독립적인 모듈로 분리하고, 각 모듈 내의 기능을 세분화하여 최적화합니다. 또한, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다.\n</end_of_turn>",
          "2": "*   **얕은 질의 이해:** Naive RAG는 사용자의 질문을 단순히 키워드나 벡터의 유사성을 기반으로 해석합니다. 따라서 질문의 숨겨진 의미, 문맥, 의도를 제대로 파악하지 못해 관련 없는 정보를 검색하거나 질문의 핵심을 벗어난 답변을 생성할 수 있습니다.\n*   **검색 노이즈:** Naive RAG는 유사도 기반 검색만으로 문서를 선택하기 때문에, 질문과 관련 없는 불필요한 정보(노이즈)가 함께 검색될 수 있습니다. 이는 모델의 성능을 저하시키고 답변의 정확성을 떨어뜨립니다.\n*   **고정된 선형 워크플로우:** Naive RAG는 검색 후 생성이라는 일직선 형태의 처리 방식을 따릅니다. 검색 단계에서 잘못된 문서가 선택되더라도 이를 수정할 기회가 없어 결과물의 품질이 저하될 수 있습니다. 즉, 오류를 수정하기 어렵고 유연성이 부족합니다.",
          "3": "Modular RAG의 3단계 구조는 다음과 같습니다:\n\n1.  **모듈 (Module):** 시스템의 주요 기능이나 임무(예: 정보 검색, 요약, 텍스트 생성 등)를 독립적으로 수행하는 핵심 구성 블록입니다.\n2.  **하위 모듈 (Sub-module):** 각 모듈 내의 기능을 세분화하고 최적화하는 단위입니다.\n3.  **연산자 (Operator):** 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 가장 기본적인 단위입니다.\n\n요약하자면, Modular RAG는 큰 기능을 모듈로 나누고, 각 모듈을 하위 모듈로 세분화하며, 각 하위 모듈 또는 모듈 내에서 특정 작업을 수행하는 연산자로 구성됩니다.\n</end_of_turn>",
          "4": "GraphRAG의 핵심 구성 요소는 다음과 같습니다:\n\n1. 쿼리 프로세서\n2. 검색기 (Retriever)\n3. 구성기 (Organizer)\n4. 생성기 (Generator)\n5. 그래프 데이터 소스\n</end_of_turn>"
        },
        "reference": {
          "0": "구성 요소 기반 아키텍처(Componentized Architecture): 검색 랭킹 생성 등 핵심 기능을 독립 모듈로 분리해 개별 관리·교체·최적화가 가능 동적 워크플로우(Dynamic Workflow): 질의의 복잡도와 의도에 따라 조건부 실행 반복 개선 병렬 처리 등을 지원해 유연한 처리 흐름을 제공",
          "1": "Naive RAG - Advanced RAG -Modular RAG",
          "2": "얕은 질의 이해 (Shallow Query Understanding): 키워드 또는 벡터 기반 유사도 매칭에 의존해 질의의 의도를 깊이 파악하지 못함 검색 노이즈 (Retrieval Noise): 유사도만으로 문서를 선택하다 보니 불필요한 정보까지 과도하게 포함됨 고정된 선형 워크플로우 (Linear Workflow): 검색 후 곧바로 생성으로 넘어가며 잘못된 검색 결과를 수정할 기회 없이 응답 생성 단계로 전이됨 ",
          "3": "1단계: 모듈(Module) 2단계: 서브모듈(Submodule) 3단계: 연산자(Operator)",
          "4": "쿼리 프로세서(Query Processor) 검색기(Retriever) 구성기(Organizer) 생성기(Generator) 그래프 데이터 소스(Graph Data Source)"
        },
        "answer_relevancy": {
          "0": 0.8968625756765055,
          "1": 0.9042970947819837,
          "2": 0.0,
          "3": 0.8891258294246124,
          "4": 0.8692849360255298
        },
        "faithfulness": {
          "0": 1.0,
          "1": 1.0,
          "2": 1.0,
          "3": 1.0,
          "4": 1.0
        },
        "context_recall": {
          "0": 1.0,
          "1": 1.0,
          "2": 1.0,
          "3": 1.0,
          "4": 1.0
        },
        "context_precision": {
          "0": 0.99999999998,
          "1": 0.999999999975,
          "2": 0.99999999998,
          "3": 0.99999999998,
          "4": 0.8874999999778125
        }
      },
      "average_scores": {
        "answer_relevancy": 0.7119140871817263,
        "faithfulness": 1.0,
        "context_recall": 1.0,
        "context_precision": 0.9774999999785624
      }
    },
    "Advanced RAG": {
      "detailed_scores": {
        "user_input": {
          "0": "Modular RAG가 제공하는 주요 특징 두 가지를 쓰시오.",
          "1": "RAG(Retrieval-Augmented Generation)의 세 가지 주요 발전 단계는 무엇인가?",
          "2": "Naive RAG의 한계점 중 “얕은 질의 이해” “검색 노이즈” “고정된 선형 워크플로우”가 의미하는 바를 각각 간단히 설명하시오.",
          "3": "Modular RAG의 3단계 구조를 구성하는 요소는 무엇인가?",
          "4": "GraphRAG(Graph Retrieval-Augmented Generation)의 핵심 구성 요소 다섯 가지를 나열하시오."
        },
        "retrieved_contexts": {
          "0": [
            "한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담 \n이 표를 통해 각 RAG 방법론의 특징을 비교하고, 프로젝트 목적과 요구사항에 맞는 최적의 방식을 선택하는 데 도움이 될 수 있습니다. Modular RAG는 높은 유연성과 확장성을 제공하여, 특히 복잡한 도메인 지식이 필요한 분야에서 강력한 성능을 발휘할 수 있습니다.\n3. Modular RAG의 주요 구성 요소 Modular RAG에서 계층구조의 구성 요소와 역할과 세부 내용을 알아봅니다. Agent Workflow Module 주요 프로세스(검색, 증강, 생성 등)를 담당 Submodule 모듈 내부에서 세부적인 작업 단계를 처리 Operator 데이터 처리 및 변환과 같은 기본적인 작업 단위를 수행 \n3.1 Agent 기반의 아키텍처 Modular RAG의 핵심 요소 중 하나는 Agent 기반 아키텍처입니다. 기존 AI 에이전트와 비교했을 때, Modular RAG의 에이전트는 다중 모듈을 조율하고 특정 작업을 수행하는 방식으로 설계됩니다. 이를 통해 보다 유연하고 확장 가능한 AI 시스템을 구축할 수 있습니다. \nAI Agent 아키텍처 AI 에이전트는 특정 목표를 달성하기 위해 환경에서 데이터를 감지하고, 해석하며, 행동하는 시스템입니다. AI 에이전트 아키텍처는 인공지능 시스템이 환경을 인식하고, 분석하며, 행동하는 방식을 정의하는 구조적 설계입니다. 이는 AI 에이전트가 자율적으로 작동하고 목표를 달성할 수 있도록 하는 핵심 요소를 포함하며, 다양한 구성 요소와 설계 패턴으로 이루어집니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "3.2 모듈  모듈 정의 모듈은 Modular RAG 시스템의 핵심 구성 블록으로 시스템의 주요 기능이나 임무(예: 정보 검색, 요약, 텍스트 생성 등)를 독립적으로 수행하는 단위입니다. 각 모듈은 특정 작업을 독립적으로 수행하도록 설계되며, 다른 모듈과 별개로 동작할 수 있습니다.  \n모듈의 역할 모듈은 사용자의 요청에 따른 특정 기능을 직접 수행합니다. 모듈은 특정 기능이나 작업을 독립적으로 수행하는 구성 요소입니다. 각 모듈은 전문화된 기능을 담당하며, 에이전트의 지시에 따라 협력하여 최종 목표를 달성합니다.  예를 들어, 검색 모듈은 외부 데이터 소스에서 관련 정보를 검색하고, 생성 모듈은 최종 응답을 생성하는 역할, 데이터 전처리, 텍스트 생성 등의 개별 기능을 담당할 수 있습니다.   \n모듈의 특징 ● 독립성 및 모듈화: 모듈은 독립적인 단위로 설계되어 다른 모듈과 별개로 작동할 수 있으며, 모듈화된 구조를 유지합니다. ● 전문화: 각 모듈은 특정 작업이나 기능에 집중하여 해당 분야에서 최적화되고 전문성을 갖출 수 있습니다. ● 재사용성 및 유연성: 모듈은 시스템 내에서 재사용할 수 있으며, 필요에 따라 쉽게 수정, 교체, 확장할 수 있습니다. 또한, 다른 프로젝트에서도 활용할 수 있습니다. ● 확장성: 새로운 기능이나 서비스가 필요할 경우, 기존 모듈을 확장하거나 새로운 모듈을 추가하여 시스템을 발전시킬 수 있습니다. ● 조합성: 여러 모듈을 결합하여 복잡한 작업을 처리하거나 새로운 기능을 추가할 수 있습니다.\n모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다."
          ],
          "1": [
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "6. Conclusion 이 리포트에서는 RAG(Retrieval-Augmented Generation)의 발전 방향을 분석하기 위해, 최근 주목받고 있는 Modular RAG를 중심으로 기존 RAG 패러다임(Naive RAG, Advanced RAG)과 비교하고, 새롭게 등장한 GraphRAG까지 다루었습니다. RAG는 LLM의 한계를 보완하며, 보다 신뢰할 수 있는 검색과 응답 생성을 목표로 발전해왔습니다. 기존 Naive RAG는 단순 검색 기반이었으며, Advanced RAG는 검색 최적화를 추가하여 성능을 향상시켰습니다. 이후 Modular RAG는 검색, 생성, 색인 기능을 독립적인 모듈로 분리하여 유연성과 확장성을 극대화하는 구조로 발전했습니다.  그러나 여전히 검색된 정보의 신뢰성과 정확성을 높이는 것이 중요한 과제로 남아 있으며, 이를 해결하기 위해 GraphRAG가 도입되었습니다. GraphRAG는 기존 벡터 검색의 한계를 보완하기 위해 지식 그래프(Knowledge Graph)를 활용한 검색 방식을 도입하여, 문서 간의 관계를 반영한 보다 정밀한 정보를 제공합니다. LinkedIn 사례에서는 GraphRAG 도입 후 검색 정확도 77.6% 향상, BLEU 점수 0.32 증가, 고객 서비스 해결 시간이 28.6% 단축되는 성과를 거두었습니다. 기존 RAG는 벡터 검색(Vector RAG)에 의존했지만, 최근 GraphRAG, Adaptive Retrieval, Multi-Agent RAG 등의 개념이 등장하며 검색 정확도, 신뢰성, 실시간성, 맥락 최적화가 더욱 강화되고 있습니다. 현재까지의 발전 흐름을 보면, 앞으로는 검색 전략을 스스로 최적화하는 자율적 검색 시스템까지 발전될 수 있는 가능성이 있습니다."
          ],
          "2": [
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다."
          ],
          "3": [
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담 \n이 표를 통해 각 RAG 방법론의 특징을 비교하고, 프로젝트 목적과 요구사항에 맞는 최적의 방식을 선택하는 데 도움이 될 수 있습니다. Modular RAG는 높은 유연성과 확장성을 제공하여, 특히 복잡한 도메인 지식이 필요한 분야에서 강력한 성능을 발휘할 수 있습니다.\n3. Modular RAG의 주요 구성 요소 Modular RAG에서 계층구조의 구성 요소와 역할과 세부 내용을 알아봅니다. Agent Workflow Module 주요 프로세스(검색, 증강, 생성 등)를 담당 Submodule 모듈 내부에서 세부적인 작업 단계를 처리 Operator 데이터 처리 및 변환과 같은 기본적인 작업 단위를 수행 \n3.1 Agent 기반의 아키텍처 Modular RAG의 핵심 요소 중 하나는 Agent 기반 아키텍처입니다. 기존 AI 에이전트와 비교했을 때, Modular RAG의 에이전트는 다중 모듈을 조율하고 특정 작업을 수행하는 방식으로 설계됩니다. 이를 통해 보다 유연하고 확장 가능한 AI 시스템을 구축할 수 있습니다. \nAI Agent 아키텍처 AI 에이전트는 특정 목표를 달성하기 위해 환경에서 데이터를 감지하고, 해석하며, 행동하는 시스템입니다. AI 에이전트 아키텍처는 인공지능 시스템이 환경을 인식하고, 분석하며, 행동하는 방식을 정의하는 구조적 설계입니다. 이는 AI 에이전트가 자율적으로 작동하고 목표를 달성할 수 있도록 하는 핵심 요소를 포함하며, 다양한 구성 요소와 설계 패턴으로 이루어집니다.",
            "Modular RAG에서 AI Agent 아키텍처 Modular RAG(Retrieval-Augmented Generation) 기반 AI 시스템은 정보 검색(Retrieval)과 생성(Generation)을 기능을 모듈화하여 구성된 구조로, 여러 독립적인 모듈을 조합하여 유연하고 확장 가능한 AI를 구축하는 방식입니다. 이 시스템의 핵심 구성 요소는 에이전트(Agent) 모듈(Modules)입니다. 에이전트(Agent)는 전체 워크플로우를 조율하여, 전체시스템의 흐름과 전략적 제어를 담당하는 핵심 역할을 합니다. 기존의 LLM(대규모 언어 모델)이 주로 사전 학습된 지식과 인컨텍스트 학습에 의존하는 것과 달리, 에이전트는 외부 도구(예: 웹 검색, API, 구조화된 데이터베이스)와 동적으로 상호작용하여 그 능력을 확장합니다. 에이전트는 주어진 작업에 따라 어떤 도구를 호출할지 자율적으로 결정하며, 이를 통해 더 정확하고 상황에 맞는 응답을 생성할 수 있습니다. 또한, 에이전트는 고급 라우팅 메커니즘을 활용하여 사용자 쿼리를 분석하고 가장 적합한 데이터 소스나 처리 경로로 안내합니다. 예를 들어, 특정 데이터베이스에서 정보를 검색해야 하는지, 웹 검색을 수행해야 하는지, 또는 도메인 특화 지식을 활용해야 하는지를 스스로 판단할 수 있습니다.",
            "더 나아가, 에이전트는 ReAct 프로세스(Reasoning + Acting)와 같은 추론 및 라우팅 프레임워크를 활용하여 검색, 의사결정, 생성 단계를 결합하고 반복적으로 결과를 정교화합니다. 이를 통해 복잡한 문제를 관리 가능한 하위 작업으로 분해하고 실시간 또는 도메인별 지식에 접근하며, 다양한 사용자 요구에 동적으로 적응할 수 있습니다. 라우팅과 도구 사용을 통합함으로써 에이전트는 기존 LLM의 한계를 넘어 효율적인 쿼리 처리와 상황에 맞춘 정밀한 응답을 보장합니다. Modular RAG 아키텍처는 전통적인 단일 모델 접근 방식과 달리, 여러 전문화된 모듈과 이를 조율하는 에이전트가 협력하여 정보를 검색, 가공, 생성하는 구조로 설계됩니다. 여기서 모듈은 검색(retrieval), 질의 확장(query expansion), 라우팅(routing) 등의 특정 작업을 수행하는 독립적인 구성 요소로 작동합니다. 이러한 모듈들은 서로 협력하여 사용자 질의를 분석하고, 최적의 처리 경로를 결정하며, 적절한 도구를 호출함으로써 보다 정밀하고 문맥에 맞는 응답을 생성할 수 있도록 합니다. 에이전트는 이러한 모듈을 조율하여 효율적이고 유기적으로 작동하도록 함으로써 최종 목표를 달성합니다. 이러한 구조를 통해, 사용자의 질의에 보다 정교하고 최적화된 응답을 제공할 수 있습니다.  Modular RAG에서 AI Agent 정의 Modular RAG의 AI 에이전트(AI Agent)는 다양한 모듈과 도구와 자율적으로 상호작용하여 특정 목표를 달성하도록 설계된 인공지능 구성 요소입니다. 전체 워크플로우를 조율하고, 전략적 의사결정을 내리며, LLM, 검색 모듈, 프롬프트 및 외부 도구 등을 통합하여 최적의 결과를 도출하는 자율적이고 목표 지향적인 에이전트입니다.   Modular RAG에서 AI Agent 역할 Agent는 전체 시스템을 조율하는 중앙 제어자로, 실행 경로를 동적으로 최적화하는 전략적 의사결정 역할을 수행합니다. 즉, 사용자 요청이나 내부 상황을 분석하여",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트"
          ],
          "4": [
            "Contents 1. Introduction 2. RAG(Retrieval-Augmented Generation)란? 2.1 RAG의 발전 방향 2.2 Naive RAG 핵심 구성 요소 2.3 Advanced RAG 핵심 개선 사항 2.4 Modular RAG (모듈형 RAG) 핵심 개념 3. Modular RAG의 주요 구성 요소 3.1 Agent 기반의 아키텍처 3.2 모듈 3.3 서브모듈 3.4 연산자 3.5 전체적인 구조 예시 3.6 UseCase: Accuracy Improvement 4. Use-case 4.1 도메인별 최적화 전략 4.2 핵심 개념 정리 4.3 의료 도메인 - AI 기반 진단 및 치료 추천 4.4 법률 도메인 - AI 기반 법률 상담 시스템 (Legal RAG) 4.5 금융 도메인 - AI 기반 투자 보고서 생성 및 시장 분석 4.6 전자상거래 도메인 - RRR 기반 AI 개인화 추천 시스템 5. RAG 최신 패러다임 발전 방향 5.1 GraphRAG 배경 5.2 GraphRAG란 무엇인가? 5.3 실제 기업 적용 사례(LinkedIn) 6. Conclusion",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다."
          ]
        },
        "response": {
          "0": "Modular RAG의 주요 특징 두 가지는 다음과 같습니다:\n\n1. **동적 워크플로우:** 질의의 복잡성과 의도에 따라 워크플로우를 동적으로 조정할 수 있습니다.\n2. **향상된 제어 및 사용자 맞춤 설정:** 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 개발자가 세밀하게 조정할 수 있습니다.",
          "1": "RAG(Retrieval-Augmented Generation)의 세 가지 주요 발전 단계는 다음과 같습니다:\n\n1. **Naive RAG:** 단순 검색 기반의 가장 기본적인 형태입니다.\n2. **Advanced RAG:** Naive RAG의 성능을 향상시키기 위해 검색 최적화를 추가했습니다.\n3. **Modular RAG:** RAG 시스템을 LEGO 블록처럼 재구성 가능한 프레임워크로 만드는 것을 목표로 합니다.\n</end_of_turn>",
          "2": "*   **얕은 질의 이해 (Shallow Query Understanding):** Naive RAG는 사용자의 질문(쿼리)을 단순히 키워드나 벡터 기반의 유사성 매칭으로 처리합니다. 질문의 숨겨진 의도나 문맥을 깊이 파악하지 못하기 때문에, 질문의 정확한 의미를 제대로 반영하지 못하는 답변을 생성할 수 있습니다.\n*   **검색 노이즈 (Retrieval Noise):** Naive RAG는 유사도 기반으로 문서를 검색하기 때문에, 질문과 관련 없는 불필요한 정보(노이즈)가 함께 검색될 수 있습니다. 이는 모델이 잘못된 정보를 학습하거나, 답변의 품질을 떨어뜨릴 수 있습니다.\n*   **고정된 선형 워크플로우 (Linear Workflow):** Naive RAG는 \"검색 후 생성(Retrieve-then-Generate)\"이라는 고정된 순서로 처리합니다. 검색 결과에 대한 수정이나 이전 단계의 결과를 반영하는 동적인 처리가 불가능합니다. 즉, 한번 검색된 문서는 수정될 수 없으며, 답변 생성 과정에서 유연하게 조정하기 어렵습니다.",
          "3": "Modular RAG의 3단계 구조는 다음과 같습니다:\n\n1. **Retrieve 모듈:** 사용자의 질의에 대해 적절한 문서를 검색하여 제공합니다.\n2. **Generate 모듈:** 검색된 문서를 기반으로 자연어 응답을 생성합니다.\n3. **하위 모듈:** Retrieve 및 Generate 모듈 내부에서 세부적인 작업 단계를 처리합니다.\n\n하위 모듈은 다음과 같습니다:\n\n*   **Reranker:** 검색된 문서의 순위를 재조정합니다.\n*   **Hybrid Search:** BM25와 벡터 검색을 조합하여 최적화합니다.\n*   **Vector Search:** 임베딩을 활용한 유사도 기반 검색합니다.\n*   **LLM-based Answering:** 대형 언어 모델을 활용하여 답변 생성합니다.\n*   **Template-based Generation:** 특정 패턴을 활용한 규칙 기반 응답 생성합니다.\n*   **Reducer:** 검색된 여러 개의 문서를 정리하여 최종 후보 선정합니다.\n*   **Routing:** 특정 조건에 따라 다른 검색 방식을 선택합니다.\n*   **Summarizer:** 검색된 문서에서 핵심 내용을 요약합니다.\n*   **Paraphraser:** 더 자연스럽고 다양한 표현으로 변환합니다.",
          "4": "GraphRAG(Graph Retrieval-Augmented Generation)의 핵심 구성 요소는 다음과 같습니다:\n\n1. 쿼리 프로세서 (Query Processor)\n2. 검색기 (Retriever)\n3. 구성기 (Organizer)\n4. 생성기 (Generator)\n5. 그래프 데이터 소스 (Graph Data Source)\n</end_of_turn>"
        },
        "reference": {
          "0": "구성 요소 기반 아키텍처(Componentized Architecture): 검색 랭킹 생성 등 핵심 기능을 독립 모듈로 분리해 개별 관리·교체·최적화가 가능 동적 워크플로우(Dynamic Workflow): 질의의 복잡도와 의도에 따라 조건부 실행 반복 개선 병렬 처리 등을 지원해 유연한 처리 흐름을 제공",
          "1": "Naive RAG - Advanced RAG -Modular RAG",
          "2": "얕은 질의 이해 (Shallow Query Understanding): 키워드 또는 벡터 기반 유사도 매칭에 의존해 질의의 의도를 깊이 파악하지 못함 검색 노이즈 (Retrieval Noise): 유사도만으로 문서를 선택하다 보니 불필요한 정보까지 과도하게 포함됨 고정된 선형 워크플로우 (Linear Workflow): 검색 후 곧바로 생성으로 넘어가며 잘못된 검색 결과를 수정할 기회 없이 응답 생성 단계로 전이됨 ",
          "3": "1단계: 모듈(Module) 2단계: 서브모듈(Submodule) 3단계: 연산자(Operator)",
          "4": "쿼리 프로세서(Query Processor) 검색기(Retriever) 구성기(Organizer) 생성기(Generator) 그래프 데이터 소스(Graph Data Source)"
        },
        "answer_relevancy": {
          "0": 0.8968625756765055,
          "1": 0.9043894058453872,
          "2": 0.8368169831263232,
          "3": 0.891251018072987,
          "4": 0.8692795643849746
        },
        "faithfulness": {
          "0": 1.0,
          "1": 1.0,
          "2": 1.0,
          "3": 1.0,
          "4": 1.0
        },
        "context_recall": {
          "0": 1.0,
          "1": 1.0,
          "2": 1.0,
          "3": 1.0,
          "4": 1.0
        },
        "context_precision": {
          "0": 0.99999999998,
          "1": 0.94999999997625,
          "2": 0.99999999998,
          "3": 0.99999999998,
          "4": 0.8874999999778125
        }
      },
      "average_scores": {
        "answer_relevancy": 0.8797199094212356,
        "faithfulness": 1.0,
        "context_recall": 1.0,
        "context_precision": 0.9674999999788124
      }
    },
    "Modular RAG": {
      "detailed_scores": {
        "user_input": {
          "0": "Modular RAG가 제공하는 주요 특징 두 가지를 쓰시오.",
          "1": "RAG(Retrieval-Augmented Generation)의 세 가지 주요 발전 단계는 무엇인가?",
          "2": "Naive RAG의 한계점 중 “얕은 질의 이해” “검색 노이즈” “고정된 선형 워크플로우”가 의미하는 바를 각각 간단히 설명하시오.",
          "3": "Modular RAG의 3단계 구조를 구성하는 요소는 무엇인가?",
          "4": "GraphRAG(Graph Retrieval-Augmented Generation)의 핵심 구성 요소 다섯 가지를 나열하시오."
        },
        "retrieved_contexts": {
          "0": [
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다.",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "• 설계 난이도 및 초기 부담: 모듈을 다수 포함하다보니 워크플로 조정 등 시스템 설계가 어렵고 복잡합니다 arxiv.org . 구성요소 사이 인터페이스를 맞추고 전체 파이프라인을 조율해야 하므로 초기 개발 노력이 많이 들며, 최적화되지 않으면 모듈 간 통신 오버헤드로 응답 지연이 커질 수 있습니다. 또한 체계가 유연한 만큼 표준화된 구성보다는 사례별 맞춤 개발이 필요해 구현 난도가 높습니다. 다만 잘 구축하면 이러한 복잡성을 상쇄할 만큼의 성능과 유연성 이점을 얻을 수 있습니다.\n구분 Naive RAG Advanced RAG Modular RAG \n개념 기본 검색 및 생성 방식 최적화된 검색 및 후처리 적용 모듈화된 검색 및 생성 구조 \n검색 방식 단순 벡터 검색 하이브리드 검색(키워드+시맨틱) 다중 데이터 소스 및 적응형 검색 \n응답 생성 검색된 문서를 그대로 사용 필터링 및 요약 후 생성 최적화된 모듈 기반 응답 생성 \n정확성 검색 품질에 크게 의존 검색 후처리로 정확성 향상 정밀한 필터링 및 다중 데이터 활용 유연성 및 확장성 고정된 검색-생성 구조 제한적인 조정 가능 동적 워크플로우 및 확장 가능한 모듈 구조 \n적용 가능 분야 간단한 FAQ, 문서 검색 법률, 금융, 의료 도메인 적용 가능 실시간 데이터 활용 및 맞춤형 검색 가능 \n장점 ● 단순하고 이해하기 쉬운 기본 접근 방식 \n● Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 보다 개선된 성능 \n● 모듈화된 아키텍처로 독립적인 관리가 가능 ● 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n한계점 \n● 유사도 계산으로 인해 쿼리 이해도가 낮음 ● 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 ● 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음 \n● 고정된 파이프라인 구조로 확장성 부족 ● 여전히 단방향 프로세스라는 구조적 한계를 내포 \n● 초기 설계 복잡 ● 유지보수 부담",
            "● 구성 요소 기반 아키텍처 (Componentized Architecture):  RAG의 핵심 기능(검색, 랭킹, 필터링, 생성 등)을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다. 이를 통해 유지보수가 용이하며, 다양한 도메인 특화 요구 사항에 맞춰 유연하게 적용 가능합니다. ● 동적 워크플로우 (Dynamic Workflow) :  기존 RAG가 고정된 “검색 후 생성” 방식을 따르는 것과 달리, 모듈형 RAG는 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선(Iterative Refinement), 병렬 처리(Parallel Execution) 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다. ● 향상된 제어 및 사용자 맞춤 설정 (Enhanced Control & Customization):  개발자와 시스템 설계자는 검색 전략, 랭킹 알고리즘, 응답 생성 방식을 보다 세밀하게 조정할 수 있습니다. 워크플로우 내 의사결정 요소를 추가하여, 질의의 문맥, 신뢰할 수 있는 데이터 소스, 도메인별 특성을 고려한 동적 경로 라우팅(Dynamic Routing)이 가능합니다. ● 다중 데이터 소스 통합 (Multi-Source Integration):  기존 RAG는 주로 비구조화된 텍스트 검색에 초점을 맞췄지만, Modular RAG는 필요에 따라 동적으로 외부 데이터 소스를 활용하여 지식을 보강하는 흐름을 구성할 수 있습니다. 예를 들어, 웹 검색이 필요한 경우 외부 검색 엔진을 활용하여 최신 정보를 가져오거나, 구조화된 데이터가 필요한 경우 관계형 데이터베이스(SQL)에서 적절한 쿼리를 생성하여 정보를 조회하며, 특정 개념 간의 관계를 분석할 때 지식 그래프(Knowledge Graph)를 활용할 수 있습니다. 또한, 실시간 API(예: 최신 뉴스, 금융 정보)를 통해 동적으로",
            "4. Use-case 앞서 설명한 Modular RAG 아키텍처는 도메인별 최적화된 검색 및 생성 시스템을 구축하는 핵심적인 역할을 합니다. 이를 위해 각 도메인의 특성을 고려하여 에이전트(Agent), 모듈(Module), 연산자(Operator) 를 조합하며, 이를 통해 보다 정교하고 유연한 질의응답 시스템을 설계할 수 있습니다. ● Agent: 전체 시스템을 조율하며, 사용자의 질의를 분석하고 최적의 검색·생성 경로를 결정합니다. ● Module: 검색, 생성, 평가 등의 주요 기능을 담당하며, 도메인별 요구사항에 맞춰 최적화됩니다. ● Operator: 모듈 내부에서 데이터 정제, 필터링, 분석 등의 개별 작업을 수행하는 최소 실행 단위입니다. 이러한 구조를 활용하면, 특정 도메인의 특성에 맞는 검색 및 생성 패턴을 효과적으로 적용할 수 있습니다. 예를 들어, Dense vs Sparse Retrieval 방식은 검색 모듈에서 실행되며, Fusion & Re-rank는 검색 결과를 정렬하고 최적화하는 연산자가 포함된 모듈로 구현됩니다. 또한, LLM Critique처럼 생성된 응답을 평가하는 과정은 Operator 수준에서 작동할 수도 있습니다. 즉, 개별적인 패턴을 단순 적용하는 것이 아니라, Agent가 적절한 Module과 Operator를 조합해 최적화된 검색·생성 프로세스를 유기적으로 실행하는 방식으로 RAG 검색 시스템을 구축할 수 있습니다."
          ],
          "1": [
            "2. RAG(Retrieval-Augmented Generation)란?  기존의 LLM은 사전에 학습된 정보만을 바탕으로 응답을 생성하므로, 최신 정보 반영이 어렵고 지식의 출처를 명확히 할 수 없는 한계를 가집니다. 이에 반해 RAG는 외부 데이터베이스에서 정보를 검색하여 보다 신뢰할 수 있는 응답을 생성하고, 정보를 지속적으로 업데이트하여 도메인 특화 데이터를 반영할 수 있습니다. RAG는 기본적으로 다음과 같은 세 가지 요소로 구성됩니다: ● 색인(Indexing): 문서를 검색 가능한 벡터로 변환 ● 검색(Retrieval): 사용자의 질의에 기반하여 관련 문서를 검색 ● 생성(Generation): 검색된 데이터를 활용하여 LLM이 응답을 생성 최근 LLM의 활용도가 증가함에 따라 LLM이 가진 단점(지식 최신성 부족, 출처 불명확성 등)을 극복할 수 있는 기술로 RAG가 각광받고 있으며, 특히 대규모 데이터 활용이 중요한 법률, 의료, 금융 분야에서 연구가 활발히 진행되고 있습니다. 현재 RAG 관련 연구는 검색 성능 향상, 문맥 최적화, 다양한 데이터 소스 통합 등 다각적인 방향에서 이루어지고 있으며, Modular RAG 개념이 등장하면서 보다 효과적인 정보 검색 및 생성 구조를 구축하는 방향으로 발전하고 있습니다.\n2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "6. Conclusion 이 리포트에서는 RAG(Retrieval-Augmented Generation)의 발전 방향을 분석하기 위해, 최근 주목받고 있는 Modular RAG를 중심으로 기존 RAG 패러다임(Naive RAG, Advanced RAG)과 비교하고, 새롭게 등장한 GraphRAG까지 다루었습니다. RAG는 LLM의 한계를 보완하며, 보다 신뢰할 수 있는 검색과 응답 생성을 목표로 발전해왔습니다. 기존 Naive RAG는 단순 검색 기반이었으며, Advanced RAG는 검색 최적화를 추가하여 성능을 향상시켰습니다. 이후 Modular RAG는 검색, 생성, 색인 기능을 독립적인 모듈로 분리하여 유연성과 확장성을 극대화하는 구조로 발전했습니다.  그러나 여전히 검색된 정보의 신뢰성과 정확성을 높이는 것이 중요한 과제로 남아 있으며, 이를 해결하기 위해 GraphRAG가 도입되었습니다. GraphRAG는 기존 벡터 검색의 한계를 보완하기 위해 지식 그래프(Knowledge Graph)를 활용한 검색 방식을 도입하여, 문서 간의 관계를 반영한 보다 정밀한 정보를 제공합니다. LinkedIn 사례에서는 GraphRAG 도입 후 검색 정확도 77.6% 향상, BLEU 점수 0.32 증가, 고객 서비스 해결 시간이 28.6% 단축되는 성과를 거두었습니다. 기존 RAG는 벡터 검색(Vector RAG)에 의존했지만, 최근 GraphRAG, Adaptive Retrieval, Multi-Agent RAG 등의 개념이 등장하며 검색 정확도, 신뢰성, 실시간성, 맥락 최적화가 더욱 강화되고 있습니다. 현재까지의 발전 흐름을 보면, 앞으로는 검색 전략을 스스로 최적화하는 자율적 검색 시스템까지 발전될 수 있는 가능성이 있습니다.",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723"
          ],
          "2": [
            "초과되어 중요한 정보가 잘려나가거나, 필요 없는 정보가 포함됨으로써 환각(hallucination) 발생 가능성이 증가합니다. ● 고정된 선형 워크플로우 (Linear Workflow):  Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 만약 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다. ● 확장성 문제 (Scalability Issues):  Naive RAG는 고정된 검색-생성 파이프라인을 사용하므로, 데이터가 증가할수록 응답 시간이 길어지고 처리 비용이 증가하는 문제가 발생합니다. 또한, 관계형 데이터베이스나 지식 그래프(knowledge graph)와 같은 구조화된 데이터와의 통합이 어렵습니다. ● 제한적인 프로세스 제어 (Limited Process Control):  사용자가 검색 전략, 랭킹 방식, 응답 생성 프로세스를 세밀하게 조정할 수 있는 기능이 부족합니다. Naive RAG는 블랙박스처럼 작동하여, 특정 검색 및 생성 방식을 조정하는 것이 어렵습니다. \n 2.3 Advanced RAG 핵심 개선 사항 Advanced RAG는 Naive RAG의 한계를 보완하기 위해 질의 변환(Query Rewriting), 재랭킹(Re-ranking), 고급 검색 기법 등의 개선된 기술을 도입해 검색 단계를 최적화하여 검색 효율성을 높이고 검색된 덩어리의 활용을 강화하는 데 중점을 둡니다.",
            "2.1 RAG의 발전 방향 \n RAG에는 대표적으로 Naive RAG, Advanced RAG,  Modular RAG 3가지 방법론이 있으며, 각 방법론의 한계를 극복하기 위해 Naive RAG → Advanced RAG → Modular RAG로 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n2.2 Naive RAG 핵심 구성 요소 Naive RAG는 색인(indexing), 검색(retrieval), 생성(generation)의 세 가지 핵심 요소로 구성된 기본적인 프레임워크입니다. 작동 방식 문서들을 작은 덩어리(chunk)로 분할하고 임베딩 모델을 사용하여 벡터 형태로 변환하여 벡터 데이터베이스에 저장합니다. 사용자 쿼리를 임베딩 모델을 사용하여 벡터로 변환하고, 벡터 데이터베이스에서 쿼리와 가장 유사한 상위 k개의 문서 덩어리를 검색합니다. 검색된 문서 덩어리와 사용자 쿼리를 LLM에 함께 입력하여 최종 답변을 생성합니다. \n특징 단순한 유사도 계산에 기반한 검색 방식으로, 복잡한 시나리오에 적용하기 어렵습니다. \n한계 \n ● 얕은 질의 이해 (Shallow Query Understanding):  Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적(ambiguous) 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪으며, 그 결과 관련성이 낮거나 불완전한 검색 결과를 반환할 가능성이 높습니다. ● 검색 노이즈 (Retrieval Noise):  Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.검색된 정보가 너무 많아지면 모델의 문맥 창(context window)이",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "특징 검색 단계의 정교한 처리를 통해 검색 정확도와 효율성을 향상시키지만, 여전히 복잡한 실제 응용 요구 사항을 충족하는 데 한계가 있습니다. \n한계 \n ● 고정적인 파이프라인 (Rigid Pipeline): 고급 RAG는 검색 전략을 향상 시켰지만, 전체적인 프로세스 구조는 여전히 고정된 방식을 유지하고 있습니다. 즉, 개별 검색 단계는 정교해졌지만 전체 시스템이 모듈화되지 않았으며, 유연하게 적응할 수 있는 구조가 부족합니다. ● 제한적인 동적 적응 (Limited Dynamic Adaptation): 고급 RAG는 검색 효율성을 높였지만, 반복적인 개선(iterative refinement)이나 다중 경로(multi-path) 처리를 완전히 지원하지 못합니다. 대부분의 질의 처리는 사전 정의된 방식에 따라 이루어져, 실시간으로 조정하거나 변화하는 정보 요구사항에 맞춰 즉각적으로 적응하기 어렵습니다.\n● 복잡한 사용자 맞춤 설정 (Complex Customization): 고급 RAG는 재랭킹 및 질의 변환 등의 개선된 기능을 제공하지만, 설정이 여전히 복잡하며, 개발자가 다양한 매개변수를 수동으로 조정해야 합니다. 또한, 모듈형 설계가 부족하여 시스템을 다시 구성하는 것이 어렵고 시간이 많이 소요됩니다.  \n2.4 Modular RAG (모듈형 RAG) 핵심 개념 Modular RAG는 기존 RAG의 한계를 극복하기 위해 개발된 유연하고 확장 가능한 프레임워크로, 독립적인 모듈과 특수 연산자로 구성된 구조를 통해 검색과 응답 생성의 제어력, 확장성, 효율성을 극대화합니다. 기존의 고정된 검색-생성 선형 파이프라인에서 벗어나, 라우팅, 스케줄링, 융합 메커니즘을 통합하는 고급 설계를 적용하여 보다 재구성이 용이한 시스템을 제공합니다.",
            "2.4 주요 RAG 방법론 적용을 위한 비교 각 RAG 방법론은 특정 상황과 목적에 따라 장점과 한계가 다르므로, 적절한 방법론을 선택하고 적용하는 것이 중요합니다. Naive RAG는 가장 단순한 구조로 빠르게 구현할 수 있지만, 검색 노이즈와 정확도 문제를 가지고 있습니다. Advanced RAG는 검색 최적화 기술을 도입하여 정확도를 높이지만 여전히 고정된 워크플로우를 따릅니다. 반면, Modular RAG는 독립적인 모듈 기반 설계를 통해 유연성과 확장성을 극대화할 수 있어 다양한 조건에 맞춰 최적화가 가능합니다.  옵션 1.) 간단한 장단점 비교 RAG 유형 장점 단점 Naive RAG - 단순하고 이해하기 쉬운 기본 접근 방식 - 유사도 계산으로 인해 쿼리 이해도가 낮음 - 검색 노이즈로 인해 불필요한 정보가 들어가게 됨 - 고정된 선형 워크플로우로 인해 이전 결과를 수정할 수 없음\nAdvanced RAG - Indexing, Pre-Retrieval, Post-Retrieval 등 고급 검색 기법을 도입하여 Naive RAG 의 한계를 개선 - Naive RAG 와 같이, 여전히 단방향 프로세스라는 구조적 한계를 내포 \nModular RAG - 모듈화된 아키텍처로 독립적인 관리가 가능 - 양방향 프로세스로 조건부 처리, 사용자 개입 등 높은 유연성과 확장성을 제공 \n- 초기 설계 시 구현 복잡성이 높음 \n 옵션 2.) 상세 비교 비교 기준 Naive RAG Advanced RAG Modular RAG 검색 방식 (Search Method) • 단순 벡터 유사도 검색: 사용자의 질의를 임베딩으로 변환한 뒤 벡터 DB 등에서 유사도가 가장 높은 문서 조각들을 Top-N으로 검색합니다 ibm.com . 일반적으로 한 번의 질의로 얻은 결과만 사용하며, 키워드 매칭이나 임베딩 기반 검색 중 하나의 기법에 주로 의존합니다."
          ],
          "3": [
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "3.2 모듈  모듈 정의 모듈은 Modular RAG 시스템의 핵심 구성 블록으로 시스템의 주요 기능이나 임무(예: 정보 검색, 요약, 텍스트 생성 등)를 독립적으로 수행하는 단위입니다. 각 모듈은 특정 작업을 독립적으로 수행하도록 설계되며, 다른 모듈과 별개로 동작할 수 있습니다.  \n모듈의 역할 모듈은 사용자의 요청에 따른 특정 기능을 직접 수행합니다. 모듈은 특정 기능이나 작업을 독립적으로 수행하는 구성 요소입니다. 각 모듈은 전문화된 기능을 담당하며, 에이전트의 지시에 따라 협력하여 최종 목표를 달성합니다.  예를 들어, 검색 모듈은 외부 데이터 소스에서 관련 정보를 검색하고, 생성 모듈은 최종 응답을 생성하는 역할, 데이터 전처리, 텍스트 생성 등의 개별 기능을 담당할 수 있습니다.   \n모듈의 특징 ● 독립성 및 모듈화: 모듈은 독립적인 단위로 설계되어 다른 모듈과 별개로 작동할 수 있으며, 모듈화된 구조를 유지합니다. ● 전문화: 각 모듈은 특정 작업이나 기능에 집중하여 해당 분야에서 최적화되고 전문성을 갖출 수 있습니다. ● 재사용성 및 유연성: 모듈은 시스템 내에서 재사용할 수 있으며, 필요에 따라 쉽게 수정, 교체, 확장할 수 있습니다. 또한, 다른 프로젝트에서도 활용할 수 있습니다. ● 확장성: 새로운 기능이나 서비스가 필요할 경우, 기존 모듈을 확장하거나 새로운 모듈을 추가하여 시스템을 발전시킬 수 있습니다. ● 조합성: 여러 모듈을 결합하여 복잡한 작업을 처리하거나 새로운 기능을 추가할 수 있습니다.\n모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.",
            "Modular RAG에서 AI Agent 아키텍처 Modular RAG(Retrieval-Augmented Generation) 기반 AI 시스템은 정보 검색(Retrieval)과 생성(Generation)을 기능을 모듈화하여 구성된 구조로, 여러 독립적인 모듈을 조합하여 유연하고 확장 가능한 AI를 구축하는 방식입니다. 이 시스템의 핵심 구성 요소는 에이전트(Agent) 모듈(Modules)입니다. 에이전트(Agent)는 전체 워크플로우를 조율하여, 전체시스템의 흐름과 전략적 제어를 담당하는 핵심 역할을 합니다. 기존의 LLM(대규모 언어 모델)이 주로 사전 학습된 지식과 인컨텍스트 학습에 의존하는 것과 달리, 에이전트는 외부 도구(예: 웹 검색, API, 구조화된 데이터베이스)와 동적으로 상호작용하여 그 능력을 확장합니다. 에이전트는 주어진 작업에 따라 어떤 도구를 호출할지 자율적으로 결정하며, 이를 통해 더 정확하고 상황에 맞는 응답을 생성할 수 있습니다. 또한, 에이전트는 고급 라우팅 메커니즘을 활용하여 사용자 쿼리를 분석하고 가장 적합한 데이터 소스나 처리 경로로 안내합니다. 예를 들어, 특정 데이터베이스에서 정보를 검색해야 하는지, 웹 검색을 수행해야 하는지, 또는 도메인 특화 지식을 활용해야 하는지를 스스로 판단할 수 있습니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트",
            "3단계 구조: ● 1단계 (모듈): RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다. ● 2단계 (하위 모듈): 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다. ● 3단계 (연산자): 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.  3단계 구조 예시 \n모듈 Retrieve 모듈 사용자의 질의에 대해 적절한 문서를 검색하여 제공 \nGenerate 모듈 검색된 문서를 기반으로 자연어 응답을 생성 \n하위 모듈 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 \n● LLM-based Answering: 대형 언어 모델을 활용하여 답변 생성 ● Template-based Generation: 특정 패턴을 활용한 규칙 기반 응답 생성\n연산자 ● Reranker: 검색된 문서의 순위를 재조정 ● Hybrid Search: BM25와 벡터 검색을 조합하여 최적화 ● Vector Search: 임베딩을 활용한 유사도 기반 검색 ● Reducer: 검색된 여러 개의 문서를 정리하여 최종 후보 선정 ● Routing: 특정 조건에 따라 다른 검색 방식을 선택 \n● Summarizer: 검색된 문서에서 핵심 내용을 요약 ● Paraphraser: 더 자연스럽고 다양한 표현으로 변환",
            "3.5 전체적인 구조 예시 Modular RAG의 관점에서 예를 들어 보겠습니다. agent를 생성할 때 LLM, tools, prompt가 필요로 합니다. 여기서 \"Tools는 특정 작업(예: 검색, 계산)을 수행하는 독립적인 리소스로 사용될 수 있으며, 필요에 따라 이를 모듈처럼 활용하거나 모듈이 호출하는 외부 리소스로 간주할 수도 있습니다. 즉, LLM이 호출되기 전에 Tools를 모듈로 간주할 수 있습니다. Tools가 특정 작업을 수행하기 위한 독립적인 기능 단위로 존재하며, 시스템 내에서 모듈처럼 작동합니다. 그렇다면 이 tools안에 있는 하나하나의 tool을 하위 모듈이라고 볼 수 있습니다. 연산자는 하위 모듈 내에서 데이터 처리, 계산, 조건부 제어 등 단일 작업을 하는 최소 단위의 실행 컴포넌트입니다.\n다음은 사례를 통한 예시입니다. 상황에 따라서 operator은 Sub-module에 속하지 않을 수도 있습니다. ─ Agent: 검색 에이전트     ├── Module: 데이터 검색 모듈     │   ├── Operator: 로그 기록 연산자 (모듈 레벨에서 동작)     │   ├── Sub-module: 웹 스크래퍼 (Web Scraping)     │   │   ├── Operator: 파싱 연산자    │   │   ├── Operator: 데이터 필터링 연산자    │   ├── Sub-module: API 호출 (Tavily API)     │   │   ├── Operator: 응답 데이터 정제 연산자    │   │   ├── Operator: 검색 결과 랭킹 연산자",
            "3.2 모듈  모듈 정의 모듈은 Modular RAG 시스템의 핵심 구성 블록으로 시스템의 주요 기능이나 임무(예: 정보 검색, 요약, 텍스트 생성 등)를 독립적으로 수행하는 단위입니다. 각 모듈은 특정 작업을 독립적으로 수행하도록 설계되며, 다른 모듈과 별개로 동작할 수 있습니다.  \n모듈의 역할 모듈은 사용자의 요청에 따른 특정 기능을 직접 수행합니다. 모듈은 특정 기능이나 작업을 독립적으로 수행하는 구성 요소입니다. 각 모듈은 전문화된 기능을 담당하며, 에이전트의 지시에 따라 협력하여 최종 목표를 달성합니다.  예를 들어, 검색 모듈은 외부 데이터 소스에서 관련 정보를 검색하고, 생성 모듈은 최종 응답을 생성하는 역할, 데이터 전처리, 텍스트 생성 등의 개별 기능을 담당할 수 있습니다.   \n모듈의 특징 ● 독립성 및 모듈화: 모듈은 독립적인 단위로 설계되어 다른 모듈과 별개로 작동할 수 있으며, 모듈화된 구조를 유지합니다. ● 전문화: 각 모듈은 특정 작업이나 기능에 집중하여 해당 분야에서 최적화되고 전문성을 갖출 수 있습니다. ● 재사용성 및 유연성: 모듈은 시스템 내에서 재사용할 수 있으며, 필요에 따라 쉽게 수정, 교체, 확장할 수 있습니다. 또한, 다른 프로젝트에서도 활용할 수 있습니다. ● 확장성: 새로운 기능이나 서비스가 필요할 경우, 기존 모듈을 확장하거나 새로운 모듈을 추가하여 시스템을 발전시킬 수 있습니다. ● 조합성: 여러 모듈을 결합하여 복잡한 작업을 처리하거나 새로운 기능을 추가할 수 있습니다.\n모듈과 Tools의 관계 Agent 시스템에서는 필요에 따라 특정 모듈을 Tools로 간주하고 사용할 수 있습니다.  Agent에서 사용하는 많은 Tools는 보통 모듈 내부에서 생성되거나 관리되지만, 경우에 따라 독립적으로 존재하는 Tools를 직접 호출하기도 합니다.",
            "Modular RAG에서 AI Agent 아키텍처 Modular RAG(Retrieval-Augmented Generation) 기반 AI 시스템은 정보 검색(Retrieval)과 생성(Generation)을 기능을 모듈화하여 구성된 구조로, 여러 독립적인 모듈을 조합하여 유연하고 확장 가능한 AI를 구축하는 방식입니다. 이 시스템의 핵심 구성 요소는 에이전트(Agent) 모듈(Modules)입니다. 에이전트(Agent)는 전체 워크플로우를 조율하여, 전체시스템의 흐름과 전략적 제어를 담당하는 핵심 역할을 합니다. 기존의 LLM(대규모 언어 모델)이 주로 사전 학습된 지식과 인컨텍스트 학습에 의존하는 것과 달리, 에이전트는 외부 도구(예: 웹 검색, API, 구조화된 데이터베이스)와 동적으로 상호작용하여 그 능력을 확장합니다. 에이전트는 주어진 작업에 따라 어떤 도구를 호출할지 자율적으로 결정하며, 이를 통해 더 정확하고 상황에 맞는 응답을 생성할 수 있습니다. 또한, 에이전트는 고급 라우팅 메커니즘을 활용하여 사용자 쿼리를 분석하고 가장 적합한 데이터 소스나 처리 경로로 안내합니다. 예를 들어, 특정 데이터베이스에서 정보를 검색해야 하는지, 웹 검색을 수행해야 하는지, 또는 도메인 특화 지식을 활용해야 하는지를 스스로 판단할 수 있습니다.",
            "- Beyond the Training Set: Empowering LLMs to Seek Knowledge https://blog.boxcars.ai/p/beyond-the-training-set-empowering  - Evolution of RAGs: Naive RAG, Advanced RAG, and Modular RAG Architectures https://www.marktechpost.com/2024/04/01/evolution-of-rags-naive-rag-advanced-rag-and-modular-rag-architectures/  - Agentic Retrieval-Augmented Generation: A Survey on Agentic RAG https://arxiv.org/html/2501.09136v1   2번파트 - Modular RAG: Transforming RAG Systems into LEGO-like Reconfigurable Frameworks https://arxiv.org/pdf/2407.21059 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e 3번 파트 - LLM RAG Paradigms: Naive RAG, Advanced RAG & Modular RAG https://medium.com/@drjulija/what-are-naive-rag-advanced-rag-modular-rag-paradigms-edff410c202e  - Retrieval-Augmented Generation for Large Language Models: A Survey https://arxiv.org/pdf/2312.10997v5 5번 파트"
          ],
          "4": [
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다.",
            "핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.\n ● 쿼리 프로세서: GraphRAG에서 쿼리는 텍스트, 분자 그래프용 SMILES 문자열, 또는 장면 그래프와 텍스트 명령의 조합과 같은 다양한 형식을 가질 수 있습니다. 쿼리 프로세서는 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용하여 쿼리를 전처리합니다. ● 검색기 (Retriever): GraphRAG의 검색기는 휴리스틱 기반, 학습 기반, 도메인 특정 검색기 등으로 분류될 수 있으며, 그래프 구조 신호를 캡처하는 데 중점을 둡니다. 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다. ● 구성기 (Organizer): 검색된 그래프에서 노이즈와 불필요한 정보를 제거하기 위해 그래프 가지치기(pruning) 방법을 사용하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다. ● 생성기 (Generator): 그래프 정보를 LLM에 공급하기 위해 다양한 방법이 사용됩니다. 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다. ● 그래프 데이터 소스: GraphRAG는 지식 그래프, 문서 그래프, 과학 그래프, 소셜 그래프, 계획 및 추론 그래프, 테이블 그래프, 인프라 그래프, 생물학적 그래프, 장면 그래프, 랜덤 그래프 등 다양한 도메인에 적용될 수 있습니다. 특징 ● 관계형 지식 활용: 그래프 구조의 연결성을 통해 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. ● 다양한 데이터 형식 처리: 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다.",
            "그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.\n관계형 지식 활용의 필요성 GraphRAG는 그래프 구조의 연결성을 활용하여 다단계 추론 및 장기 계획에 필요한 정보를 캡처할 수 있습니다. 예를 들어, 지식 그래프에서 엔터티 간의 관계를 탐색하거나, 문서 그래프에서 문서 간의 연결을 분석하여 질문에 대한 답변을 찾을 수 있습니다. \n다양한 데이터 형식 처리 GraphRAG는 텍스트, 이미지 외에 다양한 그래프 구조 데이터를 처리할 수 있습니다. 이는 기존 RAG가 처리하기 어려웠던 복잡한 데이터 형식을 포괄할 수 있게 해줍니다. \nAI 연구의 패러다임 변화 AI 연구가 모델 중심에서 데이터 중심으로 전환되면서, 데이터의 품질과 관련성이 결과에 미치는 영향이 커졌습니다. 따라서 그래프 데이터 소스를 효과적으로 구축하고 관리하는 것이 중요해졌으며, 이는 GraphRAG의 발전을 촉진했습니다. \n5.2 GraphRAG란 무엇인가? \n GraphRAG (Graph Retrieval-Augmented Generation)는 그래프 구조화된 데이터를 활용하여 검색 증강 생성(RAG)의 효율성을 높이는 기술입니다. 기존 RAG와 달리, GraphRAG는 그래프의 연결성을 이용하여 외부 정보 소스에서 추가 정보를 검색하고 활용합니다.\n핵심 구성 요소 GraphRAG는 쿼리 프로세서, 검색기(retriever), 구성기(organizer), 생성기(generator), 그래프 데이터 소스의 다섯 가지 주요 구성 요소로 이루어져 있습니다.",
            "- https://medium.com/@OpenRAG/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3   6번파트 - Retrieval-Augmented Generation with Graphs (GraphRAG) https://arxiv.org/pdf/2501.00309  7번파트 - LinkedIn used Graph RAG to cut down their ticket resolution time from 40 hrs to 15 hrs. Let's make a library to make it accessible to everyone? https://www.reddit.com/r/LangChain/comments/1dlwc39/linkedin_used_graph_rag_to_cut_down_their_ticket/?rdt=37604 - Retrieval-Augmented Generation with Knowledge Graphs for Customer Service Question Answering https://arxiv.org/pdf/2404.17723",
            "개선점 ● RRR 패턴을 활용하여 사용자 질의를 최적화하고 추천 정확도를 향상 ● 실시간 트렌드와 고객 리뷰를 반영하여 보다 개인화된 제품 추천 제공 ● 강화 학습을 통해 추천 품질을 지속적으로 개선하고 자동 최적화를 구현\n5. RAG 최신 패러다임 발전 방향 위에서 살펴본 Naive RAG , Advanced RAG , Modular RAG 3가지는 Vector RAG(벡터 검색 기반 RAG)에 속합니다. 검색 기반은 문서 간의 관계를 명확히 이해하지 못하는 한계가 있습니다. 그래서  문서에서 추출한 정보를 그래프 구조로 저장하고 관계성을 활용하여 검색 정확도를 높이는 방향으로 GraphRAG가 등장하게 되었습니다. 최신 RAG 시스템에서는 Modular RAG 구조를 채택하면서 GraphRAG를 부분적으로 포함하는 사례도 증가하고 있습니다. \n5.1 GraphRAG 배경  GraphRAG(Graph Retrieval-Augmented Generation)는 그래프 구조화된 정보의 활용을 통해 검색 증강 생성(RAG)의 효율성을 높이기 위해 등장했습니다. \n RAG의 한계 기존의 RAG는 주로 텍스트나 이미지와 같은 독립적인 데이터를 처리하는 데 중점을 둡니다. 하지만 실제 많은 정보가 그래프 형태로 연결되어 있으며, 이러한 관계성을 활용하지 못하면 다단계 추론 및 장기 계획과 같은 복잡한 작업을 수행하기 어렵습니다. 텍스트나 이미지처럼 획일적인 형식으로 표현될 수 없는 다양한 형식을 포괄하지 못한다는 한계도 존재합니다. \n그래프 구조 데이터의 중요성 실제 세계의 데이터는 다양한 관계를 내포하고 있으며, 이는 소셜 네트워크, 지식 그래프, 분자 구조 등 다양한 형태로 표현될 수 있습니다. 그래프 형태의 데이터는 이질적인 정보와 도메인별 관계 지식을 포함할 수 있습니다. 이러한 관계형 지식을 효과적으로 활용하기 위해 GraphRAG가 필요하게 되었습니다.",
            "한계 GraphRAG는 여러 분야에서 활용될 수 있지만, 그래프 구성, 검색, 구성, 생성 등 각 구성 요소와 시스템 전체의 효율성, 확장성, 신뢰성 측면에서 해결해야 할 과제들이 남아 있습니다. ● 그래프 구성: 작업에 맞는 그래프 구조 결정, 다양한 형식의 그래프 표현 방식 고려, 멀티모달 데이터 통합 문제 해결. ● 검색: 쿼리와 관련된 정보 검색, 검색 깊이 조정, 지식 충돌 해결. ● 구성: 그래프 크기 축소 및 노이즈 제거, 외부 지식을 이용한 그래프 보강. ● 생성: 그래프 구조 정보를 효과적으로 활용, 과학 그래프에서 정확한 구조 생성. ● 시스템 통합: 구성 요소 간의 원활한 상호 작용 보장 및 전체 시스템 최적화. ● 확장성: 데이터 증가에 따른 시스템 성능 유지. ● 신뢰성: ○ 개인 정보 보호: 민감한 데이터 보호를 위한 개인 정보 보호 기술 필요. ○ 설명 가능성: 추론 과정을 명확하게 설명하여 시스템에 대한 신뢰도 향상 . ● 평가: 구성 요소별 성능 평가, 종단 간 벤치마크, 작업 및 도메인별 평가, 신뢰성 벤치마크 필요. ● 새로운 응용 분야: 다양한 도메인에 GraphRAG를 적용하기 위한 맞춤형 전략 개발.  \n5.3 실제 기업 적용 사례(LinkedIn)   LinkedIn은 고객 서비스 기술 지원을 개선하기 위해 Knowledge Graph와 RAG(Retrieval-Augmented Generation)를 통합한 시스템을 개발했습니다. 기존의 벡터 기반 검색 RAG 시스템이 내부 구조와 이슈 간 관계를 무시하여 검색 정확도가 저하되는 문제가 있었습니다. 또한 임베딩 모델의 세분화 프로세스 중 콘텐츠가 단절되어 불완전한 답변이 발생하는 문제도 발생했습니다. 이를 해결하기 위해 Knowledge Graph를 통합한 GraphRAG를 도입하여, 과거 이슈의 구조와 상호 관계를 보존하면서 검색 정확도를 향상시켰습니다."
          ]
        },
        "response": {
          "0": "Modular RAG의 주요 특징 두 가지는 다음과 같습니다.\n\n1. **구성 요소 기반 아키텍처 (Componentized Architecture):** RAG의 핵심 기능을 개별 모듈로 분리하여 독립적으로 관리할 수 있습니다. 각 모듈을 업그레이드, 교체, 최적화할 수 있어, 전체 시스템을 수정하지 않고도 쉽게 개선할 수 있습니다.\n2. **동적 워크플로우 (Dynamic Workflow):** 질의의 복잡성과 의도에 따라 동적으로 워크플로우를 조정할 수 있습니다. 조건부 실행, 반복적 개선, 병렬 처리 등을 지원하여 더 높은 정확성과 응답 품질을 제공합니다.\n",
          "1": "Naive RAG, Advanced RAG, Modular RAG입니다. 각 방법론은 이전 단계의 한계를 극복하기 위해 발전하면서 점진적으로 성능과 유연성을 향상시켜 왔습니다.\n",
          "2": "*   **얕은 질의 이해 (Shallow Query Understanding):** Naive RAG는 키워드 또는 벡터 기반의 유사성 매칭을 주로 사용하므로, 질의를 깊이 이해하지 못하는 경우가 많습니다. 다의적 질의, 복합적인 질문, 또는 문맥이 중요한 요청을 처리하는 데 어려움을 겪습니다.\n*   **검색 노이즈 (Retrieval Noise):** Naive RAG는 단순한 유사성 측정을 바탕으로 문서를 선택하기 때문에, 과도하거나 불필요한 정보까지 검색하는 경우가 많습니다.\n*   **고정된 선형 워크플로우 (Linear Workflow):** Naive RAG는 검색 후 생성(Retrieve-then-Generate)이라는 고정된 일직선 처리 방식을 따릅니다. 검색 과정에서 잘못된 문서가 선택되면, 이를 수정할 기회 없이 그대로 응답 생성 단계로 넘어가게 되어 결과물의 품질이 저하됩니다.\n",
          "3": "Modular RAG의 3단계 구조는 다음과 같습니다.\n\n*   **1단계 (모듈):** RAG의 핵심 단계를 독립적인 모듈로 처리하고, 모듈 간의 조정을 제어하는 오케스트레이션 모듈을 도입합니다.\n*   **2단계 (하위 모듈):** 각 모듈 내의 기능을 세분화하고 최적화하는 하위 모듈로 구성됩니다.\n*   **3단계 (연산자):** 모듈 또는 하위 모듈 내에서 특정 기능 구현을 담당하는 기본 연산자 단위입니다.",
          "4": "GraphRAG(Graph Retrieval-Augmented Generation)의 핵심 구성 요소는 다음과 같습니다:\n\n1.  **쿼리 프로세서:** 쿼리를 전처리하여 엔터티 인식, 관계 추출, 쿼리 구조화, 쿼리 분해, 쿼리 확장 등의 기술을 사용합니다.\n2.  **검색기 (Retriever):** 그래프 구조 신호를 캡처하는 데 중점을 두며, 그래프 기반 인코더 (GNN)를 사용하여 노드, 엣지 및 (하위)그래프를 임베딩합니다.\n3.  **구성기 (Organizer):** 검색된 그래프에서 노이즈와 불필요한 정보를 제거하고, 외부 데이터나 LLM에 내장된 지식을 이용하여 그래프를 보강합니다.\n4.  **생성기 (Generator):** 그래프 정보를 LLM에 공급하기 위해 다양한 방법을 사용하며, 과학 그래프 도메인에서는 정확한 구조 생성을 위해 LLM 기반 방법 외에 그래프 기반 생성기를 사용하기도 합니다.\n5.  **그래프 데이터 소스:** 지식 그래프, 문서 그래프, 과학 그래프 등 다양한 도메인의 그래프 데이터를 제공합니다.\n"
        },
        "reference": {
          "0": "구성 요소 기반 아키텍처(Componentized Architecture): 검색 랭킹 생성 등 핵심 기능을 독립 모듈로 분리해 개별 관리·교체·최적화가 가능 동적 워크플로우(Dynamic Workflow): 질의의 복잡도와 의도에 따라 조건부 실행 반복 개선 병렬 처리 등을 지원해 유연한 처리 흐름을 제공",
          "1": "Naive RAG - Advanced RAG -Modular RAG",
          "2": "얕은 질의 이해 (Shallow Query Understanding): 키워드 또는 벡터 기반 유사도 매칭에 의존해 질의의 의도를 깊이 파악하지 못함 검색 노이즈 (Retrieval Noise): 유사도만으로 문서를 선택하다 보니 불필요한 정보까지 과도하게 포함됨 고정된 선형 워크플로우 (Linear Workflow): 검색 후 곧바로 생성으로 넘어가며 잘못된 검색 결과를 수정할 기회 없이 응답 생성 단계로 전이됨 ",
          "3": "1단계: 모듈(Module) 2단계: 서브모듈(Submodule) 3단계: 연산자(Operator)",
          "4": "쿼리 프로세서(Query Processor) 검색기(Retriever) 구성기(Organizer) 생성기(Generator) 그래프 데이터 소스(Graph Data Source)"
        },
        "answer_relevancy": {
          "0": 0.8968625756765055,
          "1": 0.8504732979000401,
          "2": 0.8401336050139515,
          "3": 0.891418496256331,
          "4": 0.8692558672894094
        },
        "faithfulness": {
          "0": 1.0,
          "1": 1.0,
          "2": 1.0,
          "3": 1.0,
          "4": 1.0
        },
        "context_recall": {
          "0": 1.0,
          "1": 1.0,
          "2": 1.0,
          "3": 1.0,
          "4": 1.0
        },
        "context_precision": {
          "0": 0.99999999999,
          "1": 0.999999999975,
          "2": 0.8874999999778125,
          "3": 0.9317956349089874,
          "4": 0.8522817460210924
        }
      },
      "average_scores": {
        "answer_relevancy": 0.8696287684272475,
        "faithfulness": 1.0,
        "context_recall": 1.0,
        "context_precision": 0.9343154761745784
      }
    }
  }
}